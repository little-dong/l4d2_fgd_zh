//     1011111111111111111111111111111111111111111111111111111111 
//     1000111111111110000000000000000000000000000011111111111000 
//     1011100000000001111111111111111111111111111100000000001100 
//     1011100000000011111111100111111111001111111110000000001110 
//     101101     111111100000111111111110000001111111      00110 
//     101100   11111110001    11110001111   100001111111   00110 
//     101100 1011110001      101101 001101     1000111100  00110 
//     101100111111001       101100   001101       00011111100110 
//     1011111111001        101110     011101        001111111110 
//     10111111100          01110       01110         00111111110 
//     1011111100          011101       101110         0011111110 
//     101111100          001101         101100         001111110 
//     101111101         101100           001101         00111110 
//     10111100         101110             001101        10111110 
//     1011110          01111111111111111111111101        0011110 
//     1011100         001111111010101010111111110        1011110 
//     1011100        00111111111111111111111111100       1011110 
//     1011100       1011111111111111111111111111101       011110 
//     1011100      101111111111111111111111111111101      011110           
//     1011100     10111111111111111111111111111111101    1011110           
//     1011110     01110111111100010000010111111100110    0011110           
//     10111100   001101 01111111111111111111110  01110  10111110           
//     101111101 101100  10110             01101  101101 00111110           
//     101111100111100    10110           01101    10111001111110  
//     10111111011110      01101         00100      0011111111110  
//     1011111111110        01101       10110        001111111110  
//     1011111111100        10110      101101       1001111100110 
//     101100111111001       10100     01101      100111111100110 
//     10110111111111000      01101   00101     10001111111111110 
//     101111111011111100001   1110  10111   10001111101101111110  
//     101111110  111111110000101111101110000001111111   10111110  
//     101111101    111111111101111101111111111111111     0011110  
//     1011111011111111111111111111111111111111111111110111011100  
//     1000000000000000000000000000000000000000000000000000000000 
//
//		原FGD文件出自：https://github.com/TeamSpen210/HammerAddons
//		使用ChatGpt翻译
@mapsize(-16384, 16384)

@AutoVisgroup = "Auto"
	[
	"Auto"
		[
		"commentary_auto"
		"commentary_dummy"
		"commentary_zombie_spawner"
		"point_commentary_node"
		]
	"Brush Entities"
		[
		"color_correction_volume"
		"env_bubbles"
		"env_embers"
		"fog_volume"
		"func_breakable"
		"func_breakable_surf"
		"func_brush"
		"func_buildable_button"
		"func_button"
		"func_clip_vphysics"
		"func_conveyor"
		"func_door"
		"func_door_rotating"
		"func_dustcloud"
		"func_dustmotes"
		"func_elevator"
		"func_fish_pool"
		"func_guntarget"
		"func_illusionary"
		"func_movelinear"
		"func_physbox"
		"func_physbox_multiplayer"
		"func_plat"
		"func_platrot"
		"func_precipitation"
		"func_precipitation_blocker"
		"func_pushable"
		"func_rotating"
		"func_tankmortar"
		"func_tanktrain"
		"func_tracktrain"
		"func_train"
		"func_traincontrols"
		"func_vehicleclip"
		"func_wall"
		"func_wall_toggle"
		"func_water"
		"func_water_analog"
		"game_zone_player"
		"momentary_rot_button"
		"trigger_active_weapon_detect"
		"trigger_auto_crouch"
		"trigger_autosave"
		"trigger_brush"
		"trigger_changelevel"
		"trigger_escape"
		"trigger_finale"
		"trigger_gravity"
		"trigger_hurt"
		"trigger_hurt_ghost"
		"trigger_impact"
		"trigger_look"
		"trigger_playermovement"
		"trigger_proximity"
		"trigger_push"
		"trigger_remove"
		"trigger_serverragdoll"
		"trigger_standoff"
		"trigger_teleport"
		"trigger_togglesave"
		"trigger_tonemap"
		"trigger_transition"
		"trigger_upgrade_laser_sight"
		"trigger_vphysics_motion"
		"trigger_wind"
		]
	"Commentary"
		[
		"commentary_auto"
		"commentary_dummy"
		"commentary_zombie_spawner"
		"point_commentary_node"
		]
	"Gameplay"
		[
		"env_hudhint"
		"env_instructor_hint"
		"func_button"
		"func_button_timed"
		"func_door"
		"func_door_rotating"
		"func_ladder"
		"func_ladderendpoint"
		"func_monitor"
		"func_rot_button"
		"func_useableladder"
		"game_text"
		"info_camera_link"
		"info_l4d1_survivor_spawn"
		"info_ladder_dismount"
		"info_player_start"
		"info_target_instructor_hint"
		"logic_active_autosave"
		"logic_autosave"
		"momentary_rot_button"
		"point_camera"
		"point_message"
		"point_teleport"
		"prop_door_rotating"
		"prop_door_rotating_checkpoint"
		"trigger_autosave"
		"trigger_teleport"
		]
	"Instances"
		[
		"func_instance"
		]
	"Lights"
		[
		"beam_spotlight"
		"env_cubemap"
		"info_no_dynamic_shadow"
		"light"
		"light_directional"
		"light_environment"
		"light_spot"
		"point_spotlight"
		]
	"NPCs"
		[
		"npc_bullseye"
		"npc_enemyfinder"
		]
	"Nodes"
		[
		"info_node"
		"info_node_air"
		"info_node_air_hint"
		"info_node_climb"
		"info_node_hint"
		"info_node_link"
		"info_node_link_controller"
		"info_radial_link_controller"
		]
	"Notes"
		[
		"hammer_notes"
		]
	"Overlays"
		[
		"info_overlay"
		]
	"Point Entities"
		[
		"ambient_generic"
		"ambient_music"
		"color_correction"
		"comp_choreo_sceneset"
		"comp_relay"
		"env_beam"
		"env_blood"
		"env_detail_controller"
		"env_dof_controller"
		"env_dustpuff"
		"env_effectscript"
		"env_entity_igniter"
		"env_entity_maker"
		"env_explosion"
		"env_fade"
		"env_fire"
		"env_fog_controller"
		"env_global"
		"env_glow"
		"env_laser"
		"env_lightglow"
		"env_particlelight"
		"env_particlescript"
		"env_rock_launcher"
		"env_rockettrail"
		"env_rotorshooter"
		"env_screeneffect"
		"env_screenoverlay"
		"env_shake"
		"env_shooter"
		"env_smokestack"
		"env_smoketrail"
		"env_soundscape"
		"env_soundscape_proxy"
		"env_soundscape_triggerable"
		"env_spark"
		"env_speaker"
		"env_splash"
		"env_sprite"
		"env_sprite_oriented"
		"env_spritetrail"
		"env_sun"
		"env_tonemap_controller"
		"env_tonemap_controller_ghost"
		"env_tonemap_controller_infected"
		"env_viewpunch"
		"env_wind"
		"env_zoom"
		"filter_activator_class"
		"filter_activator_context"
		"filter_activator_infected_class"
		"filter_activator_mass_greater"
		"filter_activator_model"
		"filter_activator_name"
		"filter_activator_team"
		"filter_base"
		"filter_damage_type"
		"filter_enemy"
		"filter_health"
		"filter_melee_damage"
		"filter_multi"
		"func_instance_io_proxy"
		"func_instance_parms"
		"game_end"
		"game_gib_manager"
		"game_player_equip"
		"game_ui"
		"game_weapon_manager"
		"generic_actor"
		"info_constraint_anchor"
		"info_landmark"
		"info_map_parameters"
		"info_map_parameters_versus"
		"info_mass_center"
		"info_particle_system"
		"info_projecteddecal"
		"info_target"
		"info_target_instructor_hint"
		"info_teleport_destination"
		"infodecal"
		"keyframe_rope"
		"keyframe_track"
		"light_environment"
		"logic_active_autosave"
		"logic_auto"
		"logic_autosave"
		"logic_branch"
		"logic_branch_listener"
		"logic_case"
		"logic_choreographed_scene"
		"logic_collision_pair"
		"logic_compare"
		"logic_director_query"
		"logic_game_event"
		"logic_lineto"
		"logic_measure_movement"
		"logic_multicompare"
		"logic_navigation"
		"logic_relay"
		"logic_scene_list_manager"
		"logic_script"
		"logic_timer"
		"logic_versus_random"
		"material_modify_control"
		"math_colorblend"
		"math_counter"
		"math_remap"
		"move_rope"
		"npc_template_maker"
		"path_corner"
		"path_corner_crash"
		"path_track"
		"phys_ballsocket"
		"phys_constraint"
		"phys_constraintsystem"
		"phys_convert"
		"phys_hinge"
		"phys_keepupright"
		"phys_lengthconstraint"
		"phys_magnet"
		"phys_motor"
		"phys_pulleyconstraint"
		"phys_ragdollconstraint"
		"phys_ragdollmagnet"
		"phys_slideconstraint"
		"phys_spring"
		"phys_thruster"
		"phys_torque"
		"point_anglesensor"
		"point_angularvelocitysensor"
		"point_broadcastclientcommand"
		"point_clientcommand"
		"point_proximity_sensor"
		"point_servercommand"
		"point_teleport"
		"point_template"
		"point_tesla"
		"point_velocitysensor"
		"point_viewcontrol"
		"point_viewcontrol_multiplayer"
		"point_viewcontrol_survivor"
		"postprocess_controller"
		"scripted_sequence"
		"shadow_control"
		"sky_camera"
		"spark_shower"
		"trigger_soundscape"
		"vgui_screen"
		"vgui_slideshow_display"
		"water_lod_control"
		]
	"Postcompiler"
		[
		"comp_adv_output"
		"comp_entity_finder"
		"comp_entity_mover"
		"comp_flicker"
		"comp_kv_setter"
		"comp_numeric_transition"
		"comp_pack"
		"comp_pack_rename"
		"comp_pack_replace_soundscript"
		"comp_player_input_helper"
		"comp_precache_model"
		"comp_precache_sound"
		"comp_prop_cable"
		"comp_prop_cable_dynamic"
		"comp_prop_rope"
		"comp_prop_rope_bunting"
		"comp_prop_rope_dynamic"
		"comp_propcombine_set"
		"comp_propcombine_volume"
		"comp_scriptvar_setter"
		"comp_sequential_call"
		"comp_vactube_spline"
		]
	"Prop Control"
		[
		"point_posecontroller"
		]
	"Tool Brushes"
		[
		"func_areaportal"
		"func_areaportalwindow"
		]
	"Vehicles"
		[
		"prop_vehicle_choreo_generic"
		"prop_vehicle_driveable"
		]
	"Weapons"
		[
		"prop_minigun"
		"prop_minigun_l4d1"
		"weapon_adrenaline_spawn"
		"weapon_ammo_spawn"
		"weapon_autoshotgun_spawn"
		"weapon_chainsaw_spawn"
		"weapon_defibrillator_spawn"
		"weapon_first_aid_kit"
		"weapon_first_aid_kit_spawn"
		"weapon_gascan_spawn"
		"weapon_grenade_launcher"
		"weapon_grenade_launcher_spawn"
		"weapon_hunting_rifle_spawn"
		"weapon_item_spawn"
		"weapon_melee_spawn"
		"weapon_molotov_spawn"
		"weapon_pain_pills_spawn"
		"weapon_pipe_bomb_spawn"
		"weapon_pistol_magnum_spawn"
		"weapon_pistol_spawn"
		"weapon_pumpshotgun_spawn"
		"weapon_rifle_ak47_spawn"
		"weapon_rifle_desert_spawn"
		"weapon_rifle_m60_spawn"
		"weapon_rifle_sg552_spawn"
		"weapon_rifle_spawn"
		"weapon_scavenge_item_spawn"
		"weapon_shotgun_chrome_spawn"
		"weapon_shotgun_spas_spawn"
		"weapon_smg_mp5_spawn"
		"weapon_smg_silenced_spawn"
		"weapon_smg_spawn"
		"weapon_sniper_awp_spawn"
		"weapon_sniper_military_spawn"
		"weapon_sniper_scout_spawn"
		"weapon_spawn"
		"weapon_upgradepack_explosive_spawn"
		"weapon_upgradepack_incendiary_spawn"
		"weapon_vomitjar_spawn"
		]
	"World Details"
		[
		"physics_cannister"
		"prop_car_alarm"
		"prop_car_glass"
		"prop_detail"
		"prop_detail_sprite"
		"prop_dynamic"
		"prop_dynamic_ornament"
		"prop_dynamic_override"
		"prop_physics"
		"prop_physics_multiplayer"
		"prop_physics_override"
		"prop_physics_respawnable"
		"prop_ragdoll"
		"prop_sphere"
		"prop_static"
		"simple_physics_brush"
		"simple_physics_prop"
		]
	]
@AutoVisgroup = "Brush Entities"
	[
	"Breakables"
		[
		"func_breakable"
		"func_breakable_surf"
		]
	"Clips"
		[
		"func_clip_vphysics"
		"func_precipitation_blocker"
		"func_vehicleclip"
		]
	"Conveyors"
		[
		"func_conveyor"
		]
	"Dynamic Water"
		[
		"func_water"
		"func_water_analog"
		]
	"FX"
		[
		"env_bubbles"
		"env_embers"
		"func_dustcloud"
		"func_dustmotes"
		"func_fish_pool"
		"func_precipitation"
		]
	"FX Swap Triggers"
		[
		"color_correction_volume"
		"fog_volume"
		"trigger_tonemap"
		]
	"Func Brush"
		[
		"func_brush"
		"func_illusionary"
		"func_wall"
		"func_wall_toggle"
		]
	"LOD Brushes"
		[
		"func_lod"
		]
	"Linear Movement"
		[
		"func_buildable_button"
		"func_button"
		"func_door"
		"func_elevator"
		"func_movelinear"
		"func_plat"
		"func_platrot"
		]
	"Physbox"
		[
		"func_physbox"
		"func_physbox_multiplayer"
		"func_pushable"
		]
	"Rotational Movement"
		[
		"func_door_rotating"
		"func_platrot"
		"func_rotating"
		"momentary_rot_button"
		]
	"Tanks"
		[
		"func_tankmortar"
		"func_tanktrain"
		]
	"Trains"
		[
		"func_guntarget"
		"func_tanktrain"
		"func_tracktrain"
		"func_train"
		"func_traincontrols"
		]
	"Triggers"
		[
		"game_zone_player"
		"trigger_active_weapon_detect"
		"trigger_auto_crouch"
		"trigger_autosave"
		"trigger_brush"
		"trigger_changelevel"
		"trigger_escape"
		"trigger_finale"
		"trigger_gravity"
		"trigger_hurt"
		"trigger_hurt_ghost"
		"trigger_impact"
		"trigger_look"
		"trigger_playermovement"
		"trigger_proximity"
		"trigger_push"
		"trigger_remove"
		"trigger_serverragdoll"
		"trigger_standoff"
		"trigger_teleport"
		"trigger_togglesave"
		"trigger_transition"
		"trigger_upgrade_laser_sight"
		"trigger_vphysics_motion"
		"trigger_wind"
		]
	]
@AutoVisgroup = "Gameplay"
	[
	"Autosaves"
		[
		"logic_active_autosave"
		"logic_autosave"
		"trigger_autosave"
		]
	"Buttons"
		[
		"func_button"
		"func_button_timed"
		"func_rot_button"
		"momentary_rot_button"
		]
	"Doors"
		[
		"func_door"
		"func_door_rotating"
		"prop_door_rotating"
		"prop_door_rotating_checkpoint"
		]
	"Ladders"
		[
		"func_ladder"
		"func_ladderendpoint"
		"func_useableladder"
		"info_ladder_dismount"
		]
	"Player Spawn"
		[
		"info_l4d1_survivor_spawn"
		"info_player_start"
		]
	"RT Camera"
		[
		"func_monitor"
		"info_camera_link"
		"point_camera"
		]
	"Teleporters"
		[
		"point_teleport"
		"trigger_teleport"
		]
	"Text/Hints"
		[
		"env_hudhint"
		"env_instructor_hint"
		"game_text"
		"info_target_instructor_hint"
		"point_message"
		]
	]
@AutoVisgroup = "Lights"
	[
	"Cubemaps"
		[
		"env_cubemap"
		]
	"Directional Light"
		[
		"light_directional"
		]
	"Dynamic"
		[
		"light_dynamic"
		]
	"Environment Light"
		[
		"light_environment"
		]
	"Info_Lighting"
		[
		"info_no_dynamic_shadow"
		]
	"Light FX"
		[
		"beam_spotlight"
		"point_spotlight"
		]
	"Proj. Texture"
		[
		"env_projectedtexture"
		]
	"Static"
		[
		"light"
		"light_environment"
		"light_spot"
		]
	]
@AutoVisgroup = "NPCs"
	[
	"Furniture"
		[
		"npc_furniture"
		]
	"Logical"
		[
		"npc_bullseye"
		"npc_enemyfinder"
		]
	]
@AutoVisgroup = "Overlays"
	[
	"Overlay"
		[
		"info_overlay"
		]
	"Texture Toggle"
		[
		"env_texturetoggle"
		]
	"Water Overlay"
		[
		"info_overlay_transition"
		]
	]
@AutoVisgroup = "Point Entities"
	[
	"Camera Control"
		[
		"point_viewcontrol"
		"point_viewcontrol_multiplayer"
		"point_viewcontrol_survivor"
		]
	"Choreo Scenes"
		[
		"comp_choreo_sceneset"
		"logic_choreographed_scene"
		"logic_scene_list_manager"
		"scripted_sequence"
		]
	"Decals"
		[
		"info_projecteddecal"
		"infodecal"
		]
	"Effects"
		[
		"env_beam"
		"env_blood"
		"env_dustpuff"
		"env_effectscript"
		"env_entity_igniter"
		"env_explosion"
		"env_fire"
		"env_glow"
		"env_laser"
		"env_lightglow"
		"env_particlelight"
		"env_particlescript"
		"env_rock_launcher"
		"env_rockettrail"
		"env_rotorshooter"
		"env_shooter"
		"env_smokestack"
		"env_smoketrail"
		"env_spark"
		"env_splash"
		"env_sun"
		"info_particle_system"
		"point_tesla"
		"spark_shower"
		]
	"Filters"
		[
		"filter_activator_class"
		"filter_activator_context"
		"filter_activator_infected_class"
		"filter_activator_mass_greater"
		"filter_activator_model"
		"filter_activator_name"
		"filter_activator_team"
		"filter_base"
		"filter_damage_type"
		"filter_enemy"
		"filter_health"
		"filter_melee_damage"
		"filter_multi"
		]
	"Global FX"
		[
		"env_fade"
		"env_screeneffect"
		"env_screenoverlay"
		"env_shake"
		"env_viewpunch"
		"env_zoom"
		]
	"Globals"
		[
		"color_correction"
		"env_detail_controller"
		"env_dof_controller"
		"env_fog_controller"
		"env_global"
		"env_tonemap_controller"
		"env_tonemap_controller_ghost"
		"env_tonemap_controller_infected"
		"env_wind"
		"game_end"
		"game_gib_manager"
		"game_weapon_manager"
		"info_landmark"
		"info_map_parameters"
		"info_map_parameters_versus"
		"light_environment"
		"logic_autosave"
		"point_broadcastclientcommand"
		"point_clientcommand"
		"point_servercommand"
		"postprocess_controller"
		"shadow_control"
		"sky_camera"
		"water_lod_control"
		]
	"Logic"
		[
		"comp_relay"
		"func_instance_io_proxy"
		"func_instance_parms"
		"logic_active_autosave"
		"logic_auto"
		"logic_autosave"
		"logic_branch"
		"logic_branch_listener"
		"logic_case"
		"logic_collision_pair"
		"logic_compare"
		"logic_director_query"
		"logic_game_event"
		"logic_lineto"
		"logic_measure_movement"
		"logic_multicompare"
		"logic_navigation"
		"logic_relay"
		"logic_script"
		"logic_timer"
		"logic_versus_random"
		"material_modify_control"
		"math_colorblend"
		"math_counter"
		"math_remap"
		"phys_convert"
		"point_anglesensor"
		"point_angularvelocitysensor"
		"point_proximity_sensor"
		"point_teleport"
		"point_velocitysensor"
		]
	"Null"
		[
		"info_null"
		]
	"Paths"
		[
		"keyframe_track"
		"path_corner"
		"path_corner_crash"
		"path_track"
		]
	"Physics"
		[
		"info_constraint_anchor"
		"info_mass_center"
		"phys_ballsocket"
		"phys_constraint"
		"phys_constraintsystem"
		"phys_hinge"
		"phys_keepupright"
		"phys_lengthconstraint"
		"phys_magnet"
		"phys_motor"
		"phys_pulleyconstraint"
		"phys_ragdollconstraint"
		"phys_ragdollmagnet"
		"phys_slideconstraint"
		"phys_spring"
		"phys_thruster"
		"phys_torque"
		]
	"Player"
		[
		"game_end"
		"game_player_equip"
		"game_ui"
		]
	"Ropes"
		[
		"keyframe_rope"
		"move_rope"
		]
	"Sounds"
		[
		"ambient_generic"
		"ambient_music"
		"env_speaker"
		"generic_actor"
		]
	"Soundscapes"
		[
		"env_soundscape"
		"env_soundscape_proxy"
		"env_soundscape_triggerable"
		"trigger_soundscape"
		]
	"Sprites"
		[
		"env_sprite"
		"env_sprite_oriented"
		"env_spritetrail"
		]
	"Targets"
		[
		"info_target"
		"info_target_instructor_hint"
		"info_teleport_destination"
		]
	"Templates"
		[
		"env_entity_maker"
		"npc_template_maker"
		"point_template"
		]
	"VGUI"
		[
		"vgui_screen"
		"vgui_slideshow_display"
		]
	]
@AutoVisgroup = "Postcompiler"
	[
	"Entity Finders"
		[
		"comp_entity_finder"
		"comp_entity_mover"
		]
	"Logic"
		[
		"comp_adv_output"
		"comp_flicker"
		"comp_numeric_transition"
		"comp_player_input_helper"
		"comp_sequential_call"
		]
	"Packing"
		[
		"comp_pack"
		"comp_pack_rename"
		"comp_pack_replace_soundscript"
		]
	"Precaching"
		[
		"comp_precache_model"
		"comp_precache_sound"
		]
	"Prop Ropes"
		[
		"comp_prop_cable"
		"comp_prop_cable_dynamic"
		"comp_prop_rope"
		"comp_prop_rope_bunting"
		"comp_prop_rope_dynamic"
		]
	"Propcombine"
		[
		"comp_propcombine_set"
		"comp_propcombine_volume"
		]
	"Sceneset"
		[
		"comp_choreo_sceneset"
		]
	"Setters"
		[
		"comp_kv_setter"
		"comp_scriptvar_setter"
		]
	"Vactubes"
		[
		"comp_vactube_spline"
		]
	]
@AutoVisgroup = "Prop Control"
	[
	"Pose Controller"
		[
		"point_posecontroller"
		]
	]
@AutoVisgroup = "Tool Brushes"
	[
	"Areaportals"
		[
		"func_areaportal"
		"func_areaportalwindow"
		]
	"Occluders"
		[
		"func_occluder"
		]
	"Propcombine"
		[
		"comp_propcombine_volume"
		]
	"Viscluster"
		[
		"func_viscluster"
		]
	]
@AutoVisgroup = "Triggers"
	[
	"Death Triggers"
		[
		"trigger_hurt"
		"trigger_hurt_ghost"
		]
	"Ent Destruction"
		[
		"trigger_remove"
		]
	"Force Triggers"
		[
		"trigger_gravity"
		"trigger_impact"
		"trigger_push"
		"trigger_vphysics_motion"
		"trigger_wind"
		]
	"Level Transitions"
		[
		"trigger_changelevel"
		"trigger_finale"
		"trigger_transition"
		]
	"Player Movement Triggers"
		[
		"trigger_auto_crouch"
		"trigger_playermovement"
		]
	"Trigger Multiple"
		[
		"trigger_multiple"
		]
	"Trigger Once"
		[
		"trigger_once"
		]
	]
@AutoVisgroup = "World Details"
	[
	"Func Detail"
		[
		"func_detail"
		]
	"Props"
		[
		"physics_cannister"
		"prop_car_alarm"
		"prop_car_glass"
		"prop_detail"
		"prop_detail_sprite"
		"prop_dynamic"
		"prop_dynamic_ornament"
		"prop_dynamic_override"
		"prop_physics"
		"prop_physics_multiplayer"
		"prop_physics_override"
		"prop_physics_respawnable"
		"prop_ragdoll"
		"prop_sphere"
		"prop_static"
		"simple_physics_brush"
		"simple_physics_prop"
		]
	]
@AutoVisgroup = "Logic"
	[
	"Sensors"
		[
		"point_anglesensor"
		"point_angularvelocitysensor"
		"point_proximity_sensor"
		"point_velocitysensor"
		]
	]
@AutoVisgroup = "Props"
	[
	"Dynamic"
		[
		"prop_car_alarm"
		"prop_dynamic"
		"prop_dynamic_ornament"
		"prop_dynamic_override"
		]
	"Physics"
		[
		"physics_cannister"
		"prop_car_glass"
		"prop_physics"
		"prop_physics_multiplayer"
		"prop_physics_override"
		"prop_physics_respawnable"
		"prop_ragdoll"
		"prop_sphere"
		"simple_physics_brush"
		"simple_physics_prop"
		]
	"Static Lighting Origins"
		[
		"info_lighting"
		]
	"Static"
		[
		"prop_detail"
		"prop_detail_sprite"
		"prop_static"
		]
	]
@AutoVisgroup = "Physics"
	[
	"Ragdoll"
		[
		"prop_ragdoll"
		]
	]

@BaseClass = Angles
    [
    angles(angle) : "俯仰 偏航 横滚 (Y Z X)" : "0 0 0" : "这个实体在世界中的方向。俯仰是围绕 Y 轴的旋转，偏航是围绕 Z 轴的旋转，横滚是围绕 X 轴的旋转。"
    ]

@BaseClass = BModelParticleSpawner
    [
    solid(choices) readonly : "固体" : 0 : "需要将其设置为零以允许其不发生碰撞。" =
        [
        0: "非固体"
        ]

    origin(origin) readonly : "起始点" : : "如果偏移，这将被打破。"
    startdisabled(choices) : "开始时禁用" : 0 =
        [
        0: "否"
        1: "是"
        ]

    color(color255) : "粒子颜色 (R G B)" : "255 255 255"
    spawnrate(integer) : "每秒粒子数量" : 40 : "每秒产生的粒子数量。"
    speedmax(integer) : "最大粒子速度" : 13 : "粒子产生后可移动的最大速度。"
    lifetimemin(integer) : "最小粒子寿命" : 3 : "每个粒子死亡之前的最小秒数。粒子的寿命在此值和“最大粒子寿命”之间的随机持续时间内。"
    lifetimemax(integer) : "最大粒子寿命" : 5 : "每个粒子死亡之前的最大秒数。粒子的寿命在“最小粒子寿命”和此值之间的随机持续时间内。将被限制为最大值 15。"
    distmax(integer) : "最大可见距离" : 1024 : "粒子可见的最大距离。它们在这个距离上变得半透明。"
    frozen(choices) : "冻结" : 0 : "设置后，此实体立即产生 SpawnRate 数量的粒子，然后变为非活动状态。" =
        [
        0: "否"
        1: "是"
        ]

    nowind(choices) : "不受风影响" : 0 : "设置后，风不会影响此实体的粒子。" =
        [
        0: "否"
        1: "是"
        ]


    // 输入
    input TurnOn(void) : "打开。"
    input TurnOff(void) : "关闭。"
    ]

@BaseClass = BaseEntityInputs
    [

    // 输入
    input Kill(void) : "从世界中移除此实体。"
    input KillHierarchy(void) : "从世界中移除此实体及其所有子级。"
    input AddOutput(string) : "向此实体添加或动态更改实体 I/O 连接的键值对。格式为：\n'<output name> <targetname>:<inputname>:<parameter>:<delay>:<max times to fire (-1 == infinite, 1 = only once)>'\n或者 'keyvalue newval'。非常危险，请小心使用。"
    input FireUser1(void) : "导致此实体的 OnUser1 输出被触发。"
    input FireUser2(void) : "导致此实体的 OnUser2 输出被触发。"
    input FireUser3(void) : "导致此实体的 OnUser3 输出被触发。"
    input FireUser4(void) : "导致此实体的 OnUser4 输出被触发。"
    input Use(void) : "与玩家调用 +use 相同；可能不会做任何事情。也可以通过创建不指定输入的输出来调用。"
    input RunScriptFile(string) : "从磁盘执行游戏脚本文件。"
    input RunScriptCode(script) : "执行一串脚本源代码字符串。如果需要传递字符串，使用双引号会损坏 VMF，请改用反引号（ ` ）。"
    input CallScriptFunction(string) : "执行给定的函数名称。"
    ]

@BaseClass = BaseEntityOutputs
    [

    // 输出
    output OnUser1(void) : "响应 FireUser1 输入触发。"
    output OnUser2(void) : "响应 FireUser2 输入触发。"
    output OnUser3(void) : "响应 FireUser3 输入触发。"
    output OnUser4(void) : "响应 FireUser4 输入触发。"
    ]

@BaseClass = BaseFadeProp
    [
    fademindist(float) : "开始淡出距离" : -1 : "物体开始淡出的距离（<0 = 使用 fademaxdist）。"
    fademaxdist(float) : "结束淡出距离" : 0 : "最大淡出距离，在此距离内物体可见（0 = 不淡出）。"
    ]

@BaseClass = BaseLight: "用于光和光源的共同参数。"
    [
    _light(color255) : "亮度" : "255 255 255 200" : "光的颜色和亮度。"
    _lighthdr(color255) : "HDR 亮度" : "-1 -1 -1 1"
    _lightscalehdr(float) : "HDR 亮度缩放" : 1 : "编译 HDR 时要缩放光的量。"
    _constant_attn(string) : "常数" : 0
    _linear_attn(string) : "线性" : 0
    _quadratic_attn(string) : "二次" : 1
    _fifty_percent_distance(string) : "50% 衰减距离" : 0 : "亮度衰减到 50% 的距离。如果设置，将覆盖线性常数和二次参数。"
    _zero_percent_distance(string) : "0% 衰减距离" : 0 : "亮度衰减到可忽略的（1/256）% 的距离。必须设置 _fifty_percent_distance 才能使用。"
    _hardfalloff(integer) : "硬衰减" : 0 : "如果设置，导致光在零百分比距离之外准确降至零。如果不小心使用，可能会导致不现实的照明。"
    _distance(integer) : "最大距离" : 0 : "允许光投射的距离。"
    ]

@BaseClass = BaseVehicle
    [
    vehiclescript(string) : "车辆脚本文件" : "scripts/vehicles/jeep_test.txt"
    actionscale(float) : "动作输入 / 帧速率比例" : 1

    // 输入
    input Action(float) : "设置动作动画的速度"
    input HandBrakeOn(void) : "打开手刹"
    input HandBrakeOff(void) : "释放手刹"
    input Steer(float) : "转向 +/-1"
    input Throttle(float) : "油门 +/-1"
    ]

@BaseClass = ControlEnables: "指定 comp_ 实体是否已启用的一对键值。"
    [
    ctrl_type(choices) : "控制类型" : 0 : "控制如何解释控制值" =
        [
        0: "已启用？"
        1: "已禁用？"
        ]

    ctrl_value(choices) : "控制值" : 1 : "决定此实体是否已启用。如果禁用，实体将不起作用。" =
        [
        0: "否"
        1: "是"
        ]

    ]

@BaseClass = DamageFilter
    [
    damagefilter(filterclass) : "伤害过滤器" : : "控制哪些实体可以对我们造成伤害的过滤器实体的名称。"

    // 输入
    input SetDamageFilter(target_destination) : "设置要用作伤害过滤器的实体。传递空字符串以清除伤害过滤器。"
    ]

@BaseClass = DamageType
    [
    damagetype(choices) : "伤害类型" : 0 : "应用的伤害类型。这些字段可以进行 OR 运算。" =
        [
        0: "通用"
        1: "压碎"
        2: "子弹"
        4: "切割"
        8: "燃烧"
        16: "冻结"
        32: "掉落"
        64: "爆炸"
        128: "棍棒"
        256: "电击"
        512: "声波"
        1024: "能量射线"
        16384: "淹没（蓝色褪色）"
        32768: "麻痹"
        65536: "神经毒气"
        131072: "毒药"
        262144: "辐射"
        524288: "溺水恢复"
        1048576: "化学"
        2097152: "慢性燃烧"
        4194304: "缓慢冻结"
        8388608: "重力枪"
        16777216: "力量碎片"
        33554432: "气垫艇"
        67108864: "溶解"
        268435464: "着火"
        ]

    damageor1(choices) : "[HA] 伤害 - 碎尸" : 0 : "可以伴随伤害类型的可选标志。" =
        [
        0: "正常行为"
        4096: "永远不使用碎尸"
        8192: "尽可能碎尸"
        ]

    damageor2(choices) : "[HA] 伤害 - 防止物理力量" : 0 : "防止将物理力量应用于目标。" =
        [
        0: "应用力量"
        2048: "防止力量"
        ]

    damageor3(choices) : "[HA] 伤害 - 死亡时不生成布娃娃" : 0 : "在死亡时防止任何布娃娃生成。" =
        [
        0: "允许布娃娃"
        4194304: "防止布娃娃"
        ]

    damageor4(choices) : "[HA] 伤害 - 爆炸表面" : 0 : "当完全处于水下时，玩家将忽略此参数。" =
        [
        0: "水下伤害"
        134217728: "仅在水面以上造成伤害"
        ]

    ]

@BaseClass = DetailPropBase
    [
    detailorientation(choices) : "方向" : 0 : "物体/精灵旋转以面向相机的方式。" =
        [
        0: "无旋转"
        1: "屏幕对齐"
        2: "仅 Z 轴"
        ]

    ]

@BaseClass = EnableDisable
    [
    startdisabled(choices) : "开始时禁用" : 0 =
        [
        0: "否"
        1: "是"
        ]


    // 输入
    input Enable(void) : "启用此实体。"
    input Disable(void) : "禁用此实体。"
    ]

@BaseClass = Glow
    [
    glowstate(choices) : "发光类型" : 0 =
        [
        0: "关闭"
        1: "+use"
        2: "朝向"
        3: "开启"
        ]

    glowrange(integer) : "发光范围" : 0 : "发光变得可见的范围。（0 = 始终可见）"
    glowrangemin(integer) : "最小发光范围" : 0 : "发光停止可见的范围。（0 = 始终可见）"
    glowcolor(color255) : "发光颜色覆盖 (R G B)" : "0 0 0" : "更改发光的渲染颜色。"

    // 输入
    input StartGlowing(void) : "为此道具打开永久发光效果。"
    input StopGlowing(void) : "关闭此道具的发光效果。"
    ]

@BaseClass = KeyFrame
    [
    nextkey(target_destination) : "下一个关键帧" : : "沿此关键帧路径的下一个关键帧的名称。"
    movespeed(integer) : "速度（每秒单位）" : 64
    ]

@BaseClass = LightPattern
    [
    style(choices) : "外观" : 0 =
        [
        0: "正常"
        10: "荧光闪烁"
        2: "缓慢、强烈的脉冲"
        11: "缓慢脉冲、无黑色"
        5: "柔和的脉冲"
        1: "闪烁 A"
        6: "闪烁 B"
        3: "蜡烛 A"
        7: "蜡烛 B"
        8: "蜡烛 C"
        4: "快速闪烁"
        9: "缓慢闪烁"
        12: "水下灯光突变"
        ]

    pattern(string) : "自定义外观" : : "为此光源设置一个自定义的光亮度模式。模式格式是一个字符串，其中'a'表示完全黑暗，'z'表示完全亮。例如'aaggnnttzz'将是一个从黑暗到明亮的阶梯式淡入。"

    // 输入
    input TurnOn(void) : "打开灯光。"
    input TurnOff(void) : "关闭灯光。"
    input Toggle(void) : "切换灯光的当前状态。"
    input SetPattern(string) : "为此灯光设置自定义的光亮度模式。模式格式是一个字符串，其中'a'表示完全黑暗，'z'表示完全亮。例如'aaggnnttzz'将是一个从黑暗到明亮的阶梯式淡入。"
    input FadeToPattern(string) : "从旧模式的第一个值淡出到给定新模式的第一个值。模式格式是一个字符串，其中'a'表示完全黑暗，'z'表示完全亮。例如'aaggnnttzz'将是一个从黑暗到明亮的阶梯式淡入。"
    ]

@BaseClass = LightShadows
    [
    _castentityshadow(choices) : "投射实体阴影" : 0 : "受此光照影响的物体可以设置为从此光源投射一个假的方向阴影。" =
        [
        0: "不影响实体阴影角度"
        1: "影响实体阴影角度"
        ]

    _shadoworiginoffset(vector) : "阴影投射偏移" : "0 0 0" : "在投射实体阴影时应用到光源原点的世界空间偏移量。对于处理非常低的灯光产生的奇怪阴影很有用：只需沿 Z 轴向上偏移即可。默认值为 0 0 0。"
    ]

@BaseClass = Mover
    [
    positioninterpolator(choices) : "位置插值器" : 0 =
        [
        0: "线性"
        1: "Catmull-Rom样条"
        ]

    ]

@BaseClass = NavAttributeRegion
    [
    spawnflags(flags)  =
        [
        2: "[2] 空白（没有游荡者）" : 0
        32: "[32] 战斗站" : 0
        64: "[64] 结局" : 0
        128: "[128] 任务开始" : 0
        256: "[256] 战场" : 0
        1024: "[1024] 不可清除" : 0
        2048: "[2048] 检查点" : 0
        4096: "[4096] 遮挡" : 0
        8192: "[8192] 无怪物" : 0
        32768: "[32768] 救援车辆" : 0
        65536: "[65536] 救援衣橱" : 0
        524288: "[524288] 无威胁" : 0
        1048576: "[1048576] 躺着" : 0
        ]

    precise(choices) : "精确" : 0 =
        [
        0: "否"
        1: "是"
        ]

    crouch(choices) : "蹲下" : 0 =
        [
        0: "否"
        1: "是"
        ]

    stairs(choices) : "楼梯" : 0 =
        [
        0: "否"
        1: "是"
        ]

    remove_attributes(integer) : "移除属性" : 0 : "是否应该从导航区域中删除属性而不是应用它们？"
    tank_only(choices) : "仅坦克" : 0 =
        [
        0: "否"
        1: "是"
        ]

    mob_only(choices) : "仅怪物" : 0 =
        [
        0: "否"
        1: "是"
        ]


    // 输入
    input ApplyNavAttributes(void) : "应用导航属性."
    ]

@BaseClass = NavBlocker
    [
    teamtoblock(choices) : "要阻止的队伍" : -1 : "此实体应该阻止的队伍" =
        [
        -1: "所有人"
        2: "幸存者"
        3: "感染者"
        ]


    // 输入
    input BlockNav(string) : "开始阻止导航区域."
    input UnblockNav(void) : "停止阻止导航区域."
    ]

@BaseClass = Node
    [
    nodeid(integer) readonly : "节点ID"
    ]

@BaseClass = Origin
    [
    origin(origin) : "原点（X Y Z）" : : "此实体中心在世界中的位置。旋转实体通常围绕其原点旋转."
    ]

@BaseClass = Reflection
    [
    drawinfastreflection(choices) : "在快速反射中渲染" : 0 : "如果启用，将导致此实体/道具在快速水反射（即当水材质指定$reflectonlymarkedentities时）中渲染，并在世界模拟器传递中渲染。" =
        [
        0: "否"
        1: "是"
        ]


    // 输入
    input DisableDrawInFastReflection(void) : "关闭此实体在使用$reflectonlymarkedentities的水材质中的反射渲染."
    input EnableDrawInFastReflection(void) : "打开此实体在使用$reflectonlymarkedentities的水材质中的反射渲染."
    ]

@BaseClass = RenderFields
    [
    rendermode(choices) : "渲染模式" : 0 : "用于在此实体上设置非标准渲染模式. 参见'FX Amount'和'FX Color'. \n* 颜色和纹理 = src*a+dest*(1-a)\n* 发光 = src*a + dest，在精灵上固定在屏幕上\n* 实体 = 执行alphatest透明度\n* 加法 = src*a + dest\n* 加法FF = 在精灵动画帧之间混合\n* Alpha加法 = src + dest*(1-a)\n* 世界空间发光 = src*a + dest" =
        [
        0: "正常"
        1: "颜色"
        2: "纹理"
        3: "发光"
        4: "实体"
        5: "加法"
        7: "加法分数帧"
        8: "加法Alpha"
        9: "世界空间发光"
        10: "不渲染"
        ]

    rendercolor(color255) : "FX颜色（R G B）" : "255 255 255" : "与模型/精灵混合的颜色."
    renderamt(integer) : "FX Alpha（0-255）" : 255 : "透明度量，需要非正常的渲染模式. 0是不可见的，255是完全可见的."
    renderfx(choices) : "渲染特效" : 0 : "各种略微陈旧的Alpha效果。材质代理更可定制，但这些设置更快速。淡入/淡出在FX更改时应用。不同的实体自动获得轻微的偏移量以避免同步." =
        [
        0: "正常"
        1: "脉动+-16，1.5秒周期"
        2: "脉动+-16，0.4秒周期"
        3: "脉动+-64，1.5秒周期"
        4: "脉动+-64，0.4秒周期"
        17: "脉动+-255，0.26秒周期"
        9: "每0.8秒闪烁一次"
        10: "每0.2秒闪烁一次"
        11: "每0.09秒闪烁一次"
        12: "慢闪烁（1.5秒，0.18秒）"
        13: "快闪烁（0.2秒，0.14秒）"
        5: "淡出（4秒）"
        6: "淡出（1秒）"
        7: "淡入（4秒）"
        8: "淡入（1秒）"
        15: "淡出（即时）"
        16: "淡入（即时）"
        14: "恒定发光"
        18: "发光外壳"
        ]

    disablereceiveshadows(choices) : "禁用接收阴影" : 0 =
        [
        0: "否"
        1: "是"
        ]


    // 输入
    input Alpha(integer) : "设置实体的alpha（0-255）."
    input Color(color255) : "设置实体的颜色（R G B）."
    ]

@BaseClass = ResponseContext
    [
    responsecontext(string) : "响应上下文" : : "此实体的响应系统上下文。格式应为：'key:value,key2:value2,etc'。当此实体发出声音时，将传递键和值的列表到响应规则系统."

    // 输入
    input AddContext(string) : "将上下文添加到此实体的响应上下文列表中。格式应为'key:value'."
    input RemoveContext(string) : "从此实体的响应上下文列表中删除上下文。名称应与先前添加的上下文的'key'匹配."
    input ClearContext(void) : "删除此实体的响应上下文列表中的所有上下文."
    ]

@BaseClass = RopeKeyFrame
    [
    spawnflags(flags)  =
        [
        1: "[1] 自动调整大小" : 0
        ]

    nextkey(target_destination) : "下一个绳子" : : "沿此路径的下一个绳子的名称."
    slack(integer) : "松弛" : 25 : "绳子的额外长度（默认情况下，它具有编辑器中其两个端点之间的长度）."
    type(choices) : "类型" : 0 =
        [
        0: "绳子"
        1: "半刚性"
        2: "刚性"
        ]

    subdiv(integer) : "细分" : 2 : "每个绳段之间的细分数。最大值为8。更高的值使绳子更顺滑，但渲染速度较慢."
    barbed(choices) : "带刺" : 0 : "使绳子看起来更锐利，更带刺的测试效果." =
        [
        0: "否"
        1: "是"
        ]

    width(float) : "宽度（1-64）" : 2 : "绳子的宽度."
    texturescale(float) : "纹理比例" : 1 : "这会改变纹理的分辨率。默认分辨率为每英寸4像素。较大的值拉伸纹理，较小的值将其压缩."
    collide(choices) : "与世界碰撞" : 0 =
        [
        0: "否"
        1: "是"
        ]

    dangling(choices) : "开始摆动" : 0 : "当设置为是时，绳子开始与其目标端点分离." =
        [
        0: "开始附加"
        1: "开始摆动"
        ]

    breakable(choices) : "可破坏" : 0 : "当设置为是时，绳子可以在射击时从任一端点分离." =
        [
        0: "不可摧毁"
        1: "可破坏"
        ]

    ropematerial(material) : "绳材质" : "cable/cable.vmt" : "渲染绳子时要使用的材质."
    usewind(choices) : "风" : 0 : "绳子是否受风影响?" =
        [
        0: "忽略风"
        1: "受风影响"
        ]

    movespeed(integer) readonly : "速度（未使用）" : 64
    positioninterpolator(integer) readonly : "位置插值器" : 2 : "曲线类型。当前只有绳子得到充分支持."

    // 输入
    input SetScrollSpeed(float) : "设置纹理滚动的速度."
    input SetForce(vector) : "立即对绳子施加力。参数应该是包含要施加的力的向量（X Y Z）."
    input Break(void) : "断开绳子的这一端，导致其掉落."
    ]

@BaseClass = SetSkin
    [
    skin(integer) : "皮肤" : 0 : "一些模型有其纹理的多个版本，称为皮肤。将此设置为非零数字以使用该皮肤而不是默认皮肤."
    skinset(string) : "[HA] 使用的皮肤" : : "将此设置为以空格分隔的所有要使用此ent的皮肤编号列表（例如'0 4 8'）。这允许自动打包跳过未使用的皮肤.如果留空，则假定所有皮肤都已使用."
    ]

@BaseClass = StaticTargetName: "仅用于编译的目标名."
    [
    targetname(target_source) : "名称" : : "其他实体通过此名称引用此实体.此实体仅在编译期间存在，因此名称仅在有限情况下可用."
    ]

@BaseClass = TeamNum
    [
    teamnum(integer) : "队伍"

    // 输入
    input SetTeam(integer) : "更改实体的队伍."
    ]

@BaseClass = Toggle
    [

    // 输入
    input Toggle(void) : "切换此实体的启用/禁用状态."
    ]

@BaseClass = _Breakable
    [
    explodedamage(float) : "爆炸伤害" : 0 : "如果非零，则当此实体断裂时，将产生导致指定数量伤害的爆炸。另请参见'爆炸半径'."
    exploderadius(float) : "爆炸半径" : 0 : "如果非零，则当此实体断裂时，将产生指定数量的爆炸半径。另请参见'爆炸伤害'."
    explodemagnitude(integer) : "爆炸大小" : 0 : "如果非零，则当此实体断裂时，将产生指定数量的爆炸伤害."
    performancemode(choices) : "性能模式" : 0 : "用于限制此实体断裂时产生的碎片数量，以提高性能." =
        [
        0: "正常"
        1: "无碎片"
        2: "所有平台上的完整碎片"
        3: "减少碎片"
        ]

    pressuredelay(float) : "压力延迟" : 0 : "压力断裂后断裂之前的延迟时间（允许声音在断裂之前播放）."
    breakmodelmessage(string) : "断裂模型消息" : : "如果设置，将使用此断裂模型消息，而不是正常的断裂行为."
    minhealthdmg(integer) : "最小伤害值" : 0 : "如果伤害小于此金额，实体将忽略任何伤害事件."
    health(integer) : "健康值" : 0 : "断裂前要承受的伤害点数. 0表示不会断裂."
    physdamagescale(float) : "物理碰撞伤害缩放" : "1.0" : "当此对象被物理对象击中时，缩放伤害能量。设置为1.0表示材料与肉体一样坚固，较小的数字表示更坚固的材料."

    // 输入
    input Break(void) : "打断此可打破的物体."
    input SetHealth(integer) : "为可打破的物体设置新的健康值. 如果可打破的物体的健康值降到零，它将断裂."
    input AddHealth(integer) : "为可打破的物体添加健康值. 如果可打破的物体的健康值降到零，它将断裂."
    input RemoveHealth(integer) : "从可打破的物体中减去健康值. 如果可打破的物体的健康值降到零，它将断裂."
    input EnablePhyscannonPickup(void) : "使可打破的物体能够被物理炮拾取."
    input DisablePhyscannonPickup(void) : "使可打破的物体不能被物理炮拾取."
    input SetMass(float) : "设置此对象的质量."

    // 输出
    output OnBreak(void) : "当此可打破的物体打破时触发."
    output OnTakeDamage(void) : "当此可打破的物体受到任何伤害时触发."
    output OnHealthChanged(float) : "当此可打破的物体的健康状况改变时触发，将新的健康值作为最大健康值的百分比[0..1]传递."
    output OnPhysCannonDetach(void) : "当物理炮将此可打破的物体从墙上撕下时触发. 仅在此断裂所使用的模型中定义了ACT_PHYSCANNON_DETACH时触发."
    output OnPhysCannonAnimatePreStarted(void) : "当此道具开始播放Pre物理炮拉动动作时触发，这是因为玩家试图用物理炮抓住此道具。仅在此断裂所使用的模型中定义了ACT_PHYSCANNON_ANIMATE_PRE时触发."
    output OnPhysCannonAnimatePullStarted(void) : "当此道具开始播放物理炮拉动动作时触发，这是因为玩家试图用物理炮抓住此道具。仅在此断裂所使用的模型中定义了ACT_PHYSCANNON_ANIMATE时触发。如果道具具有预拉动动画，这将在Pre动画完成后播放."
    output OnPhysCannonPullAnimFinished(void) : "当此道具完成播放物理炮拉动动作时触发，这是因为玩家试图用物理炮抓住此道具。仅在此断裂所使用的模型中定义了ACT_PHYSCANNON_ANIMATE时触发。如果道具具有Pre & Post拉动动画，则将在Post动画完成后触发."
    output OnPhysCannonAnimatePostStarted(void) : "当此道具开始播放Post物理炮拉动动作时触发，这是因为玩家试图用物理炮抓住此道具。仅在此断裂所使用的模型中定义了ACT_PHYSCANNON_ANIMATE_POST时触发."
    output OnPhysCannonDetachPost(void) : "当物理炮完成Post物理炮拉动动作时触发，这是因为玩家试图用物理炮抓住此道具。仅在此断裂所使用的模型中定义了ACT_PHYSCANNON_DETACH_POST时触发."
    ]

@PointClass 
	iconsprite("editor/comp_entity_finder")
	sphere(radius)
	cylinder(255 255 255, targetname, targetref, radius)
	line(255 255 255, targetname, kv1_known)
	line(255 255 255, targetname, kv2_known)
	line(255 255 255, targetname, kv3_known)
	line(255 255 255, targetname, kv4_known)
	line(255 255 255, targetname, kv5_known)
= comp_entity_finder: "Finds the closest entity of a given type, then applies various transformations.Outputs from this entity will be moved to the found entity.Further keyvalues can be set manually with SmartEdit off."
	[
	targetname(target_source) readonly : "Targetname" : "<pack_rename>" : "Fake targetname, used to determine how containing instances are configured."
	targetcls(string) : "Target Classname" : : "Classnames of the entity to find. Multiple classnames can be specified seperated by spaces."
	radius(float) : "Search Radius" : 64 : "Radius to search inside, or 0 for infinite."
	searchfov(float) : "Search Field Of View" : 180 : "The found entity must be within this many degrees of the direction of the finder."
	angles(angle) : "Search Direction" : "0 0 0" : "If Search FOV is used, the direction to compare to."
	targetref(target_destination) : "Reference position" : : "If set, look for entities close to this entity instead of the comp_entity_finder."
	blacklist(target_destination) : "Search Blacklist" : : "If set, ignore entities matching this name."
	teleporttarget(choices) : "Teleport Target To Me" : 0 : "Move the found entity to the location of this entity or that of the reference." =
		[
		0: "No"
		1: "Yes"
		]

	makeunique(choices) : "Make Target Unique" : 0 : "Append a numeric suffix to the target's name to make it unique." =
		[
		0: "No"
		1: "Yes"
		]

	sep1(string) readonly : "=========================================================================================================="
	kv1_mode(choices) : "1 - Mode" : : "The first modification to perform. For Replace Outputs, outputs sent to a !name specified in Destination will be switched to point to the found entity." =
		[
		"": "None"
		"const2target": "Constant -> Target Ent KV"
		"const2known": "Constant -> Known Ent KV"
		"known2target": "Known Ent KV -> Target Ent KV"
		"target2known": "Target Ent KV -> Known Ent KV"
		"replacetarget": "Replace Outputs"
		]

	kv1_known(target_destination) : "1 - Known Entity" : : "The known entity to access."
	kv1_src(string) : "1 - Source" : : "Constant value to use or keyvalue name to read from."
	kv1_dest(string) : "1 - Destination" : : "Keyvalue name to write to or !special name to replace."
	sep2(string) readonly : "=========================================================================================================="
	kv2_mode(choices) : "2 - Mode" : : "The second modification to perform. For Replace Outputs, outputs sent to a !name specified in Destination will be switched to point to the found entity." =
		[
		"": "None"
		"const2target": "Constant -> Target KV"
		"const2known": "Constant -> Known KV"
		"known2target": "Known KV -> Target KV"
		"target2known": "Target KV -> Known KV"
		"replacetarget": "Replace Outputs"
		]

	kv2_known(target_destination) : "2 - Known Entity" : : "The known entity to access."
	kv2_src(string) : "2 - Source" : : "Constant value or keyvalue name to read from."
	kv2_dest(string) : "2 - Destination" : : "Keyvalue name to write to or !special name to replace."
	sep3(string) readonly : "=========================================================================================================="
	kv3_mode(choices) : "3 - Mode" : : "The third modification to perform. For Replace Outputs, outputs sent to a !name specified in Destination will be switched to point to the found entity." =
		[
		"": "None"
		"const2target": "Constant -> Target KV"
		"const2known": "Constant -> Known Ent KV"
		"known2target": "Known KV -> Target KV"
		"target2known": "Target KV -> Known KV"
		"replacetarget": "Replace Outputs"
		]

	kv3_known(target_destination) : "3 - Known Entity" : : "The known entity to access."
	kv3_src(string) : "3 - Source" : : "Constant value or keyvalue name to read from."
	kv3_dest(string) : "3 - Destination" : : "Keyvalue name to write to or !special name to replace."
	sep4(string) readonly : "=========================================================================================================="
	kv4_mode(choices) : "4 - Mode" : : "The fourth modification to perform. For Replace Outputs, outputs sent to a !name specified in Destination will be switched to point to the found entity." =
		[
		"": "None"
		"const2target": "Constant -> Target KV"
		"const2known": "Constant -> Known Ent KV"
		"known2target": "Known KV -> Target KV"
		"target2known": "Target KV -> Known KV"
		"replacetarget": "Replace Outputs"
		]

	kv4_known(target_destination) : "4 - Known Entity" : : "The known entity to access."
	kv4_src(string) : "4 - Source" : : "Constant value or keyvalue name to read from."
	kv4_dest(string) : "4 - Destination" : : "Keyvalue name to write to or !special name to replace."
	sep5(string) readonly : "=========================================================================================================="
	kv5_mode(choices) : "5 - Mode" : : "The fifth modification to perform. For Replace Outputs, outputs sent to a !name specified in Destination will be switched to point to the found entity." =
		[
		"": "None"
		"const2target": "Constant -> Target KV"
		"const2known": "Constant -> Known Ent KV"
		"known2target": "Known KV -> Target KV"
		"target2known": "Target KV -> Known KV"
		"replacetarget": "Replace Outputs"
		]

	kv5_known(target_destination) : "5 - Known Entity" : : "The known entity to access."
	kv5_src(string) : "5 - Source" : : "Constant value or keyvalue name to read from."
	kv5_dest(string) : "5 - Destination" : : "Keyvalue name to write to or !special name to replace."

	// Outputs
	output OutName(void) : "Needed to allow Hammer to add outputs to this."
	]

@PointClass 
	iconsprite("editor/comp_entity_mover")
	sphere(distance)
	line(255 255 255, targetname, target)
= comp_entity_mover: "Shift an entity by a given amount. This is useful to place entities into the void, for example."
	[
	target(target_destination) : "Target Entity" : : "The name of the entity or entities to move."
	reference(target_destination) : "Reference Entity" : : "If set, the target will be offset by the amount that this entity is from the reference. The Distance will then be a multiplier."
	direction(angle) : "Direction" : "0 0 0" : "If no Reference is provided, the direction to move in."
	distance(float) : "Distance" : 1 : "The amount to move targets by."
	]

@SolidClass = comp_propcombine_volume: "Specifies a group of props that will be combined together. Note that unlike the propcombine_set point-entity version, this does impact some brush limits, so it is suggested to use the point version in instances and prefabs."
	[
	name(string) : "Name" : : "Two sets with the same name will be treated as one."
	prop(studio) : "Model Filter" : : "If set, a combinable model used to filter which others will be combined. The propcombine set will only apply to models which could be combined with this one."
	skin(integer) : "Skin Filter" : 0 : "The skin for the Model Filter."
	]

@PointClass 
	color(0 0 255)
	sidelist()
	iconsprite("editor/env_cubemap.vmt")
	line(255 255 255, targetname, parallaxobb)
= env_cubemap: "用于创建立方体环境贴图的采样点。"
    [
    cubemapsize(choices) : "Cubemap 大小" : 0 =
        [
        0: "默认"
        1: "1x1"
        2: "2x2"
        3: "4x4"
        4: "8x8"
        5: "16x16"
        6: "32x32"
        7: "64x64"
        8: "128x128"
        9: "256x256"
        ]

    sides(sidelist) : "画刷面" : : "(可选) 直接附着到env_cubemap的画刷面。按Pick然后在3D视图中点击面来选择它们。使用CTRL点击可以增加或移除选择。"
    ]

@SolidClass 
    color(0 180 0)
= func_detail: "将其画刷转化为细节画刷的实体。细节画刷不会对PVS中的可见性产生影响。世界几何不会被细节画刷剪切，因此如果您有一个小的细节块附着在墙上，墙不会被细节画刷切割。func_detail非常适合只是视觉细节的高频画刷几何体。它也是减少地图VIS时间的理想选择。"
    [
    ]

@SolidClass = func_detail_blocker: "一个画刷实体，防止细节精灵被放置在其体积内。"
    [
    ]

@PointClass 
    sphere(max_range)
    iconsprite("editor/ficool2/func_fish_pool")
= func_fish_pool: "创建一群在这个实体附近游动的互动鱼群。"
    [
    model(studio) : "模型" : "models/Junkola.mdl"
    fish_count(integer) : "鱼的数量" : 10 : "这个水池中的鱼的数量"
    max_range(float) : "最大范围" : 150 : "鱼可以游动的最远距离（最大255）"
    ]

@PointClass 
    iconsprite("editor/func_instance_io_proxy.vmt")
= func_instance_io_proxy: "在实例内部放置一个此实体的副本。从代理的OnProxyRelay输出发送信息到实例内部的实体，将允许您通过向func_instance发送信息来从实例外部触发这些实体。将实例内部的实体的ProxyRelay信息发送到代理，您将能够使用这些事件来从func_instance向实例外部的其他实体发送信息。注意：实例、代理和所有涉及的实体都应该有描述性的命名。"
    [
    targetname(target_source) : "名称" : "proxy" : "其他实体通过此名称引用此实体。"

    // 输入
    input ProxyRelay(string) : "这条信息将被中继，并且将从实例中获取。"

    // 输出
    output OnProxyRelay(void) : "外部的一条信息可以触发这个，导致在实例中发生某些事情。"
    ]

@PointClass 
    iconsprite("editor/func_instance_parms.vmt")
= func_instance_parms: "在实例内部放置一个此实体的副本。每当您为实例添加一个$参数时，获取此实体的属性。它将自动填充变量并允许您指示变量类型。"
    [
    parm1(instance_parm) : "参数 (01)" : : "这是一个参数。它的形式为$变量类型 [默认值]。"
    parm2(instance_parm) : "参数 (02)" : : "这是一个参数。它的形式为$变量类型 [默认值]。"
    parm3(instance_parm) : "参数 (03)" : : "这是一个参数。它的形式为$变量类型 [默认值]。"
	parm4(instance_parm) : "参数 (04)" : : "这是一个参数。它的形式为$变量类型 [默认值]。"
	parm5(instance_parm) : "参数 (05)" : : "这是一个参数。它的形式为$变量类型 [默认值]。"
	parm6(instance_parm) : "参数 (06)" : : "这是一个参数。它的形式为$变量类型 [默认值]。"
	parm7(instance_parm) : "参数 (07)" : : "这是一个参数。它的形式为$变量类型 [默认值]。"
	parm8(instance_parm) : "参数 (08)" : : "这是一个参数。它的形式为$变量类型 [默认值]。"
	parm9(instance_parm) : "参数 (09)" : : "这是一个参数。它的形式为$变量类型 [默认值]。"
	parm10(instance_parm) : "参数 (10)" : : "这是一个参数。它的形式为$变量类型 [默认值]。"
	parm11(instance_parm) : "参数 (11)" : : "这是一个参数。它的形式为$变量类型 [默认值]。"
	parm12(instance_parm) : "参数 (12)" : : "这是一个参数。它的形式为$变量类型 [默认值]。"
	parm13(instance_parm) : "参数 (13)" : : "这是一个参数。它的形式为$变量类型 [默认值]。"
	parm14(instance_parm) : "参数 (14)" : : "这是一个参数。它的形式为$变量类型 [默认值]。"
	parm15(instance_parm) : "参数 (15)" : : "这是一个参数。它的形式为$变量类型 [默认值]。"
	parm16(instance_parm) : "参数 (16)" : : "这是一个参数。它的形式为$变量类型 [默认值]。"
	parm17(instance_parm) : "参数 (17)" : : "这是一个参数。它的形式为$变量类型 [默认值]。"
	parm18(instance_parm) : "参数 (18)" : : "这是一个参数。它的形式为$变量类型 [默认值]。"
	parm19(instance_parm) : "参数 (19)" : : "这是一个参数。它的形式为$变量类型 [默认值]。"
	parm20(instance_parm) : "参数 (20)" : : "这是一个参数。它的形式为$变量类型 [默认值]。"
	parm21(instance_parm) : "参数 (21)" : : "这是一个参数。它的形式为$变量类型 [默认值]。"
	parm22(instance_parm) : "参数 (22)" : : "这是一个参数。它的形式为$变量类型 [默认值]。"
	parm23(instance_parm) : "参数 (23)" : : "这是一个参数。它的形式为$变量类型 [默认值]。"
	parm24(instance_parm) : "参数 (24)" : : "这是一个参数。它的形式为$变量类型 [默认值]。"
	parm25(instance_parm) : "参数 (25)" : : "这是一个参数。它的形式为$变量类型 [默认值]。"
	parm26(instance_parm) : "参数 (26)" : : "这是一个参数。它的形式为$变量类型 [默认值]。"
	parm27(instance_parm) : "参数 (27)" : : "这是一个参数。它的形式为$变量类型 [默认值]。"
	parm28(instance_parm) : "参数 (28)" : : "这是一个参数。它的形式为$变量类型 [默认值]。"
	parm29(instance_parm) : "参数 (29)" : : "这是一个参数。它的形式为$变量类型 [默认值]。"
	parm30(instance_parm) : "参数 (30)" : : "这是一个参数。它的形式为$变量类型 [默认值]。"
	]

@SolidClass = func_ladder: "梯子。玩家将能够自由地沿着这个画刷的一侧移动，就像它是一个梯子一样。如果您在地图中使用模型道具来视觉上代表梯子，将toolsinvisibleladder材质应用于func_ladder画刷的可攀爬侧。"
    [
    ]

@SolidClass 
    color(180 180 0)
= func_viscluster: "任何触摸这个画刷的视野叶将假定它们可以相互看见。放置在大型开放区域中以帮助减少编译时间。"
    [
    ]

@PointClass 
    iconsprite("editor/ts_book.vmt")
    line(255 255 255, targetname, linename1)
    line(255 0 0, targetname, linename2)
    line(0 255 0, targetname, linename3)
    line(0 0 255, targetname, linename4)
    worldtext()
= hammer_notes: "用于在内部存储注释和评论的假实体。不会生成。"
    [
    message(string) : "信息" : : "用于输入任何注释的文本字段。如果您使用的是Hammer++，这也会出现在3D视图中。"
    scale(float) : "比例" : "0.25" : "改变图标大小，以便从更远的地方看到这个。"
    linename1(target_destination) : "白色相关实体" : : "添加实体名称以绘制到它们的线。"
    linename2(target_destination) : "红色相关实体" : : "添加实体名称以绘制到它们的线。"
    linename3(target_destination) : "绿色相关实体" : : "添加实体名称以绘制到它们的线。"
    linename4(target_destination) : "蓝色相关实体" : : "添加实体名称以绘制到它们的线。"
    mat(material) : "材质选择器" : : "有材质浏览器以便更容易编辑。"
    part(string) : "粒子选择器" : : "有粒子系统选择器以便更容易编辑。"
    model(studio) : "模型选择器" : : "有模型选择器以便更容易编辑。"
    sound(sound) : "声音选择器" : : "有声音选择器以便更容易编辑。"
    ]

@PointClass 
    halfgridsnap
    iconsprite("editor/ficool2/info_mass_center.vmt")
    color(128 128 128)
    line(128 128 128, targetname, target)
= info_mass_center: "一个实体，通过将其移动到info_mass_center的位置来覆盖目标物理对象的质量中心。这会在生成时自我销毁。"
    [
    target(target_destination) : "目标对象" : : "其质量中心将被覆盖的实体。"
    ]

@PointClass 
    iconsprite("editor/info_no_dynamic_shadow.vmt")
    color(200 200 0)
= info_no_dynamic_shadow: "使用此实体标记不应接收动态阴影的表面。用于应用于墙壁和地板，其中阴影绘制不正确，暴露敌人的位置。"
    [
    sides(sidelist) : "画刷面"
    ]

@PointClass 
    size(-1 -1 0, 1 1 1)
    color(80 150 225)
    studio("models/editor/overlay_helper_box.mdl")
    iconsprite("editor/vizzys/info_overlay_transition")
    sidelist()
    sidelist(sides2)
    overlay_transition()
= info_overlay_transition: "这在两个画刷的交汇处创建一个滚动纹理，用于类似于水边波浪效果之类的东西。"
    [
    material(material) : "材质"
    sides(sidelist) : "画刷面"
    sides2(sidelist) : "水面"
    lengthtexcoordstart(float) : "纹理坐标长度起始" : "0.0"
    lengthtexcoordend(float) : "纹理坐标长度结束" : "1.0"
    widthtexcoordstart(float) : "纹理坐标宽度起始" : "0.0"
    widthtexcoordend(float) : "纹理坐标宽度结束" : "1.0"
    width1(float) : "陆地宽度" : "25.0"
    width2(float) : "水面宽度" : "25.0"
    debugdraw(choices) : "显示调试" : 0 =
        [
        0: "否"
        1: "是"
        ]

    ]

@PointClass = model_studio: "一个旧的假人模型实体，它的行为就像cycler一样。"
    [
    ]

@BaseClass base(BaseVehicle) = BaseDriveableVehicle
    [
    vehiclelocked(choices) : "开始时锁定" : 0 : "是否开始时锁定车辆。锁定的车辆无法进入或退出。" =
        [
        0: "否"
        1: "是"
        ]


    // 输入
    input TurnOn(void) : "打开：启动引擎并启用油门"
    input TurnOff(void) : "关闭：停止引擎，禁用油门，使用刹车。"
    input Lock(void) : "防止玩家进入或退出车辆。"
    input Unlock(void) : "重新允许玩家进入或退出车辆。"

    // 输出
    output PlayerOn(void) : "玩家进入了车辆"
    output PlayerOff(void) : "玩家退出了车辆"
    output PressedAttack(void) : "玩家按下攻击键"
    output PressedAttack2(void) : "玩家按下攻击键2"
    output AttackAxis(string) : "攻击按钮的状态 [0,1]"
    output Attack2Axis(string) : "攻击按钮2的状态 [0,1]"
    ]

@BaseClass base(BaseEntityInputs, BaseEntityOutputs) = BaseEntity
    [
    targetname(target_source) : "名称" : : "其他实体引用此实体的名称。"
    globalname(string) : "全局实体名称" : : "此实体在不同地图中链接到另一个实体的名称。当玩家转移到新地图时，新地图中与前一地图的实体具有匹配全局名称的实体，将会复制前一地图的状态覆盖它们的状态。"
    vscripts(scriptlist) : "实体脚本" : : "在所有实体生成后执行的脚本文件的名称。"
    thinkfunction(string) : "脚本思考函数" : : "此实体脚本范围内将被自动调用的函数名称。"
    vscript_init_code(string) : "[HA] 初始化代码" : : "此代码将在实体脚本选项之后执行。游戏中的反引号(`)字符将被转换为字符串的引号。"
    vscript_init_code2(string) : "[HA] 初始化代码2" : : "此代码将是在实体脚本选项之后执行的第二行代码。游戏中的反引号(`)字符将被转换为字符串的引号。可以在关闭SmartEdit的情况下添加额外的Init Code键值。"
    linedivider_base(string) readonly : "=========================================================================================================="
    ]

@BaseClass base(BaseEntityInputs, BaseEntityOutputs) = BaseEntityBrush
    [
    targetname(target_source) : "名称" : : "其他实体引用此实体的名称。"
    globalname(string) : "全局实体名称" : : "此实体在不同地图中链接到另一个实体的名称。当玩家转移到新地图时，新地图中与前一地图的实体具有匹配全局名称的实体，将会复制前一地图的状态覆盖它们的状态。"
    origin(origin) : "原点(X Y Z)" : : "此刷子实体中心在世界中的位置。旋转实体通常围绕它们的原点旋转。"
    parentname(target_destination) : "父级" : : "此实体在移动层次结构中父级的名称。具有父级的实体会随其父级一起移动。"
    parent_attachment_point(string) : "[HA] 附着点" : : "如果设置，将在生成时附着到父级上的这个附着点。"
    linedivider_vscript(string) readonly : "=========================================================================================================="
    vscripts(scriptlist) : "实体脚本" : : "在所有实体生成后执行的脚本文件的名称。"
    thinkfunction(string) : "脚本思考函数" : : "此实体脚本范围内将被自动调用的函数名称。"
    vscript_init_code(string) : "[HA] 初始化代码" : : "此代码将在实体脚本选项之后执行。游戏中的反引号(`)字符将被转换为字符串的引号。"
    vscript_init_code2(string) : "[HA] 初始化代码2" : : "此代码将是在实体脚本选项之后执行的第二行代码。游戏中的反引号(`)字符将被转换为字符串的引号。可以在关闭SmartEdit的情况下添加额外的Init Code键值。"
    linedivider_base(string) readonly : "=========================================================================================================="
    linedivider_basebrush(string) readonly : "=========================================================================================================="

    // 输入
    input SetParent(target_destination) : "在移动层次结构中更改实体的父级。"
    input SetParentAttachment(string) : "更改此实体以附着到其父级上的特定附着点。实体必须在发送此输入之前已经有父级。传入的参数应该是附着点的名称。"
    input SetParentAttachmentMaintainOffset(string) : "更改此实体以附着到其父级上的特定附着点。实体必须在发送此输入之前已经有父级。传入的参数应该是附着点的名称。实体将保持其在附着时相对于父级的位置。"
    input ClearParent(void) : "从移动层次结构中移除此实体，使其可以独立移动。"
    input Use(void) : "或多或少地复制玩家与实体交互的效果。( +USE)"
    ]

@BaseClass base(BaseEntityInputs, BaseEntityOutputs) = BaseEntityPoint
    [
    targetname(target_source) : "名称" : : "其他实体引用此实体的名称。"
    globalname(string) : "全局实体名称" : : "此实体在不同地图中链接到另一个实体的名称。当玩家转移到新地图时，新地图中与前一地图的实体具有匹配全局名称的实体，将会复制前一地图的状态覆盖它们的状态。"
    angles(angle) : "俯仰偏航滚转(X Y Z)" : "0 0 0" : "此实体在世界中的方向。滚转是围绕X轴的旋转，俯仰是围绕Y轴的旋转，偏航是围绕Z轴的旋转。"
    parentname(target_destination) : "父级" : : "此实体在移动层次结构中父级的名称。具有父级的实体会随其父级一起移动。"
    parent_attachment_point(string) : "[HA] 附着点" : : "如果设置，将在生成时附着到父级上的这个附着点。"
    linedivider_vscript(string) readonly : "=========================================================================================================="
    vscripts(scriptlist) : "实体脚本" : : "在所有实体生成后执行的脚本文件的名称。"
    thinkfunction(string) : "脚本思考函数" : : "此实体脚本范围内将被自动调用的函数名称。"
    vscript_init_code(string) : "[HA] 初始化代码" : : "此代码将在实体脚本选项之后执行。游戏中的反引号(`)字符将被转换为字符串的引号。"
    vscript_init_code2(string) : "[HA] 初始化代码2" : : "此代码将是在实体脚本选项之后执行的第二行代码。游戏中的反引号(`)字符将被转换为字符串的引号。可以在关闭SmartEdit的情况下添加额外的Init Code键值。"
    linedivider_base(string) readonly : "=========================================================================================================="

    // 输入
    input SetParent(target_destination) : "在移动层次结构中更改实体的父级。"
    input SetParentAttachment(string) : "更改此实体以附着到其父级上的特定附着点。实体必须在发送此输入之前已经有父级。传入的参数应该是附着点的名称。"
    input SetParentAttachmentMaintainOffset(string) : "更改此实体以附着到其父级上的特定附着点。实体必须在发送此输入之前已经有父级。传入的参数应该是附着点的名称。实体将保持其在附着时相对于父级的位置。"
    input ClearParent(void) : "从移动层次结构中移除此实体，使其可以独立移动。"
    ]

@BaseClass base(_Breakable, DamageFilter) = BreakableProp
    [
    spawnflags(flags)  =
        [
        16: "[16] 触碰即碎" : 0
        32: "[32] 压力碎裂" : 0
        ]


    // 输入
    input EnableDamageForces(void) : "对实体造成伤害会对其施加物理力。"
    input DisableDamageForces(void) : "对实体造成伤害不会施加物理力。"

    // 输出
    output OnTakeDamage(void) : "每次这个可破坏物受到任何伤害时触发。"
    ]

@BaseClass base(Angles) = Button
    [
    glow(target_destination) : "发光实体" : : "为这个按钮设置+use发光效果的实体的名称。"
    sounds(choices) : "按下声音" : 0 : "按下时播放的声音。从Buttons.snd*类别中选择。" =
        [
        0: "无（静音）"
        100: "开关"
        101: "电源插头 - 基本电子产品（柔和）"
        1: "Buttons.snd1: 大电击 & 预热"
        2: "Buttons.snd2: 拒绝访问"
        3: "Buttons.snd3: 允许访问"
        4: "Buttons.snd4: 快速组合锁"
        5: "Buttons.snd5: 电动插销1"
        6: "Buttons.snd6: 电动插销2"
        7: "Buttons.snd7: 水泵"
        8: "Buttons.snd8: 小电击"
        9: "Buttons.snd9: 卡片声"
        10: "Buttons.snd10: 嗡鸣"
        11: "Buttons.snd11: 嗡鸣关闭"
        12: "Buttons.snd12: 锁闩上锁"
        13: "Buttons.snd13: 锁闩解锁"
        14: "Buttons.snd14: 开关"
        15: "Buttons.snd15: 小哔声"
        16: "Buttons.snd16: 小拒绝"
        17: "Buttons.snd17: 小嘟声"
        18: "Buttons.snd18: 小技术拒绝"
        19: "Buttons.snd19: 点击和组合屏幕噪音"
        20: "Buttons.snd20: 宽敞的哔声"
        21: "Buttons.snd21: 杠杆或轮子：转动 + 移动吱吱声"
        22: "Buttons.snd22: 杠杆或轮子：锁闩 + 释放气体"
        23: "Buttons.snd23: 杠杆或轮子：棘轮 + 吱吱声"
        24: "Buttons.snd24: 杠杆或轮子：大棘轮"
        25: "Buttons.snd25: 杠杆或轮子：铿锵 + 释放气体"
        26: "Buttons.snd26: 杠杆或轮子：锁闩 + 大金属重击"
        27: "Buttons.snd27: 杠杆或轮子：小棘轮"
        28: "Buttons.snd28: 杠杆或轮子：小杠杆移动"
        31: "Buttons.snd31: 电击嗡鸣（缺失）"
        32: "Buttons.snd32: 点击哔声（缺失）"
        33: "Buttons.snd33: 技术哔声（缺失）"
		34: "Buttons.snd34: 点击哔哔开启"
		35: "Buttons.snd35: 小高音哔"
		36: "Buttons.snd36: 小科技模糊哔"
		37: "Buttons.snd37: 小点击哔（更改为轻开关）"
		40: "Buttons.snd40: 联合门锁 - 锁定"
		41: "Buttons.snd41: 联合哔咕"
		42: "Buttons.snd42: 联合咕嘟"
		43: "Buttons.snd43: 联合呻吟咕噜"
		44: "Buttons.snd44: 联合点击交谈"
		45: "Buttons.snd45: 联合点击咕嘟嘶"
		46: "Buttons.snd46: 联合点击嘶（拒绝）"
		47: "Buttons.snd47: 联合点击讲话器"
		]

    locked_sound(choices) : "锁定声音" : 0 : "当玩家尝试使用按钮并因为它被锁定而失败时播放的声音。这些是按钮.snd*类别中的声音。" =
        [
        0: "无（静音）"
        100: "轻开关"
        101: "电源插头 - 基础电子（柔和）"
		1: "Buttons.snd1: 大电击 & 预热"
		2: "Buttons.snd2: 拒绝访问"
		3: "Buttons.snd3: 允许访问"
		4: "Buttons.snd4: 快速组合锁"
		5: "Buttons.snd5: 动力插销1"
		6: "Buttons.snd6: 动力插销2"
		7: "Buttons.snd7: 潜水器"
		8: "Buttons.snd8: 小电击"
		9: "Buttons.snd9: 磁卡声音"
		10: "Buttons.snd10: 嗡鸣"
		11: "Buttons.snd11: 嗡鸣关闭"
		12: "Buttons.snd12: 门闩锁定"
		13: "Buttons.snd13: 门闩解锁"
		14: "Buttons.snd14: 轻开关"
		15: "Buttons.snd15: 小尖叫"
		16: "Buttons.snd16: 小拒绝"
		17: "Buttons.snd17: 小叮咚"
		18: "Buttons.snd18: 小科技拒绝"
		19: "Buttons.snd19: 点击和联合屏幕模糊"
		20: "Buttons.snd20: 宽敞的哔声"
		21: "Buttons.snd21: 杠杆或轮子：转动 + 移动吱吱"
		22: "Buttons.snd22: 杠杆或轮子：门闩 + 释放气体"
		23: "Buttons.snd23: 杠杆或轮子：棘轮 + 吱吱"
		24: "Buttons.snd24: 杠杆或轮子：大棘轮"
		25: "Buttons.snd25: 杠杆或轮子：金属碰撞 + 气体释放"
		26: "Buttons.snd26: 杠杆或轮子：门闩 + 大金属砰"
		27: "Buttons.snd27: 杠杆或轮子：小棘轮"
		28: "Buttons.snd28: 杠杆或轮子：小杠杆移动"
		31: "Buttons.snd31: 电击嗡鸣（缺失）"
		32: "Buttons.snd32: 点击哔（缺失）"
		33: "Buttons.snd33: 科技哔（缺失）"
		34: "Buttons.snd34: 点击哔哔开启"
		35: "Buttons.snd35: 小高音哔"
		36: "Buttons.snd36: 小科技模糊哔"
		37: "Buttons.snd37: 小点击哔（更改为轻开关）"
		40: "Buttons.snd40: 联合门锁 - 锁定"
		41: "Buttons.snd41: 联合哔咕"
		42: "Buttons.snd42: 联合咕嘟"
		43: "Buttons.snd43: 联合呻吟咕噜"
		44: "Buttons.snd44: 联合点击交谈"
		45: "Buttons.snd45: 联合点击咕嘟嘶"
		46: "Buttons.snd46: 联合点击嘶（拒绝）"
		47: "Buttons.snd47: 联合点击讲话器"
		]

    unlocked_sound(choices) : "解锁声音" : 0 : "当按钮解锁时播放的声音。这些是Buttons.snd*类别中的声音。" =
        [
        0: "无（静音）"
        100: "轻开关"
        101: "电源插头 - 基础电子（柔和）"
		1: "Buttons.snd1: 大电击 & 预热"
		2: "Buttons.snd2: 拒绝访问"
		3: "Buttons.snd3: 允许访问"
		4: "Buttons.snd4: 快速组合锁"
		5: "Buttons.snd5: 动力插销1"
		6: "Buttons.snd6: 动力插销2"
		7: "Buttons.snd7: 潜水器"
		8: "Buttons.snd8: 小电击"
		9: "Buttons.snd9: 磁卡声音"
		10: "Buttons.snd10: 嗡鸣"
		11: "Buttons.snd11: 嗡鸣关闭"
		12: "Buttons.snd12: 门闩锁定"
		13: "Buttons.snd13: 门闩解锁"
		14: "Buttons.snd14: 轻开关"
		15: "Buttons.snd15: 小尖叫"
		16: "Buttons.snd16: 小拒绝"
		17: "Buttons.snd17: 小叮咚"
		18: "Buttons.snd18: 小科技拒绝"
		19: "Buttons.snd19: 点击和联合屏幕模糊"
		20: "Buttons.snd20: 宽敞的哔声"
		21: "Buttons.snd21: 杠杆或轮子：转动 + 移动吱吱"
		22: "Buttons.snd22: 杠杆或轮子：门闩 + 释放气体"
		23: "Buttons.snd23: 杠杆或轮子：棘轮 + 吱吱"
		24: "Buttons.snd24: 杠杆或轮子：大棘轮"
		25: "Buttons.snd25: 杠杆或轮子：金属碰撞 + 气体释放"
		26: "Buttons.snd26: 杠杆或轮子：门闩 + 大金属砰"
		27: "Buttons.snd27: 杠杆或轮子：小棘轮"
		28: "Buttons.snd28: 杠杆或轮子：小杠杆移动"
		31: "Buttons.snd31: 电击嗡鸣（缺失）"
		32: "Buttons.snd32: 点击哔（缺失）"
		33: "Buttons.snd33: 科技哔（缺失）"
		34: "Buttons.snd34: 点击哔哔开启"
		35: "Buttons.snd35: 小高音哔"
		36: "Buttons.snd36: 小科技模糊哔"
		37: "Buttons.snd37: 小点击哔（更改为轻开关）"
		40: "Buttons.snd40: 联合门锁 - 锁定"
		41: "Buttons.snd41: 联合哔咕"
		42: "Buttons.snd42: 联合咕嘟"
		43: "Buttons.snd43: 联合呻吟咕噜"
		44: "Buttons.snd44: 联合点击交谈"
		45: "Buttons.snd45: 联合点击咕嘟嘶"
		46: "Buttons.snd46: 联合点击嘶（拒绝）"
		47: "Buttons.snd47: 联合点击讲话器"
		]


    // 输入
    input Lock(void) : "锁定按钮，阻止其功能。"
    input Unlock(void) : "解锁按钮，允许其功能。"
    input Press(void) : "激活按钮，仿佛被按下。"
    input PressIn(void) : "激活按钮，仿佛被按下，发送到底部位置。"
    input PressOut(void) : "释放按钮，发送到顶部位置。"

    // 输出
    output OnDamaged(void) : "按钮受损时触发。"
    output OnPressed(void) : "按钮被按下时触发。"
    output OnUseLocked(void) : "按钮在锁定状态下被使用时触发。"
    output OnIn(void) : "按钮到达内部/按下位置时触发。"
    output OnOut(void) : "按钮到达外部/释放位置时触发。"
    ]

@BaseClass base(Node) = HintNode
    [
    spawnflags(flags)  =
        [
        65536: "[65536] 允许跳上" : 0
        ]

    hinttype(choices) : "提示" : 0 =
        [
        0: "无"
        2: "世界：窗口"
        12: "世界：忙碌行为提示"
        13: "世界：视觉上有趣"
        14: "世界：视觉上有趣（不要瞄准）"
        15: "世界：15英尺内禁止联合地雷"
        16: "世界：视觉上有趣（隐身模式）"
        100: "战术：中等蹲伏掩护"
        101: "战术：低矮蹲伏掩护"
        103: "战术：入口/出口夹点"
        105: "战术：敌人劣势点"
        107: "战术：高地"
        400: "蚂蚁狮：挖洞点"
        401: "蚂蚁狮：逃离震动器点"
        450: "头蟹：挖洞点"
        451: "头蟹：退出舱点"
        500: "滚轮：巡逻点"
        501: "滚轮：清理点"
        700: "乌鸦：飞向点"
        701: "乌鸦：栖息点"
        900: "追随者：等待点"
        901: "覆盖跳跃许可"
        902: "玩家小队过渡点"
        903: "NPC退出点"
        904: "步行者节点"
        950: "玩家盟友：推开目的地"
        951: "玩家盟友：恐惧撤退目的地"
        1000: "半条命1世界：机械"
        1001: "半条命1世界：闪烁的灯光"
        1002: "半条命1世界：人类血迹"
        1003: "半条命1世界：外星血迹"
        1300: "光圈：巢穴"
        ]

hintactivity(string) : "提示活动" : : "与此提示节点关联的活动。NPC AI的各个部分会在不同的时候播放这个活动。例如，Actbusy节点会在NPC在节点上忙碌时播放此活动。"
nodefov(choices) : "节点视野" : 180 : "想象这个节点要求NPC必须在节点的视野范围内才能使用这个提示。可以输入其他角度。" =
    [
    45: "45度"
    90: "90度"
    180: "180度"
    360: "360度"
    ]

starthintdisabled(choices) : "开始提示禁用" : 0 =
    [
    0: "否"
    1: "是"
    ]

group(string) : "提示组" : : "如果指定，给提示一个特定的组名。对于需要逻辑分组在一起的提示节点很有用。NPC也可能拒绝使用不匹配其提示组的提示节点。"
targetnode(node_dest) : "目标节点" : -1 : "关联目标节点的节点ID（如果有的话）。"
ignorefacing(choices) : "忽略朝向" : 2 : "不关心节点的朝向。可能不适用于给定的提示类型。" =
    [
    0: "否"
    1: "是"
    2: "默认"
    ]

minimumstate(choices) : "最小状态" : 1 : "要求NPC拥有最小状态才能使用提示。" =
    [
    1: "空闲"
    2: "警戒"
    3: "战斗"
    ]

maximumstate(choices) : "最大状态" : 3 : "要求NPC拥有最大状态才能使用提示。" =
    [
    1: "空闲"
    2: "警戒"
    3: "战斗"
    ]


// 输入
input EnableHint(void) : "启用提示。"
input DisableHint(void) : "禁用提示。"
]

@BaseClass base(BaseEntityInputs) = PlayerInputs: "可以在玩家身上触发的输入，用于那些通过这些输入的实体。"
[

// 输入
input SetHUDVisibility(bool) : "设置玩家的HUD是否可见。"
input SetFogController(target_destination) : "设置当前的env_fog_controller实体。"
input SetColorCorrectionController(target_destination) : "设置当前的color_correction实体。"
input HandleMapEvent(string) : "触发游戏/模组特定事件的通用钩子，例如给玩家触发成就。"
input SetSuppressAttacks(bool) : "阻止或重新允许玩家使用武器。"
input SetBodyGroup(integer) : "HACK: 设置玩家的身体组（从0 - n）。你最好知道你在做什么！"
input Ignite(void) : "点燃，突然起火"
input IgniteLifetime(float) : "点燃，带有参数的生命周期。"
input IgniteNumHitboxFires(integer) : "点燃，带有参数的受影响的hitbox数量。"
input IgniteHitboxFireScalev(float) : "点燃，带有参数的hitbox火焰规模。"
]

@BaseClass base(SetSkin) = SetModel
[
model(studio) : "模型" : : "此实体使用的模型。"
]

@PointClass base(ControlEnables) 
	iconsprite("editor/comp_adv_output")
= comp_adv_output: "Adds a single output to an entity, with precise control over fixup behaviour."
	[
	out_ent(target_destination) : "Outputting Entity" : : "The name of the entity or entities to add the output to."
	out_name(string) : "Output Name" : : "The output name to use."
	target_global(string) : "Target - String" : : "A fixed entity name, !special name or classname to fire inputs at."
	target_local(target_destination) : "Target - Ent Name" : : "If set, the entity to fire inputs at."
	target_instname(string) : "Target - Instance Name" : : "If set, this is appended to the target to form a full target-inst_name name."
	inp_name(string) : "Input Name" : : "The input to fire."
	delay(float) : "Delay" : "0.0" : "The delay to add to the output."
	delay2(float) : "Extra Delay" : "0.0" : "A second delay to add to the first. Useful for instance parameters."
	times(integer) : "Times to Fire" : -1 : "The number of times this output can fire, or -1 for infinite. Hammer normally only allows setting this to 1 or -1."
	params_fmt(string) : "Parameter" : "{1}" : "Sets the parameter to use. This can contain placeholders like {1},{2} etc which will be filled by values in the following parameters. Use two braces like {{ or }} if you need them in the parameter directly."
	params_global1(target_destination) : "Parameter 1 - String" : : "A value which will replace {1} in the parameter."
	params_local1(target_destination) : "Parameter 1 - Ent Name" : : "If set, this is a fixed up entity name which will be used in the parameter, replacing {1}."
	params_pos1(vector) : "Parameter 1 - Position" : : "If set, this is a XYZ position which will be used in the parameter, replacing {1}. This will be offset by instancing."
	params_global2(target_destination) : "Parameter 2 - String" : : "A value which will replace {2} in the parameter."
	params_local2(target_destination) : "Parameter 2 - Ent Name" : : "If set, this is a fixed up entity name which will be used in the parameter, replacing {1}."
	params_pos2(vector) : "Parameter 2 - Position" : : "If set, this is a XYZ position which will be used in the parameter, replacing {2}. This will be offset by instancing."
	params_global3(target_destination) : "Parameter 3 - String" : : "A value which will replace {3} in the parameter."
	params_local3(target_destination) : "Parameter 3 - Ent Name" : : "If set, this is a fixed up entity name which will be used in the parameter, replacing {3}."
	params_pos3(vector) : "Parameter 3 - Position" : : "If set, this is a XYZ position which will be used in the parameter, replacing {3}. This will be offset by instancing."
	params_global4(target_destination) : "Parameter 4 - Ent Name" : : "A value which will replace {4} in the parameter."
	params_local4(target_destination) : "Parameter 4 - Ent Name" : : "If set, this is a fixed up entity name which will be used in the parameter, replacing {4}."
	params_pos4(vector) : "Parameter 4 - Position" : : "If set, this is a XYZ position which will be used in the parameter, replacing {4}. This will be offset by instancing."
	params_global5(target_destination) : "Parameter 5 - String" : : "A value which will replace {5} in the parameter."
	params_local5(target_destination) : "Parameter 5 - Ent Name" : : "If set, this is a fixed up entity name which will be used in the parameter, replacing {5}."
	params_pos5(vector) : "Parameter 5 - Position" : : "If set, this is a XYZ position which will be used in the parameter, replacing {5}. This will be offset by instancing."
	]

@PointClass base(StaticTargetName, ControlEnables) 
	iconsprite("editor/comp_case")
= comp_case: "Simplified version of logic_case which is able to be optimised away by the compiler.This is primarly intended to be used in instances - depending on a fixup value, it will produce different results.It can be used alternatively to pick a random output, though this is fixed at compile time for each inputting entity."
	[
	multiplecasesallowed(choices) : "Multiple case hits allowed" : 0 : "If an input value matches a given case, are we allowed to test the rest of the cases or should we stop there? Don't worry about this if you're only using this entity for PickRandom." =
		[
		0: "No"
		1: "Yes"
		]

	value(string) : "Input Value" : : "If the InValue parameter is blank or Trigger is used, this value will be used instead."
	mode(choices) : "Mode" : "casefold" : "Specifies how comparisons are performed. Text mode simply checks for a case that matches the input text. Numeric treats values as numbers, allowing cases to additionally specify a comparison like '< 3.14'. Weighted Random instead changes the case values to specify the chance to produce any given case. In all modes, each case is compared in order." =
		[
		"string": "Text - Case Sensitive"
		"casefold": "Text - Case Insensitive"
		"numeric": "Numeric"
		"randweight": "Weighted Random"
		]

	seed(string) : "Random Seed" : : "For the PickRandom input, the position and name of the input entity and the case are used to seed a random number generator. This can be set to further randomise the chosen case."
	misschance(float) : "Miss Chance (%)" : 0 : "If nonzero, PickRandom will skip picking cases entirely this often. Only OnUsed and OnMissed will be fired."
	case01(string) : "Case 01" : : "Fires OnCase01 if the InValue parameter matches this value. In Numeric mode, comparison operators such as <, >, =, !=, >=, or <= may be put at the start of the value. In Weighted Random mode, this instead is the chance that this case will be picked."
	case02(string) : "Case 02" : : "Fires OnCase02 if the InValue parameter matches this value. In Numeric mode, comparison operators such as <, >, =, !=, >=, or <= may be put at the start of the value. In Weighted Random mode, this instead is the chance that this case will be picked."
	case03(string) : "Case 03" : : "Fires OnCase03 if the InValue parameter matches this value. In Numeric mode, comparison operators such as <, >, =, !=, >=, or <= may be put at the start of the value. In Weighted Random mode, this instead is the chance that this case will be picked."
	case04(string) : "Case 04" : : "Fires OnCase04 if the InValue parameter matches this value. In Numeric mode, comparison operators such as <, >, =, !=, >=, or <= may be put at the start of the value. In Weighted Random mode, this instead is the chance that this case will be picked."
	case05(string) : "Case 05" : : "Fires OnCase05 if the InValue parameter matches this value. In Numeric mode, comparison operators such as <, >, =, !=, >=, or <= may be put at the start of the value. In Weighted Random mode, this instead is the chance that this case will be picked."
	case06(string) : "Case 06" : : "Fires OnCase06 if the InValue parameter matches this value. In Numeric mode, comparison operators such as <, >, =, !=, >=, or <= may be put at the start of the value. In Weighted Random mode, this instead is the chance that this case will be picked."
	case07(string) : "Case 07" : : "Fires OnCase07 if the InValue parameter matches this value. In Numeric mode, comparison operators such as <, >, =, !=, >=, or <= may be put at the start of the value. In Weighted Random mode, this instead is the chance that this case will be picked."
	case08(string) : "Case 08" : : "Fires OnCase08 if the InValue parameter matches this value. In Numeric mode, comparison operators such as <, >, =, !=, >=, or <= may be put at the start of the value. In Weighted Random mode, this instead is the chance that this case will be picked."
	case09(string) : "Case 09" : : "Fires OnCase09 if the InValue parameter matches this value. In Numeric mode, comparison operators such as <, >, =, !=, >=, or <= may be put at the start of the value. In Weighted Random mode, this instead is the chance that this case will be picked."
	case10(string) : "Case 10" : : "Fires OnCase10 if the InValue parameter matches this value. In Numeric mode, comparison operators such as <, >, =, !=, >=, or <= may be put at the start of the value. In Weighted Random mode, this instead is the chance that this case will be picked."
	case11(string) : "Case 11" : : "Fires OnCase11 if the InValue parameter matches this value. In Numeric mode, comparison operators such as <, >, =, !=, >=, or <= may be put at the start of the value. In Weighted Random mode, this instead is the chance that this case will be picked."
	case12(string) : "Case 12" : : "Fires OnCase12 if the InValue parameter matches this value. In Numeric mode, comparison operators such as <, >, =, !=, >=, or <= may be put at the start of the value. In Weighted Random mode, this instead is the chance that this case will be picked."
	case13(string) : "Case 13" : : "Fires OnCase13 if the InValue parameter matches this value. In Numeric mode, comparison operators such as <, >, =, !=, >=, or <= may be put at the start of the value. In Weighted Random mode, this instead is the chance that this case will be picked."
	case14(string) : "Case 14" : : "Fires OnCase14 if the InValue parameter matches this value. In Numeric mode, comparison operators such as <, >, =, !=, >=, or <= may be put at the start of the value. In Weighted Random mode, this instead is the chance that this case will be picked."
	case15(string) : "Case 15" : : "Fires OnCase15 if the InValue parameter matches this value. In Numeric mode, comparison operators such as <, >, =, !=, >=, or <= may be put at the start of the value. In Weighted Random mode, this instead is the chance that this case will be picked."
	case16(string) : "Case 16" : : "Fires OnCase16 if the InValue parameter matches this value. In Numeric mode, comparison operators such as <, >, =, !=, >=, or <= may be put at the start of the value. In Weighted Random mode, this instead is the chance that this case will be picked."

	// Inputs
	input InValue(string) : "Replaced by whichever case matches the parameter. Does nothing in Weighted Random mode."
	input Trigger(void) : "Replaced by whichever case matches the input keyvalue. In Weighted Random mode, behaves like PickRandom."
	input PickRandom(void) : "Replaced by a random case with outputs defined."

	// Outputs
	output OnCase01(void) : "Fired when the input value equals the Case01 value."
	output OnCase02(void) : "Fired when the input value equals the Case02 value."
	output OnCase03(void) : "Fired when the input value equals the Case03 value."
	output OnCase04(void) : "Fired when the input value equals the Case04 value."
	output OnCase05(void) : "Fired when the input value equals the Case05 value."
	output OnCase06(void) : "Fired when the input value equals the Case06 value."
	output OnCase07(void) : "Fired when the input value equals the Case07 value."
	output OnCase08(void) : "Fired when the input value equals the Case08 value."
	output OnCase09(void) : "Fired when the input value equals the Case09 value."
	output OnCase10(void) : "Fired when the input value equals the Case10 value."
	output OnCase11(void) : "Fired when the input value equals the Case11 value."
	output OnCase12(void) : "Fired when the input value equals the Case12 value."
	output OnCase13(void) : "Fired when the input value equals the Case13 value."
	output OnCase14(void) : "Fired when the input value equals the Case14 value."
	output OnCase15(void) : "Fired when the input value equals the Case15 value."
	output OnCase16(void) : "Fired when the input value equals the Case16 value."
	output OnDefault(void) : "Fired when the input value does not equal any of the Case values."
	output OnUsed(string) : "Fired when an input value is received, regardless of whether it matches a case."
	output OnMatched(string) : "Fired when an input value matches any of the cases."
	output OnMissed(string) : "Fired when the miss chance succeeded."
	]

@PointClass base(Angles, ControlEnables) 
	iconsprite("editor/comp_kv_setter")
= comp_kv_setter: "Sets a keyvalue on an entity to a new value. This is useful to compute spawnflags, or to adjust keyvalues when the target entity's options can't be set to a fixup variable."
	[
	target(target_destination) : "Target Entity" : : "The name of the entity or entities to set values on."
	mode(choices) : "Mode" : "kv" : "The type of value to set." =
		[
		"kv": "KeyValues"
		"flags": "SpawnFlags"
		]

	kv_name(string) : "Name / Mask" : : "The name of the keyvalue to set, or the bits to change for spawnflags."
	kv_value_global(string) : "Value - String" : : "The value to apply."
	kv_value_local(target_destination) : "Value - Ent Name" : : "If set, use this fixed-up entity name."
	kv_value_pos(vector) : "Value - Position" : : "If set, overrides the regular value. This will be offset by instancing."
	invert(choices) : "Invert Value" : 0 : "If enabled, invert the value so 0 and 1 are swapped." =
		[
		0: "No"
		1: "Yes"
		]

	rotate(choices) : "Rotate Value" : 0 : "If enabled, treat the value as a vector and rotate it by the angles set on this entity first." =
		[
		0: "No"
		1: "Yes"
		]

	conv_ang(choices) : "Convert To Angle" : 0 : "If enabled, convert a +X axis normal back into the Euler angle." =
		[
		0: "No"
		1: "Yes"
		]


	// Outputs
	output OnUser1(void) : "Fired in response to FireUser1 input."
	output OnUser2(void) : "Fired in response to FireUser2 input."
	output OnUser3(void) : "Fired in response to FireUser3 input."
	output OnUser4(void) : "Fired in response to FireUser4 input."
	]

@PointClass base(ControlEnables) 
	iconsprite("editor/comp_pack")
= comp_pack: "Explicitly identify resources to pack into the map. If more are needed, add additional keyvalues with SmartEdit off."
	[
	generic1(string) : "Generic" : : "Pack a file, starting in any of the content folders."
	generic2(string) : "Generic" : : "Pack a file, starting in any of the content folders."
	generic3(string) : "Generic" : : "Pack a file, starting in any of the content folders."
	generic4(string) : "Generic" : : "Pack a file, starting in any of the content folders."
	generic5(string) : "Generic" : : "Pack a file, starting in any of the content folders."
	sound1(sound) : "Sound" : : "Pack a raw sound file or a soundscript."
	sound2(sound) : "Sound" : : "Pack a raw sound file or a soundscript."
	sound3(sound) : "Sound" : : "Pack a raw sound file or a soundscript."
	sound4(sound) : "Sound" : : "Pack a raw sound file or a soundscript."
	sound5(sound) : "Sound" : : "Pack a raw sound file or a soundscript."
	model1(studio) : "Model" : : "Pack a model."
	model2(studio) : "Model" : : "Pack a model."
	model3(studio) : "Model" : : "Pack a model."
	model4(studio) : "Model" : : "Pack a model."
	model5(studio) : "Model" : : "Pack a model."
	material1(material) : "Material" : : "Pack a material."
	material2(material) : "Material" : : "Pack a material."
	material3(material) : "Material" : : "Pack a material."
	material4(material) : "Material" : : "Pack a material."
	material5(material) : "Material" : : "Pack a material."
	particle1(string) : "Particle" : : "Pack a particle system, and include in the manifest."
	particle2(string) : "Particle" : : "Pack a particle system, and include in the manifest."
	particle3(string) : "Particle" : : "Pack a particle system, and include in the manifest."
	particle4(string) : "Particle" : : "Pack a particle system, and include in the manifest."
	particle5(string) : "Particle" : : "Pack a particle system, and include in the manifest."
	soundscript1(string) : "SoundScript" : : "Pack a soundscript file, and include in the manifest."
	soundscript2(string) : "SoundScript" : : "Pack a soundscript file, and include in the manifest."
	soundscript3(string) : "SoundScript" : : "Pack a soundscript file, and include in the manifest."
	soundscript4(string) : "SoundScript" : : "Pack a soundscript file, and include in the manifest."
	soundscript5(string) : "SoundScript" : : "Pack a soundscript file, and include in the manifest."
	]

@PointClass base(ControlEnables) 
	iconsprite("editor/comp_pack_rename")
= comp_pack_rename: "Pack a file into the BSP, under a different name than it starts with."
	[
	filesrc(string) : "Source Filename" : : "Filename to read data from."
	filedest(string) : "Destination Filename" : : "Filename to pack under."
	filetype(choices) : "File Type" : "GENERIC" : "File type to record it as. For Model files, the .vtx/vtx/phy etc files are also packed automatically." =
		[
		"GENERIC": "Generic"
		"SOUNDSCRIPT": "SoundScript file (add to manifest)"
		"PARTICLE_FILE": "Particle System (add to manifest)"
		"VSCRIPT_SQUIRREL": "VScript (Squirrel)"
		"MATERIAL": "Material"
		"TEXTURE": "Texture"
		"MODEL": "Model"
		]

	]

@PointClass base(ControlEnables) 
	iconsprite("editor/comp_pack_replace_soundscript")
= comp_pack_replace_soundscript: "Replace a soundscript with a different one."
	[
	original(string) : "Original SoundScript" : : "Prevent this soundscript from being included."
	replacement(string) : "New SoundScript" : : "Force this soundscript to be included."
	]

@PointClass base(Angles, ControlEnables) 
	iconsprite("editor/comp_precache_model")
	studioprop()
	line(255 255 255, targetname, lineent)
= comp_precache_model: "Force a specific model to load, for runtime switching. Duplicates will be removed."
	[
	model(studio) : "Model" : : "The model to load."
	skin(integer) : "Skin" : : "Skin to show."
	skinset(string) : "Used Skins" : : "Set this to a space seperated list of all the skin numbers which will be used. This allows auto-packing to skip unused ones. If blank all skins are assumed to be used."
	lineent(target_destination) : "Line Entity" : : "Draws a line to the specified entity. Use this to indicate in Hammer if the model is meant for a specific entity."
	]

@PointClass base(ControlEnables) 
	iconsprite("editor/comp_precache_sound")
= comp_precache_sound: "Force a specific sound to load, for runtime switching. Duplicates will be removed. More keyvalues can be added."
	[
	sound1(sound) : "Sound" : : "Pack and precache a raw sound file or a soundscript."
	sound2(sound) : "Sound" : : "Pack and precache a raw sound file or a soundscript."
	sound3(sound) : "Sound" : : "Pack and precache a raw sound file or a soundscript."
	sound4(sound) : "Sound" : : "Pack and precache a raw sound file or a soundscript."
	sound5(sound) : "Sound" : : "Pack and precache a raw sound file or a soundscript."
	sound6(sound) : "Sound" : : "Pack and precache a raw sound file or a soundscript."
	sound7(sound) : "Sound" : : "Pack and precache a raw sound file or a soundscript."
	sound8(sound) : "Sound" : : "Pack and precache a raw sound file or a soundscript."
	sound9(sound) : "Sound" : : "Pack and precache a raw sound file or a soundscript."
	sound10(sound) : "Sound" : : "Pack and precache a raw sound file or a soundscript."
	]

@MoveClass base(StaticTargetName) 
	sphere(radius)
	animator()
	keyframe()
	iconsprite("editor/comp_prop_cable")
	line(128 128 128, targetname, bunting)
= comp_prop_cable: "Generates cables using a static prop. comp_prop_rope is an alternate name, they can be interchanged."
	[
	group(target_source) : "Group" : : "If set, all cables with the same group will be compiled to one model."
	nextkey(target_destination) : "Next Cable" : : "Name of the next cable along this path."
	slack(integer) : "Slack" : 25 : "How much extra length the cable has, for 'catenary' mode (by default it has the length between its two endpoints in the editor)."
	positioninterpolator(choices) : "Type" : 2 : "How to interpolate the cable. Straight makes it straight. Spline uses a spline curve, which smoothly blends between points. Catenary makes it hang down, like the original move_rope. Bezier is an alternate smooth curve, but the visual in Hammer will be incorrect." =
		[
		0: "Straight"
		1: "Spline Curve"
		2: "Catenary"
		3: "Bezier"
		]

	segments(integer) : "Segments" : 2 : "Number of nodes to generate between each cable. Higher values make smoother cables, but produce more faces."
	sides(integer) : "Sides" : 8 : "Number of faces for each cylindrical section. Only the value at the start of the cable is used."
	radius(float) : "Radius" : "1.0" : "Radius of this cable section."
	coll_segments(choices) : "Collision Segments" : -1 : "Type in the number of convex segments to generate between each cable. Higher values make smoother collision, but produce more convex segments." =
		[
		-1: "[-1] Same as visual geometry"
		]

	coll_sides(choices) : "Collision Sides" : 0 : "Type in the number of faces for each cylindrical collision section. If set to less than 3 sides, collision will not be generated." =
		[
		0: "[0] No collisions"
		1: "[1] No collisions"
		2: "[2] No collisions"
		]

	material(material) : "Cable Material" : "models/cables/generic_black" : "The material to use for the cable. Must be a model material."
	mat_scale(float) : "Lengthwise Material Scale" : 1 : "This changes the texture resolution along the cable, relative to the amount of width used. Larger values stretch the texture and smaller values scrunch it up."
	mat_rotate(choices) : "Material Orientation" : 0 : "Controls which direction the cable runs in the material, if your texture is rotated." =
		[
		0: "Vertical"
		1: "Horizontal"
		]

	u_min(float) : "Width Start" : "0.0" : "The distance along the texture to start. 0 is the left/bottom side, 1 is the right/top side. This allows using only part of the texture, if it contains multiple different cable styles."
	u_max(float) : "Width End" : "1.0" : "The distance along the texture to end. 0 is the left/bottom side, 1 is the right/top side. This allows using only part of the texture, if it contains multiple different cable styles."
	bunting(target_destination) : "Bunting Definition" : : "Set to the name of a comp_prop_rope_bunting, to define models which will be placed at each segment across the rope."
	linedivider_staticprop(string) readonly : "=========================================================================================================="
	renderamt(integer) : "Alpha" : 255 : "Alpha of the fade, where 0 = fully transparent and 255 = fully opaque."
	rendercolor(color255) : "Color (R G B)" : "255 255 255"
	screenspacefade(choices) : "Screen Space Fade" : 0 : "The method by which the fading distance should be determined. If 'No', the fade distances is the distance from the player's view to the object, in inches. If 'Yes', the fade distance is the size of the object onscreen, in pixels." =
		[
		0: "No"
		1: "Yes"
		]

	fademindist(float) : "Start Fade Dist/Pixels" : -1 : "Distance at which the prop starts to fade (<0 = use fademaxdist). If 'Screen Space Fade' is selected, this represents the number of pixels wide covered by the prop when it starts to fade."
	fademaxdist(float) : "End Fade Dist/Pixels" : 0 : "Maximum distance at which the prop is visible (0 = don't fade out). If 'Screen Space Fade' is selected, this represents the *minimum* number of pixels wide covered by the prop when it fades."
	fadescale(float) : "Fade Scale" : 1 : "If you specify a fade in the worldspawn, or if the engine is running under dx7 [hl2/ep1/portal] or dx8 [ep2/tf], then the engine will forcibly fade out props even if fademindist/fademaxdist isn't specified. This scale factor gives you some control over the fade. Using 0 here turns off the forcible fades. Numbers smaller than 1 cause the prop to fade out at further distances, and greater than 1 cause it to fade out at closer distances."
	disableshadows(choices) : "Disable Shadows" : 0 =
		[
		0: "No"
		1: "Yes"
		]

	disableselfshadowing(choices) : "Disable Self-Shadowing" : 0 =
		[
		0: "No"
		1: "Yes"
		]

	disablevertexlighting(choices) : "Disable Vertex lighting" : 0 : "Disable per-vertex lighting on this prop." =
		[
		0: "No"
		1: "Yes"
		]

	drawinfastreflection(choices) : "Render in Fast Reflections" : 0 : "If enabled, causes this entity/prop to to render in fast water reflections (i.e. when a water material specifies $reflectonlymarkedentities) and in the world impostor pass." =
		[
		0: "No"
		1: "Yes"
		]

	movespeed(integer) readonly : "Speed (unused)" : 1 : "This key needs to be greater than zero to show the preview in Hammer, ignore it."
	]

@MoveClass base(StaticTargetName) 
	sphere(radius)
	animator()
	keyframe()
	iconsprite("editor/comp_prop_rope")
	line(128 128 128, targetname, bunting)
= comp_prop_rope: "Generates ropes using a static prop. comp_prop_cable is an alternate name, they can be interchanged."
	[
	group(target_source) : "Group" : : "If set, all ropes with the same group will be compiled to one model."
	nextkey(target_destination) : "Next Rope" : : "Name of the next rope along this path."
	slack(integer) : "Slack" : 25 : "How much extra length the rope has, for 'catenary' mode (by default it has the length between its two endpoints in the editor)."
	positioninterpolator(choices) : "Type" : 2 : "How to interpolate the rope. Straight makes it straight. Spline uses a spline curve, which smoothly blends between points. Catenary makes it hang down, like the original move_rope. Bezier is an alternate smooth curve, but the visual in Hammer will be incorrect." =
		[
		0: "Straight"
		1: "Spline Curve"
		2: "Catenary"
		3: "Bezier"
		]

	segments(integer) : "Segments" : 2 : "Number of nodes to generate between each rope. Higher values make smoother ropes, but produce more faces."
	sides(integer) : "Sides" : 8 : "Number of faces for each cylindrical section. Only the value at the start of the rope is used."
	radius(float) : "Radius" : "1.0" : "Radius of this rope section."
	coll_segments(choices) : "Collision Segments" : -1 : "Type in the number of convex segments to generate between each rope. Higher values make smoother collision, but produce more convex segments." =
		[
		-1: "[-1] Same as visual geometry"
		]

	coll_sides(choices) : "Collision Sides" : 0 : "Type in the number of faces for each cylindrical collision section. If set to less than 3 sides, collision will not be generated." =
		[
		0: "[0] No collisions"
		1: "[1] No collisions"
		2: "[2] No collisions"
		]

	material(material) : "Rope Material" : "models/cables/generic_black" : "The material to use for the rope. Must be a model material."
	mat_scale(float) : "Lengthwise Material Scale" : 1 : "This changes the texture resolution along the rope, relative to the amount of width used. Larger values stretch the texture and smaller values scrunch it up."
	mat_rotate(choices) : "Material Orientation" : 0 : "Controls which direction the rope runs in the material, if your texture is rotated." =
		[
		0: "Vertical"
		1: "Horizontal"
		]

	u_min(float) : "Width Start" : "0.0" : "The distance along the texture to start. 0 is the left/bottom side, 1 is the right/top side. This allows using only part of the texture, if it contains multiple different rope styles."
	u_max(float) : "Width End" : "1.0" : "The distance along the texture to end. 0 is the left/bottom side, 1 is the right/top side. This allows using only part of the texture, if it contains multiple different rope styles."
	bunting(target_destination) : "Bunting Definition" : : "Set to the name of a comp_prop_rope_bunting, to define models which will be placed at each segment across the rope."
	linedivider_staticprop(string) readonly : "=========================================================================================================="
	renderamt(integer) : "Alpha" : 255 : "Alpha of the fade, where 0 = fully transparent and 255 = fully opaque."
	rendercolor(color255) : "Color (R G B)" : "255 255 255"
	screenspacefade(choices) : "Screen Space Fade" : 0 : "The method by which the fading distance should be determined. If 'No', the fade distances is the distance from the player's view to the object, in inches. If 'Yes', the fade distance is the size of the object onscreen, in pixels." =
		[
		0: "No"
		1: "Yes"
		]

	fademindist(float) : "Start Fade Dist/Pixels" : -1 : "Distance at which the prop starts to fade (<0 = use fademaxdist). If 'Screen Space Fade' is selected, this represents the number of pixels wide covered by the prop when it starts to fade."
	fademaxdist(float) : "End Fade Dist/Pixels" : 0 : "Maximum distance at which the prop is visible (0 = don't fade out). If 'Screen Space Fade' is selected, this represents the *minimum* number of pixels wide covered by the prop when it fades."
	fadescale(float) : "Fade Scale" : 1 : "If you specify a fade in the worldspawn, or if the engine is running under dx7 [hl2/ep1/portal] or dx8 [ep2/tf], then the engine will forcibly fade out props even if fademindist/fademaxdist isn't specified. This scale factor gives you some control over the fade. Using 0 here turns off the forcible fades. Numbers smaller than 1 cause the prop to fade out at further distances, and greater than 1 cause it to fade out at closer distances."
	disableshadows(choices) : "Disable Shadows" : 0 =
		[
		0: "No"
		1: "Yes"
		]

	disableselfshadowing(choices) : "Disable Self-Shadowing" : 0 =
		[
		0: "No"
		1: "Yes"
		]

	disablevertexlighting(choices) : "Disable Vertex lighting" : 0 : "Disable per-vertex lighting on this prop." =
		[
		0: "No"
		1: "Yes"
		]

	drawinfastreflection(choices) : "Render in Fast Reflections" : 0 : "If enabled, causes this entity/prop to to render in fast water reflections (i.e. when a water material specifies $reflectonlymarkedentities) and in the world impostor pass." =
		[
		0: "No"
		1: "Yes"
		]

	movespeed(integer) readonly : "Speed (unused)" : 1 : "This key needs to be greater than zero to show the preview in Hammer, ignore it."
	]

@MoveClass base(StaticTargetName) 
	iconsprite("editor/comp_prop_rope_bunting")
= comp_prop_rope_bunting: "Specifies small props which will be placed at regular intervals across the compiled rope."
	[
	weight(integer) : "Weight" : 1 : "If multiple are defined with the same weighting, this specifies the relative probabilities.This works like a lottery - each model has this many 'tickets', and then one is chosen randomly each time. If you have two choices with a weight of 9 and 1, the first will be chosen 90% of the time."
	placement_interval(integer) : "Placement Interval" : 1 : "Place this prop every X segments, not including the start/end of the rope."
	distance(float) : "Placement Distance" : 0 : "If greater than zero, override Placement Interval, and instead place every this many units."
	model(studio) : "Model" : : "Specifies the model to place. This can either be an MDL which is placed as invidual prop_statics, or a SMD (relative to a game folder) which is merged into the rope model. Alternatively make it entirely blank to have a chance to randomly skip placing ropes."
	angles(angle) : "Rotation" : "0 0 0" : "Rotate the model by this much, before applying the orientation of the rope. After this is applied, the X axis should be aligned with the rope direction."
	orient(choices) : "Orientation Mode" : "follow" : "Controls how the rope orientation affects the model." =
		[
		"follow": "Follow Rope"
		"yaw": "Yaw Only"
		"pitch_yaw": "Pitch and Yaw"
		"none": "No Rotation"
		"rand_yaw": "Random Yaw"
		"rand": "Random"
		]

	]

@PointClass base(Angles) 
	iconsprite("editor/comp_propcombine_set")
	wirebox(mins, maxs)
= comp_propcombine_set: "Specifies a group of props that will be combined together."
	[
	mins(vector) : "BBox Mins" : "-32 -32 -32" : "Minimum offset from the entity, defining the shape."
	maxs(vector) : "BBox Maxes" : "32 32 32" : "Maximum offset from the entity, defining the shape."
	name(string) : "Name" : : "Two sets with the same name will be treated as one."
	prop(studio) : "Model Filter" : : "If set, a combinable model used to filter which others will be combined. The propcombine set will only apply to models which could be combined with this one."
	skin(integer) : "Skin Filter" : 0 : "The skin for the Model Filter."
	]

@PointClass base(StaticTargetName, ControlEnables) 
	iconsprite("editor/comp_relay")
= comp_relay: "Simplified version of logic_relay which is able to be optimised away by the compiler.The various inputs and outputs are useful for bundling commands together, or using more appopriate verbs.Inputs only work if given directly from entities (or via instance redirection), not ingame or dynamically.All inputs/outputs may pass through any parameter, if no override is specified."
	[
	delay(float) : "Extra Delay" : "0.0" : "Add this delay to all outputs. This allows you to control this via $fixup values, for instance."

	// Inputs
	input Trigger(string) : "Trigger the relay and fire the output."
	input TurnOn(string) : "Fire the OnTurnedOn output."
	input TurnOff(string) : "Fire the OnTurnedOff output."
	input FireUser1(string) : "Causes this relay's OnUser1 output to be fired."
	input FireUser2(string) : "Causes this relay's OnUser2 output to be fired."
	input FireUser3(string) : "Causes this relay's OnUser3 output to be fired."
	input FireUser4(string) : "Causes this relay's OnUser4 output to be fired."
	input FireUser5(string) : "Causes this relay's OnUser5 output to be fired."
	input FireUser6(string) : "Causes this relay's OnUser6 output to be fired."
	input FireUser7(string) : "Causes this relay's OnUser7 output to be fired."
	input FireUser8(string) : "Causes this relay's OnUser8 output to be fired."

	// Outputs
	output OnTrigger(string) : "Fired when the relay is triggered."
	output OnTurnedOn(string) : "Fired when the relay is turned on."
	output OnTurnedOff(string) : "Fired when the relay is turned off."
	output OnUser1(string) : "Fired in response to a FireUser1 input."
	output OnUser2(string) : "Fired in response to a FireUser2 input."
	output OnUser3(string) : "Fired in response to a FireUser3 input."
	output OnUser4(string) : "Fired in response to a FireUser4 input."
	output OnUser5(string) : "Fired in response to a FireUser5 input."
	output OnUser6(string) : "Fired in response to a FireUser6 input."
	output OnUser7(string) : "Fired in response to a FireUser7 input."
	output OnUser8(string) : "Fired in response to a FireUser8 input."
	]

@PointClass base(Origin, Angles, ControlEnables) 
	iconsprite("editor/comp_scriptvar_setter")
	studio("models/editor/cone_helper.mdl")
	line(255 255 255, targetname, target)
	line(255 255 255, targetname, ref)
= comp_scriptvar_setter: "Assigns data or a group of data to a variable in an entity's VScript scope or the global scope on spawn.\nTo set an array, provide an index in the variable name in the form 'varname[4]'. \nAll the comp_scriptvars pointing to that variable will be collected into a single array literal, with holes filled by *null*. \nIf the brackets are empty, these values will fill those holes and then append to the end in an arbitrary order."
	[
	target(target_destination) : "Script Entity" : : "The entity to set a variable on. Alternatively, leave this blank to assign the variable ::globally."
	variable(string) : "Variable Name" : : "The name of the variable to set. A specific array index can be set with the form 'varname[4]'. Alternatively use 'varname[]' to assign them to the first index available. Holes in the array are set to null. If this is a :;global name, the script entity is ignored."
	ref(target_destination) : "Reference Entity" : : "If set, a reference entity to use to obtain data from instead of this one."
	mode(choices) : "Mode" : "pos" : "The kind of data to read. For Constants, the position/reference is ignored completely. For Entity Handle to be useful, only one reference entity should exist. For Offset and Distance, it's the offset of the reference relative to this entity. For Entity KeyValue, the constant is the keyvalue name, then the value is converted to an appropriate Squirrel type. " =
		[
		"const": "Constant"
		"string": "Stringified Constant"
		"bool": "Boolean Constant"
		"inv_bool": "Inverted Boolean Constant"
		"name": "Entity Name"
		"handle": "Entity Handle"
		"keyvalue": "Entity KeyValue"
		"pos": "Position"
		"pos_x": "Position - X only"
		"pos_y": "Position - Y only"
		"pos_z": "Position - Z only"
		"ang": "Angle (as vector)"
		"qangle": "Angle (as QAngle)"
		"off": "Offset to Reference"
		"dist": "Distance to Reference"
		"x": "Forward Direction"
		"y": "Left Direction"
		"z": "Up Direction"
		]

	const(string) : "Scale / Constant" : : "A scale factor for the data, or a constant to use directly. The exact behaviour depends on the mode."
	]

@MoveClass base(StaticTargetName, Angles) 
	sphere(radius)
	animator()
	keyframe()
	iconsprite("editor/comp_prop_rope")
= comp_vactube_spline: "Constructs a custom vactube model, using a set of path points."
	[
	nextkey(target_destination) : "Next Rope" : : "Name of the next spline node."
	opaque(choices) : "Opaque Tube" : 0 : "Whether the tube should be glass, or the black opaque version." =
		[
		0: "No"
		1: "Yes"
		]

	skin(choices) : "Mode" : 0 : "Whether this will link to comp_vactube_junctions, or just be a static prop." =
		[
		0: "Static Prop"
		1: "Vactube Junction"
		]

	segments(integer) : "Segments" : 2 : "Number of nodes to generate for this. Higher values make smoother tubes, but produce more faces."
	collisions(choices) : "Enable Collisions" : 1 : "Should a collision mesh should be generated?" =
		[
		0: "No"
		1: "Yes"
		]

	positioninterpolator(choices) : "Type" : 1 : "How to interpolate the tube. Spline uses a spline curve, which smoothly blends between points. Bezier is an alternate smooth curve, but the visual in Hammer will be incorrect." =
		[
		1: "Spline Curve"
		3: "Bezier"
		]

	vac_separateglass(choices) : "Separate Glass and Frame" : 0 : "Separating glass and frame can help with transparency sorting issue" =
		[
		0: "No"
		1: "Yes"
		]

	linedivider_staticprop(string) readonly : "=========================================================================================================="
	renderamt(integer) : "Alpha" : 255 : "Alpha of the fade, where 0 = fully transparent and 255 = fully opaque."
	rendercolor(color255) : "Color (R G B)" : "255 255 255"
	screenspacefade(choices) : "Screen Space Fade" : 0 : "The method by which the fading distance should be determined. If 'No', the fade distances is the distance from the player's view to the object, in inches. If 'Yes', the fade distance is the size of the object onscreen, in pixels." =
		[
		0: "No"
		1: "Yes"
		]

	fademindist(float) : "Start Fade Dist/Pixels" : -1 : "Distance at which the prop starts to fade (<0 = use fademaxdist). If 'Screen Space Fade' is selected, this represents the number of pixels wide covered by the prop when it starts to fade."
	fademaxdist(float) : "End Fade Dist/Pixels" : 0 : "Maximum distance at which the prop is visible (0 = don't fade out). If 'Screen Space Fade' is selected, this represents the *minimum* number of pixels wide covered by the prop when it fades."
	fadescale(float) : "Fade Scale" : 1 : "If you specify a fade in the worldspawn, or if the engine is running under dx7 [hl2/ep1/portal] or dx8 [ep2/tf], then the engine will forcibly fade out props even if fademindist/fademaxdist isn't specified. This scale factor gives you some control over the fade. Using 0 here turns off the forcible fades. Numbers smaller than 1 cause the prop to fade out at further distances, and greater than 1 cause it to fade out at closer distances."
	disableshadows(choices) : "Disable Shadows" : 0 =
		[
		0: "No"
		1: "Yes"
		]

	disableselfshadowing(choices) : "Disable Self-Shadowing" : 0 =
		[
		0: "No"
		1: "Yes"
		]

	disablevertexlighting(choices) : "Disable Vertex lighting" : 0 : "Disable per-vertex lighting on this prop." =
		[
		0: "No"
		1: "Yes"
		]

	drawinfastreflection(choices) : "Render in Fast Reflections" : 0 : "If enabled, causes this entity/prop to to render in fast water reflections (i.e. when a water material specifies $reflectonlymarkedentities) and in the world impostor pass." =
		[
		0: "No"
		1: "Yes"
		]

	movespeed(integer) readonly : "Speed (unused)" : 1 : "This needs to be greater than zero to show the preview lines."
	]

@PointClass base(Angles) 
	instance()
	size(-2 -2 -2, 2 2 2)
= func_instance: "用于放置地图文件实例的实体。你可以对这个实体进行翻译和旋转操作。你可以使用替换键在实例内容中对参数进行更改，只需在变量名前加上$符号。然后在实例内容的任何键/值对的值部分使用$variable名。"
    [
    targetname(target_source) : "修正名称" : : "所有实体将根据修正样式与此名称进行修正。"
    file(instance_file) : "VMF文件名" : : "这表示相对于地图文件名的地图文件。如果在父目录中存在sdk_content/maps/，也会相对于它查找。"
    fixup_style(choices) : "实体名称修正" : 0 : "实例化实体名称的修正样式。使用'修正名称'字段。" =
        [
        0: "前缀"
        1: "后缀"
        2: "无"
        ]

    spawnpositionname(string) : "生成位置名称" : : "当实例被导出到实体层时创建的生成位置的名称。"
    propagate_fixup(choices) : "修正嵌套实例" : 0 : "所有嵌套实例将遵循此实例的修正规则。嵌套实例中的任何修正规则将被忽略。" =
        [
        0: "否"
        1: "是"
        ]

    replace01(instance_variable) : "替换变量" : : "这是一个替换参数。它的形式为$variable value。该实例内所有包含$variable的实体都会被替换为value内容。例如：$color 255 0 0"
    replace02(instance_variable) : "替换变量" : : "这是一个替换参数。它的形式为$variable value。该实例内所有包含$variable的实体都会被替换为value内容。例如：$color 255 0 0"
	replace03(instance_variable) : "替换变量" : : "这是一个替换参数。它的形式为$variable value。该实例内所有包含$variable的实体都会被替换为value内容。例如：$color 255 0 0"
	replace04(instance_variable) : "替换变量" : : "这是一个替换参数。它的形式为$variable value。该实例内所有包含$variable的实体都会被替换为value内容。例如：$color 255 0 0"
	replace05(instance_variable) : "替换变量" : : "这是一个替换参数。它的形式为$variable value。该实例内所有包含$variable的实体都会被替换为value内容。例如：$color 255 0 0"
	replace06(instance_variable) : "替换变量" : : "这是一个替换参数。它的形式为$variable value。该实例内所有包含$variable的实体都会被替换为value内容。例如：$color 255 0 0"
	replace07(instance_variable) : "替换变量" : : "这是一个替换参数。它的形式为$variable value。该实例内所有包含$variable的实体都会被替换为value内容。例如：$color 255 0 0"
	replace08(instance_variable) : "替换变量" : : "这是一个替换参数。它的形式为$variable value。该实例内所有包含$variable的实体都会被替换为value内容。例如：$color 255 0 0"
	replace09(instance_variable) : "替换变量" : : "这是一个替换参数。它的形式为$variable value。该实例内所有包含$variable的实体都会被替换为value内容。例如：$color 255 0 0"
	replace10(instance_variable) : "替换变量" : : "这是一个替换参数。它的形式为$variable value。该实例内所有包含$variable的实体都会被替换为value内容。例如：$color 255 0 0"
	replace11(instance_variable) : "替换变量" : : "这是一个替换参数。它的形式为$variable value。该实例内所有包含$variable的实体都会被替换为value内容。例如：$color 255 0 0"
	replace12(instance_variable) : "替换变量" : : "这是一个替换参数。它的形式为$variable value。该实例内所有包含$variable的实体都会被替换为value内容。例如：$color 255 0 0"
	replace13(instance_variable) : "替换变量" : : "这是一个替换参数。它的形式为$variable value。该实例内所有包含$variable的实体都会被替换为value内容。例如：$color 255 0 0"
	replace14(instance_variable) : "替换变量" : : "这是一个替换参数。它的形式为$variable value。该实例内所有包含$variable的实体都会被替换为value内容。例如：$color 255 0 0"
	replace15(instance_variable) : "替换变量" : : "这是一个替换参数。它的形式为$variable value。该实例内所有包含$variable的实体都会被替换为value内容。例如：$color 255 0 0"
	replace16(instance_variable) : "替换变量" : : "这是一个替换参数。它的形式为$variable value。该实例内所有包含$variable的实体都会被替换为value内容。例如：$color 255 0 0"
	replace17(instance_variable) : "替换变量" : : "这是一个替换参数。它的形式为$variable value。该实例内所有包含$variable的实体都会被替换为value内容。例如：$color 255 0 0"
	replace18(instance_variable) : "替换变量" : : "这是一个替换参数。它的形式为$variable value。该实例内所有包含$variable的实体都会被替换为value内容。例如：$color 255 0 0"
	replace19(instance_variable) : "替换变量" : : "这是一个替换参数。它的形式为$variable value。该实例内所有包含$variable的实体都会被替换为value内容。例如：$color 255 0 0"
	replace20(instance_variable) : "替换变量" : : "这是一个替换参数。它的形式为$variable value。该实例内所有包含$variable的实体都会被替换为value内容。例如：$color 255 0 0"
	replace21(instance_variable) : "替换变量" : : "这是一个替换参数。它的形式为$variable value。该实例内所有包含$variable的实体都会被替换为value内容。例如：$color 255 0 0"
	replace22(instance_variable) : "替换变量" : : "这是一个替换参数。它的形式为$variable value。该实例内所有包含$variable的实体都会被替换为value内容。例如：$color 255 0 0"
	replace23(instance_variable) : "替换变量" : : "这是一个替换参数。它的形式为$variable value。该实例内所有包含$variable的实体都会被替换为value内容。例如：$color 255 0 0"
	replace24(instance_variable) : "替换变量" : : "这是一个替换参数。它的形式为$variable value。该实例内所有包含$variable的实体都会被替换为value内容。例如：$color 255 0 0"
	replace25(instance_variable) : "替换变量" : : "这是一个替换参数。它的形式为$variable value。该实例内所有包含$variable的实体都会被替换为value内容。例如：$color 255 0 0"
	replace26(instance_variable) : "替换变量" : : "这是一个替换参数。它的形式为$variable value。该实例内所有包含$variable的实体都会被替换为value内容。例如：$color 255 0 0"
	replace27(instance_variable) : "替换变量" : : "这是一个替换参数。它的形式为$variable value。该实例内所有包含$variable的实体都会被替换为value内容。例如：$color 255 0 0"
	replace28(instance_variable) : "替换变量" : : "这是一个替换参数。它的形式为$variable value。该实例内所有包含$variable的实体都会被替换为value内容。例如：$color 255 0 0"
	replace29(instance_variable) : "替换变量" : : "这是一个替换参数。它的形式为$variable value。该实例内所有包含$variable的实体都会被替换为value内容。例如：$color 255 0 0"
	replace30(instance_variable) : "替换变量" : : "这是一个替换参数。它的形式为$variable value。该实例内所有包含$variable的实体都会被替换为value内容。例如：$color 255 0 0"
	]

@PointClass base(StaticTargetName) 
    iconsprite("editor/info_lighting.vmt")
    halfgridsnap
    line(255 255 255, lightingorigin, targetname)
= info_lighting: "一个用来改变prop_static的照明原点的实体。将prop_static的照明原点设置为指向这个实体，使prop_static的照明效果就像它位于info_lighting的原点一样。适用于嵌入世界几何体中的prop_static实体（如岩石/窗户等）。"
    [
    ]

@PointClass base(Node) 
    studio("models/editor/ground_node.mdl")
    color(232 219 8)
= info_node: "用于地面移动NPC的导航节点。导航节点被烘焙进节点图，以便NPC可以移动到它们。地面节点在生成时会落到地面上。"
    [
    spawnflags(flags)  =
        [
        1: "[1] 强制人类权限" : 0
        2: "[2] 强制小型居中权限" : 0
        4: "[4] 强制宽人类权限" : 0
        8: "[8] 强制微型权限" : 0
        16: "[16] 强制宽短权限" : 0
        32: "[32] 强制中型权限" : 0
        64: "[64] 强制微型居中权限" : 0
        128: "[128] 强制大型权限" : 0
        256: "[256] 强制大型居中权限" : 0
        512: "[512] 保持编辑器位置" : 0
        ]

    ]

@PointClass base(Node) 
    studio("models/editor/air_node.mdl")
    color(232 171 8)
= info_node_air: "用于飞行NPC的导航节点。空中导航节点被烘焙进节点图，以便NPC可以移动到它们。空中节点在生成时不会落到地面。"
    [
    nodeheight(integer) : "节点高度" : 0
    ]

@PointClass base(Angles) 
    color(255 255 0)
    iconsprite("editor/light_directional.vmt")
= light_directional: "一个没有衰减的定向光源。类似于light_environment中的阳光。"
    [
    pitch(angle_negative_pitch) : "俯仰" : 0 : "光源从太阳向下的俯仰角度。0是水平的，-90是直下。"
    _light(color255) : "亮度" : "255 255 255 200"
    _lighthdr(color255) : "HDR亮度" : "-1 -1 -1 1"
    _lightscalehdr(float) : "HDR亮度缩放" : "0.7" : "编译HDR时光线缩放的量。"
    sunspreadangle(float) : "扩散角度" : 0 : "用于投射柔和阴影的光线的角度范围。数字越大越分散。5是一个起始值。"
    ]

@PointClass base(Origin, Angles, DetailPropBase) 
    studioprop()
= prop_detail: "允许手动放置基于模型的细节道具。这些通常由VBSP在设置了%detailtype的材料上生成。"
    [
    model(studio) : "模型" : : "指定使用的模型。"
    ]

@PointClass base(Origin, Angles, DetailPropBase) 
    iconsprite("editor/ficool2/prop_detail_sprite")
    wirebox(position_ul, position_lr)
= prop_detail_sprite: "允许手动放置基于精灵的细节道具。这些通常由VBSP在设置了%detailtype的材料上生成。"
    [
    position_ul(vector) : "左上角位置" : "-10 20" : "世界中精灵左上角的位置。"
    position_lr(vector) : "右下角位置" : "10 0" : "世界中精灵右下角的位置。"
    tex_ul(vector) : "精灵左上角位置" : "0 0" : "纹理中精灵左上角的位置。"
    tex_size(vector) : "精灵大小" : "64 64" : "纹理中精灵的宽度和高度。"
    tex_total_size(float) : "精灵表大小" : 512 : "精灵表纹理的宽度。\nValve Bug: 纵横比必须与默认的detail/detailsprites相匹配！"
    ]

@PointClass base(Angles) 
    color(255 255 0)
    sphere(fademindist)
    sphere(fademaxdist)
    studioprop()
= prop_static: "一个不移动也不动画的道具。"
    [
    model(studio) : "模型" : : "指定放置的模型。"
    skin(integer) : "皮肤" : 0 : "有些模型有多个版本的纹理，称为皮肤。设置这个数字为非0值，使用该皮肤而不是默认的。"
    renderamt(integer) : "透明度" : 255 : "淡入的透明度，其中0=完全透明，255=完全不透明。"
    rendercolor(color255) : "颜色 (R G B)" : "255 255 255"
    solid(choices) : "碰撞" : 6 : "此道具的碰撞方式。" =
        [
        0: "无"
        2: "包围盒"
        3: "定向包围盒"
        4: "定向包围盒，限制为仅偏航"
        6: "VPhysics"
        ]

    linedivider_light(string) readonly : "=========================================================================================================="
    disableshadows(choices) : "禁用阴影" : 0 : "防止此道具遮挡光线产生阴影。" =
        [
        0: "否"
        1: "是"
        ]

    disableflashlight(choices) : "不接收投影纹理阴影" : 0 : "防止此道具接收投影纹理阴影。" =
        [
        0: "否"
        1: "是"
        ]

    disablevertexlighting(choices) : "禁用顶点照明" : 0 : "在此道具上禁用顶点照明。" =
        [
        0: "否"
        1: "是"
        ]

    disableselfshadowing(choices) : "禁用自我阴影" : 0 : "当启用顶点照明时，防止几何体对自身产生阴影――在自身上投射阴影。" =
        [
        0: "否"
        1: "是"
        ]

    ignorenormals(choices) : "忽略表面法线" : 0 : "当启用顶点照明时，计算顶点照明时忽略面的表面法线。适用于薄的、半透明的物体，如植被道具上的叶子。" =
        [
        0: "否"
        1: "是"
        ]

drawinfastreflection(choices) : "在快速反射中渲染" : 0 : "如果启用，会导致此实体/道具在快速水面反射（即当水材料指定$reflectonlymarkedentities时）以及在世界替代者通道中渲染。" =
        [
        0: "否"
        1: "是"
        ]

    lightingorigin(target_destination) : "照明起点" : : "选择一个info_lighting来指定采样照明的位置，而不是使用此实体的起点。"
    linedivider_fade(string) readonly : "=========================================================================================================="
    screenspacefade(choices) : "屏幕空间淡出" : 0 : "决定淡出距离的方法。如果为'否'，淡出距离是从玩家视角到物体的距离，以英寸为单位。如果为'是'，淡出距离是物体在屏幕上的大小，以像素为单位。" =
        [
        0: "否"
        1: "是"
        ]

    fademindist(float) : "开始淡出距离/像素" : -1 : "道具开始淡出的距离（<0 = 使用fademaxdist）。如果选择了'屏幕空间淡出'，这代表道具开始淡出时覆盖的像素宽度。"
    fademaxdist(float) : "结束淡出距离/像素" : 0 : "道具可见的最大距离（0 = 不淡出）。如果选择了'屏幕空间淡出'，这代表道具淡出时覆盖的*最小*像素宽度。"
    fadescale(float) : "淡出比例" : 1 : "如果你在worldspawn中指定了淡出，或者如果引擎在dx7 [hl2/ep1/portal] 或dx8 [ep2/tf] 下运行，那么引擎将强制淡出道具，即使没有指定fademindist/fademaxdist。这个比例因子给了你一些对淡出的控制。这里使用0将关闭强制淡出。小于1的数字会导致道具在更远的距离淡出，大于1的数字会导致它在更近的距离淡出。"
    ]

@BaseClass base(BaseEntityPoint, RenderFields, Reflection) = BaseBeam: "这是'beam'类的定义，但我们不希望它出现在实体列表中。"
    [
    rendermode(choices) readonly : "渲染模式" : 1 : "渲染模式被强制设置为纹理，但在Hammer中设置为颜色以确保正确渲染。" =
        [
        1: "颜色"
        ]

    renderamt(integer) : "亮度 (1 - 255)" : 100
    rendercolor(color255) : "光束颜色 (R G B)" : "255 255 255"
    hdrcolorscale(float) : "HDR颜色比例。" : "1.0" : "在HDR模式下运行时用于乘以精灵颜色的浮点值。"
    noiseamplitude(float) : "噪声量 (0-64)" : 0 : "光束中的噪声量。0是完全直线的光束。"
    framerate(integer) : "每10秒帧数" : 0 : "光束纹理应该以多快的帧率动画化，如果它有多帧。"
    framestart(integer) : "起始帧" : 0 : "开始光束纹理的帧。"
    texture(sprite) : "精灵名称" : "sprites/laserbeam.vmt" : "用于绘制光束的材质。"
    texturescroll(integer) : "纹理滚动速率 (0-100)" : 35 : "光束纹理沿光束滚动的速率。"
    damage(string) : "每秒伤害" : 0 : "这个光束在激活时每秒对事物造成的伤害。对于持续伤害，值应该大于10，否则可能不起作用。"
    dissolvetype(choices) : "溶解类型" : -1 =
        [
        -1: "无"
        0: "能量"
        1: "重电"
        2: "轻电"
        ]


    // 输入
    input TurnOn(void) : "打开光束。"
    input TurnOff(void) : "关闭光束。"
    input Toggle(void) : "切换光束的开关状态。"
    input Width(float) : "设置光束的宽度，以像素为单位。"
    input ScrollSpeed(float) : "设置每秒滚动速度的单位（0 - 100）。"
    input Alpha(integer) : "设置光束的透明度（0 - 255）。"
    input Color(color255) : "设置光束的渲染颜色（R G B）。"
    input ColorRedValue(float) : "设置红色通道的值（0 - 255）。"
    input ColorGreenValue(float) : "设置绿色通道的值（0 - 255）。"
    input ColorBlueValue(float) : "设置蓝色通道的值（0 - 255）。"
    ]

@BaseClass base(BaseEntityPoint, RenderFields, Reflection, DamageFilter) = BaseEntityAnimating
    [
    solid(choices) : "碰撞" : 6 : "此实体的碰撞方法。可以在运行时通过AddOutput更改。" =
        [
        0: "无"
        1: "BSP (QPhysics)"
        2: "边界框"
        3: "定向边界框"
        4: "定向边界框，仅限偏航"
        5: "自定义（每个实体定义，如果未定义，实体将有奇怪的碰撞行为）"
        6: "VPhysics"
        ]

    body(integer) : "身体组" : 0 : "身体组允许打开和关闭模型的部分，因此可以动态显示或隐藏部分。"
    modelscale(float) : "模型比例" : : "模型大小的乘数。负值是被接受的。但在大多数情况下，这不会改变物理碰撞。负值可能会导致游戏崩溃！"
    linedivider_animbase(string) readonly : "=========================================================================================================="
    lightingorigin(target_destination) : "照明起点" : : "选择任何实体（不是info_lighting！）来代替实体的起点采样照明。"
    lightingoriginhack(target_destination) : "照明起点偏移" : : "采样照明的info_lighting_relative代替实体的起点。"
    fademindist(float) : "开始淡出距离/像素" : : "实体开始淡出的距离。如果<0，当结束淡出时实体将立即消失。如果实体在3D天空盒中，值将适当缩放。"
    fademaxdist(float) : "结束淡出距离/像素" : : "实体结束淡出的距离。如果<0，实体根本不会消失。如果实体在3D天空盒中，值将适当缩放。"
    fadescale(float) : "淡出比例" : : "如果在worldspawn中指定，或者如果引擎在DirectX 8以下运行，即使没有指定上述淡出距离，实体也会淡出。这个值提供了更多控制：小于1的数字会导致实体在更远的距离淡出，大于1的数字会导致它在更近的距离淡出。使用0关闭强制淡出。"
    disableshadows(choices) : "禁止产生廉价阴影？" : 0 : "阻止实体创建廉价的实时纹理/动态阴影。" =
        [
        0: "否"
        1: "是"
        ]

    disablereceiveshadows(choices) : "禁止接收阴影？" : 0 : "阻止阴影（廉价和投影纹理）出现在此实体上。" =
        [
        0: "否"
        1: "是"
        ]

    disableshadowdepth(choices) : "不影响投影纹理" : 0 : "阻止此实体影响投影纹理阴影。" =
        [
        0: "否"
        1: "是"
        ]

    disableflashlight(choices) : "不接收投影纹理" : 0 : "用于禁用手电筒（env_projectedtexture）照明和阴影在此实体上。" =
        [
        0: "否"
        1: "是"
        ]

    linedivider_anim(string) readonly : "=========================================================================================================="

    // 输入
    input Skin(integer) : "更改模型皮肤为指定编号。"
    input SetBodyGroup(integer) : "将模型的身体组更改为指定的索引编号。"
    input Ignite(void) : "使实体无限期着火。"
    input IgniteLifetime(float) : "使实体着火一定时间。"
    input IgniteNumHitboxFires(integer) : "使实体着火并有给定数量的击中箱火焰粒子。"
    input IgniteHitboxFireScale(float) : "使实体着火并有给定规模的击中箱火焰粒子。"
    input BecomeRagdoll(void) : "杀死实体并从模型创建一个客户端布娃娃，没有任何力量（只是瘫软）。只有当模型包含布娃娃时才会传递输入，对于其他模型可以使用phys_convert代替。OnDeath、OnHalfHealth等输出将**不会**触发。"
    input SetLightingOrigin(string) : "设置用作实体照明起点的实体。可以使用任何实体。"
    input SetLightingOriginHack(string) : "通过info_lighting_relative的距离偏移实体的照明起点。"
    input fademindist(float) : "设置实体开始淡出的距离。如果<0，当结束淡出时实体将立即消失。如果实体在3D天空盒中，值将适当缩放。"
    input fademaxdist(float) : "设置实体结束淡出的距离。如果<0，实体根本不会消失。如果实体在3D天空盒中，值将适当缩放。"
    input DisableShadow(void) : "允许实体绘制实时目标（动态）阴影。"
    input EnableShadow(void) : "阻止实体绘制实时目标（动态）阴影。"
    input DisableReceivingFlashlight(void) : "此物体将不会接收投影纹理（手电筒）的光线或阴影。"
    input EnableReceivingFlashlight(void) : "此物体可以接收投影纹理（手电筒）的光线或阴影。"
    input AlternativeSorting(bool) : "用于尝试解决渲染时的排序问题。真为激活，假为停用"

    // 输出
    output OnIgnite(void) : "当此物体着火时触发。"
    ]

@BaseClass base(BaseEntityPoint, RenderFields, Reflection, DamageFilter) = BaseEntityPhysics
    [
    solid(choices) : "碰撞" : 6 : "此实体的碰撞方法。可以在运行时通过AddOutput更改。" =
        [
        0: "无"
        2: "边界框"
        3: "定向边界框"
        4: "定向边界框，仅限偏航"
        6: "VPhysics"
        ]

    body(integer) : "身体组" : 0 : "设置模型的身体组索引，从0开始（如果可用）。"
    texframeindex(integer) : "纹理帧" : : "此实体上任何动画纹理的帧号。"
    lightingorigin(target_destination) : "照明起点" : : "选择任何实体（不是info_lighting！）来代替实体的起点采样照明。"
    lightingoriginhack(target_destination) : "照明起点偏移" : : "采样照明的info_lighting_relative代替实体的起点。"
    fademindist(float) : "开始淡出距离/像素" : : "实体开始淡出的距离。如果<0，当结束淡出时实体将立即消失。如果实体在3D天空盒中，值将适当缩放。"
    fademaxdist(float) : "结束淡出距离/像素" : : "实体结束淡出的距离。如果<0，实体根本不会消失。如果实体在3D天空盒中，值将适当缩放。"
    fadescale(float) : "淡出比例" : : "如果在worldspawn中指定，或者如果引擎在DirectX 8以下运行，即使没有指定上述淡出距离，实体也会淡出。这个值提供了更多控制：小于1的数字会导致实体在更远的距离淡出，大于1的数字会导致它在更近的距离淡出。使用0关闭强制淡出。"
    shadowcastdist(integer) : "阴影投射距离" : : "设置实体投射动态阴影的距离，单位为单位。0表示从shadow_control实体的默认距离。"
    disableshadows(choices) : "禁用阴影？" : 0 : "阻止实体创建廉价的实时纹理/动态阴影。" =
        [
        0: "否"
        1: "是"
        ]

    disablereceiveshadows(choices) : "禁止接收阴影？" : 0 : "阻止动态阴影（例如玩家和道具阴影）出现在这个实体上。" =
        [
        0: "否"
        1: "是"
        ]

    modelscale(float) : "模型比例" : : "模型大小的乘数。负值是被接受的。但在大多数情况下，这不会改变物理碰撞。负值可能会导致游戏崩溃！"
    linedivider_phys(string) readonly : "=========================================================================================================="

    // 输入
    input Skin(integer) : "更改模型皮肤为指定编号。"
    input SetBodyGroup(integer) : "将模型的身体组更改为指定的索引编号。"
    input Ignite(void) : "使实体无限期着火。"
    input IgniteLifetime(float) : "使实体着火一定时间。"
    input IgniteNumHitboxFires(integer) : "使实体着火并有给定数量的击中箱火焰粒子。"
    input IgniteHitboxFireScale(float) : "使实体着火并有给定规模的击中箱火焰粒子。"
    input BecomeRagdoll(void) : "杀死实体并从模型创建一个客户端布娃娃。只有当模型包含布娃娃时才会传递输入，对于其他模型可以使用phys_convert代替。"
    input SetLightingOrigin(string) : "设置用作实体照明起点的实体。可以使用任何实体。"
    input SetLightingOriginHack(string) : "通过info_lighting_relative的距离偏移实体的照明起点。"
    input fademindist(float) : "设置实体开始淡出的距离。如果<0，当结束淡出时实体将立即消失。如果实体在3D天空盒中，值将适当缩放。"
    input fademaxdist(float) : "设置实体结束淡出的距离。如果<0，实体根本不会消失。如果实体在3D天空盒中，值将适当缩放。"
    input DisableShadow(void) : "允许实体绘制实时目标（动态）阴影。"
    input EnableShadow(void) : "阻止实体绘制实时目标（动态）阴影。"
    input AlternativeSorting(bool) : "用于尝试解决渲染时的排序问题。真为激活，假为停用"

    // 输出
    output OnIgnite(void) : "当此物体着火时触发。"
    ]

@BaseClass base(BaseEntityBrush, RenderFields, Reflection) = BaseEntityVisBrush
    [
    vrad_brush_cast_shadows(choices) : "VRAD阴影" : 0 : "决定此实体是否会投射光照贴图阴影。" =
        [
        0: "不投射阴影"
        1: "投射阴影"
        ]

    _minlight(float) : "最小光照级别" : 0 : "打到这个刷子上的最小环境光级别。"
    disablereceiveshadows(choices) : "禁止接收阴影？" : 0 : "阻止动态阴影（例如玩家和道具阴影）出现在这个实体上。" =
        [
        0: "否"
        1: "是"
        ]

    disableshadowdepth(choices) : "禁用ShadowDepth" : 0 : "用于禁用此实体渲染进入阴影深度（用于手电筒）。" =
        [
        0: "否"
        1: "是"
        ]

    disableflashlight(choices) : "禁用手电筒" : 0 : "用于禁用手电筒（env_projectedtexture）照明和阴影在此实体上。" =
        [
        0: "否"
        1: "是"
        ]

    linedivider_visbrush(string) readonly : "=========================================================================================================="

    // 输入
    input DisableShadow(void) : "允许实体绘制实时目标（动态）阴影。"
    input EnableShadow(void) : "阻止实体绘制实时目标（动态）阴影。"
    input DisableReceivingFlashlight(void) : "此物体将不会接收投影纹理（手电筒）的光线或阴影。"
    input EnableReceivingFlashlight(void) : "此物体可以接收投影纹理（手电筒）的光线或阴影。"
    input EnableDamageForces(void) : "对实体造成伤害会对其施加物理力。"
    input DisableDamageForces(void) : "对实体造成伤害不会对其施加物理力。"
    input AlternativeSorting(bool) : "用于尝试解决渲染时的排序问题。真为激活，假为停用"
    ]

@BaseClass base(BaseEntityPoint, EnableDisable) = BaseNPCMaker
    [
    startdisabled(choices) : "开始时禁用" : 1 =
        [
        0: "否"
        1: "是"
        ]

    spawnflags(flags)  =
        [
        16: "[16] 淡出尸体" : 0
        32: "[32] 无限孩子" : 0
        64: "[64] 不掉落" : 0
        128: "[128] 可见时不生成" : 0
        ]

    maxnpccount(integer) : "NPC数量" : 1 : "此生成器耗尽前会生成的NPC数量。"
    spawnfrequency(string) : "频率" : 5 : "新NPC生成的频率（以秒为单位）。如果设置为-1，当最后一个NPC死亡时将制造一个新的NPC。"
    maxlivechildren(integer) : "最大存活NPC" : 5 : "任何时候允许的最大存活孩子数量（新的不会生成，直到一个死亡）。如果设置为-1，则不应用限制。"
    ignoreentity(target_destination) : "忽略实体" : : "如果设置，检查是否有空间生成时忽略的实体。"

    // 输入
    input Spawn(void) : "生成一个NPC。"
    input Toggle(void) : "切换生成器的启用/禁用状态。"
    input Enable(void) : "启用生成器。"
    input Disable(void) : "禁用生成器。"
    input AddMaxChildren(integer) : "增加生成器耗尽前可以生成的NPC数量。如果一个耗尽的生成器被给予了一些孩子来生成，它仍然不会开始生成，直到它通过Enable输入被重新启用。"
    input SetMaxChildren(integer) : "设置生成器耗尽前可以生成的NPC数量。如果一个耗尽的生成器被给予了一些孩子来生成，它仍然不会开始生成，直到它通过Enable输入被重新启用。"
    input SetMaxLiveChildren(integer) : "设置此生成器可以同时存活的最大NPC数量。"
    input SetSpawnFrequency(float) : "设置新NPC生成的频率（以秒为单位）。"

    // 输出
    output OnSpawnNPC(target_destination) : "当生成一个NPC时触发。激活者是NPC，参数是指向NPC的指针。"
    output OnAllSpawned(void) : "当生成器耗尽时触发（所有孩子都已生成）。"
    output OnAllSpawnedDead(void) : "当生成器耗尽（所有孩子都已生成）并且所有生成的孩子都已死亡时触发。"
    output OnAllLiveChildrenDead(void) : "当所有生成的孩子都死亡时触发。这并不意味着生成器已耗尽，所以在此之后任何时候都可能生成一个新的孩子（除非生成器被禁用）。"
    ]

@BaseClass base(BaseEntityBrush) = BaseTank
    [
    spawnflags(flags)  =
        [
        1: "[1] 激活" : 0
        16: "[16] 仅直接" : 0
        32: "[32] 可控制" : 0
        64: "[64] 伤害踢" : 0
        1024: "[1024] NPC可控制" : 0
        2048: "[2048] NPC设置控制器" : 0
        4096: "[4096] 允许友军打击玩家" : 0
        32768: "[32768] 非实体" : 0
        131072: "[131072] 对玩家每3次射击中有一次精准" : 0
        ]

    control_volume(target_destination) : "控制体积" : : "指定玩家必须在其中才能控制此坦克的触发器名称。"
    master(string) : "(队伍) 主控"
    yawrate(string) : "偏航速率" : 30
    yawrange(string) : "偏航范围" : 180
    yawtolerance(string) : "偏航容忍度" : 15
    pitchrate(string) : "俯仰速率" : 0
    pitchrange(string) : "俯仰范围" : 0
    pitchtolerance(string) : "俯仰容忍度" : 5
    barrel(string) : "炮管长度" : 0
    barrely(string) : "炮管水平" : 0
    barrelz(string) : "炮管垂直" : 0
    spritesmoke(sprite) : "烟雾精灵" : : "用于炮口烟雾效果的特定精灵。"
    spriteflash(sprite) : "闪光精灵" : : "用于炮口闪光效果的特定精灵。"
    spritescale(string) : "精灵比例" : 1 : "烟雾和闪光精灵的比例。"
    rotatestartsound(sound) : "旋转开始声音"
    rotatesound(sound) : "旋转循环声音"
    rotatestopsound(sound) : "旋转停止声音"
    firerate(string) : "射击频率" : 1
    bullet_damage(string) : "每颗子弹的伤害" : 0 : "如果设置为0，将使用基础武器子弹的伤害。"
    bullet_damage_vs_player(string) : "每颗子弹对玩家的伤害" : 0 : "如果设置为0，将使用每颗子弹的伤害值。"
    persistence(string) : "射击持续性" : 1 : "(秒) 在失去目标视线后继续射击的时间"
    persistence2(string) : "射击持续性2" : 0 : "(秒) 在失去敌人并且持续性时间过后，偶尔向敌人最后已知位置射击的时间"
    firespread(choices) : "子弹精度" : 0 =
        [
        0: "完美射击"
        1: "小圆锥"
        2: "中圆锥"
        3: "大圆锥"
        4: "超大圆锥"
        ]

    minrange(string) : "最小目标范围" : 0
    maxrange(string) : "最大目标范围" : 0
    gun_base_attach(string) : "枪支基座附件" : : "如果指定了父对象，则这是父对象上用于瞄准的附件点。"
    gun_barrel_attach(string) : "枪支炮管附件" : : "如果指定了父对象，则这是父对象上用于射击的附件点。如果您指定了这个，您会想要同时指定枪支基座附件。"
    gun_yaw_pose_param(string) : "枪支偏航姿态参数" : : "如果指定了父对象+枪支俯仰姿态参数，则枪支本身将不可见，func_tank将使用姿态参数在父对象上操纵枪支。"
    gun_yaw_pose_center(float) : "枪支偏航姿态中心" : 0 : "父对象上枪支的中心偏航姿态参数"
    gun_pitch_pose_param(string) : "枪支俯仰姿态参数" : : "如果指定了父对象+枪支偏航姿态参数，则枪支本身将不可见，func_tank将使用姿态参数在父对象上操纵枪支。"
    gun_pitch_pose_center(float) : "枪支俯仰姿态中心" : 0 : "父对象上枪支的中心俯仰姿态参数"
    ammo_count(integer) : "弹药数量" : -1 : "仅适用于玩家使用。-1 = 无限弹药。"
    leadtarget(choices) : "预瞄目标" : 0 =
        [
        0: "否"
        1: "是"
        ]

    npc_man_point(target_destination) : "NPC操作点" : : "NPC必须站立以操作此func_tank的点。"
    playergraceperiod(float) : "NPC攻击后宽限期" : 0 : "如果指定，操纵此func_tank的NPC在攻击非玩家目标后，不会在这段时间内向玩家开火。"
    ignoregraceupto(float) : "忽略宽限期直到" : 768 : "如果玩家距离func_tank在这个距离以下，将忽略玩家宽限期。"
    playerlocktimebeforefire(float) : "玩家锁定时间" : 0 : "坦克在允许射击前必须将玩家作为目标的时间。"
    shouldfindnpcs(choices) : "自动寻找NPC" : 1 : "如果可以由NPC控制，设置我们是否应该自动寻找使用此func_tank的NPC，还是仅等待玩家设置。与StartFindingNPCs和StopFindingNPCs相同。" =
        [
        0: "否"
        1: "是"
        ]

    effecthandling(choices) : "效果处理" : 0 : "特殊效果处理，影响声音和枪口效果。单独设置可以覆盖部分内容。" =
        [
        0: "使用单独设置。"
        1: "AR2"
        2: "联合火炮"
        ]


    // 输入
    input Activate(void) : "打开坦克"
    input Deactivate(void) : "关闭坦克（进入休眠状态）"
    input SetFireRate(string) : "设置射击速度（0 = 不射击）"
    input SetDamage(string) : "设置每颗子弹的伤害"
    input SetTargetPosition(string) : "我应该瞄准的世界位置"
    input SetTargetDir(vector) : "瞄准的方向。"
    input SetTargetEntityName(target_destination) : "我应该追踪/攻击的实体名称"
    input SetTargetEntity(string) : "设置我应该追踪/攻击的实体到传入的实体。"
    input ClearTargetEntity(void) : "清除我应该攻击的实体。"
    input FindNPCToManTank(string) : "找到附近的NPC来操作此func_tank。"
    input StartFindingNPCs(void) : "开始寻找操作此func_tank的NPC。"
    input StopFindingNPCs(void) : "停止寻找操作此func_tank的NPC。"
    input ForceNPCOff(void) : "强制操作此func_tank的NPC（如果有的话）离开。"
    input SetMaxRange(float) : "设置func_tank的最大范围。"

    // 输出
    output OnFire(void) : "坦克射击时触发"
    output OnAquireTarget(void) : "当目标新进入射程且可以被射击时触发"
    output OnLoseTarget(void) : "当目标超出射程时触发"
    output OnAmmoDepleted(void) : "当坦克用尽弹药时触发"
    output OnGotController(void) : "当NPC开始控制此坦克时触发。玩家不会触发此输入。"
    output OnLostController(void) : "当NPC控制器停止控制坦克时触发。玩家不会触发此输入。"
    output OnGotPlayerController(void) : "当玩家开始控制此坦克时触发。NPC不会触发此输入。"
    output OnLostPlayerController(void) : "当玩家控制器停止控制坦克时触发。NPC不会触发此输入。"
    output OnReadyToFire(void) : "当坦克准备好在回合间射击时触发"
    ]

@BaseClass base(BaseEntityPoint) = CombineBallSpawners
    [
    spawnflags(flags)  =
        [
        4096: "[4096] 开始时不活跃" : 1
        8192: "[8192] 联合电源供应" : 0
        ]

    ballcount(integer) : "球数" : 3 : "这是在发射器内部弹跳的球数"
    minspeed(float) : "球的最小速度" : "300.0" : "在发射器中飞行的球的最小速度"
    maxspeed(float) : "球的最大速度" : "600.0" : "在发射器中飞行的球的最大速度"
    ballradius(float) : "球的半径" : "12.0" : "精灵和碰撞的大小。这被限制在1-12单位内。"
    ballrespawntime(float) : "球的重生时间" : "4.0" : "能量球的重生时间"

    // 输入
    input Enable(void) : "启用合并球的生成"
    input Disable(void) : "禁用合并球的生成"

    // 输出
    output OnBallGrabbed(void) : "当合并球被巨型物理炮从场地中抓取时触发"
    output OnBallReinserted(void) : "当合并球被重新插入场地时触发（仅在勾选了联合电源供应时触发）"
    output OnBallHitTopSide(void) : "当合并球在场地中击中顶部时触发（仅在勾选了联合电源供应时触发）"
    output OnBallHitBottomSide(void) : "当合并球在场地中击中底部时触发（仅在勾选了联合电源供应时触发）"
    output OnLastBallGrabbed(void) : "当场地中的最后一个合并球被巨型物理炮抓取时触发"
    output OnFirstBallReinserted(void) : "当场地中的第一个合并球被重新插入时触发（仅在勾选了联合电源供应时触发）"
    ]

@BaseClass base(BaseEntityPoint) = ForceController
    [
    spawnflags(flags)  =
        [
        1: "[1] 开始时打开" : 0
        2: "[2] 应用力" : 1
        4: "[4] 应用扭矩" : 1
        8: "[8] 本地定位" : 1
        16: "[16] 忽略质量" : 0
        ]

    attach1(target_destination) : "附加对象" : : "要对其施加力的对象。"
    forcetime(float) : "力的持续时间（0=无限）" : 0 : "此时间过后自动关闭（0 = 永远开启或直到被停用）"

    // 输入
    input Activate(void) : "打开力"
    input Deactivate(void) : "关闭力"
    input Scale(string) : "设置力的比例"
    ]

@BaseClass base(BaseEntityBrush, TeamNum) = NavCost
    [
    start_disabled(choices) : "开始时禁用" : 0 =
        [
        0: "否"
        1: "是"
        ]


    // 输入
    input Enable(void) : "启用"
    input Disable(void) : "禁用"
    input Toggle(void) : "切换"
    ]

@BaseClass base(BaseEntityBrush) = TriggerOnce
    [
    spawnflags(flags)  =
        [
        1: "[1] 客户端（玩家）" : 1
        2: "[2] NPC" : 0
        4: "[4] func_pushable" : 0
        8: "[8] VPhysics 对象" : 0
        16: "[16] 仅玩家盟友NPC" : 0
        32: "[32] 仅在载具中的客户端" : 0
        64: "[64] 一切（不包括物理碎片）" : 0
        512: "[512] 仅不在载具中的客户端" : 0
        1024: "[1024] 物理碎片" : 0
        2048: "[2048] 仅在载具中的NPC（尊重玩家盟友标记）" : 0
        ]

    startdisabled(choices) : "开始时禁用？" : 0 =
        [
        0: "否"
        1: "是"
        ]

    filtername(filterclass) : "过滤器名称" : : "用于测试潜在激活者的过滤器实体。"

    // 输入
    input Enable(void) : "启用此触发器。"
    input Disable(void) : "禁用此触发器，某些触发器实体可能在被禁用时也会触发OnEndTouch。"
    input Toggle(void) : "切换此触发器的启用和禁用状态。"
    input TouchTest(void) : "触发OnTouching或OnNotTouching输出，取决于是否有东西触碰此实体。"
	input StartTouch(void) : "触发OnStartTouch输出。如果由触发器内部的实体调用，OnStartTouch也会将它们作为激活者触发。请注意，即使玩家在触发器内部被视为'未'触摸触发器时，这个输入也会被传递。"

    // 输出
    output OnTrigger(void) : "每当触发器被激活时触发。"
    output OnStartTouch(void) : "当实体开始触摸此触发器时触发。触摸实体必须通过此触发器的过滤器才能触发此输出。"
    output OnTouching(void) : "当调用TouchTest输入且有实体正在触摸此触发器时触发。不调用激活器。"
    output OnNotTouching(void) : "当调用TouchTest输入且没有实体正在触摸此触发器时触发。不调用激活器。"
    ]

@BaseClass base(BaseEntityPoint) = TwoObjectPhysics
    [
    spawnflags(flags)  =
        [
        1: "[1] 破坏前无碰撞" : 0
        4: "[4] 初始时不活动" : 0
        8: "[8] 改变质量以保持稳定附着在世界上" : 0
        16: "[16] 在打开前不连接实体" : 0
        ]

    attach1(target_destination) : "实体1（黄色）" : : "要约束的第一个实体。如果为空，则将第二个实体约束到世界上。"
    attach2(target_destination) : "实体2（蓝色）" : : "要约束的第二个实体。如果为空，则将第一个实体约束到世界上。"
    constraintsystem(target_destination) : "约束系统管理器" : : "此约束应成为其一部分的phys_constraintsystem的名称。一组实体上的所有约束应放在同一个系统中，否则它们将在模拟过程中相互作用。"
    forcelimit(float) : "破坏力限制（磅）" : 0 : "冲击必须对约束施加多少力才能破坏它。计算这个的一种方法是将它设置为如果一个物体静止在约束的物体上就会破坏这个约束的物体质量。"
    torquelimit(float) : "扭矩限制以破坏（磅*距离）" : 0 : "破坏约束所需的扭矩量。计算这个的一种方法是将任何参考质量乘以破坏约束所需的静止距离（从物体的质心）。"
    breaksound(sound) : "破坏时播放声音" : : "当约束被破坏时播放的声音。"
    teleportfollowdistance(float) : "跟随传送距离" : 0 : "如果一个物体传送超过这么多单位，它将导致另一个约束物体传送到一个适当的相对位置。"

    // 输入
    input Break(void) : "强制约束破裂。"
    input TurnOn(void) : "启用约束。当对象在约束产生时不存在，或者当您已经停用约束时，执行此操作。破碎的约束不能被打开。它们已被删除。"
    input TurnOff(void) : "禁用此约束。"

    // 输出
    output OnBreak(void) : "当约束破裂时触发。"
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/ambient_generic.vmt")
    sphere(radius)
    line(255 255 0, targetname, sourceEntityName)
= ambient_generic: "通用环境声音。用它来播放和控制单个声音。"
    [
    spawnflags(flags)  =
        [
        1: "[1] 无限范围" : 0
        16: "[16] 初始时静音" : 1
        32: "[32] 不是循环的" : 1
        ]

    message(sound) : "声音名称" : : "要播放的GameSound条目的名称。也支持直接的.wav文件名。"
    health(integer) : "音量" : 10 : "声音音量，表示为从0到10的范围，其中10是最大声。"
    radius(float) : "声音范围" : 1250 : "此声音可听到的最大距离。由soundscripts覆盖。"
    pitch(integer) : "音调" : 100 : "声音音调，表示为从1（低）到255（高）的范围，其中100是声音的默认音调。由soundscripts覆盖。"
    sourceentityname(target_destination) : "来源实体" : : "如果指定了实体，则声音将来自这个命名实体，而不是ambient_generic的位置。"
    preset(choices) : "动态预设" : 0 : "如果使用，将许多以下属性（+音调）覆盖为预设值。" =
        [
        0: "无"
        1: "巨型机器"
        2: "大型机器"
        3: "机器"
        4: "慢速淡入"
        5: "淡入"
        6: "快速淡入"
        7: "慢速脉冲"
        8: "脉冲"
        9: "快速脉冲"
        10: "慢速振荡器"
        11: "振荡器"
        12: "快速振荡器"
        13: "嘈杂音调"
        14: "非常低的音调"
        15: "低音调"
        16: "高音调"
        17: "非常高的音调"
        18: "尖叫音调"
        19: "旋转启动/关闭振荡"
        20: "脉冲启动/关闭"
        21: "随机音调"
        22: "快速随机音调"
        23: "递增启动"
        24: "外星"
        25: "奇异"
        26: "X行星"
        27: "闹鬼"
        ]

    linedivider_snd(string) : "=======================" : : "下面是更复杂的值。"
    volstart(integer) : "过渡音量" : 0 : "开始/结束时的音量。与淡入和淡出时间一起使用。"
    fadeinsecs(integer) : "音量过渡时间 - 开始（0-100）" : 0 : "声音从过渡音量过渡到设置音量所需的时间，当它开始播放时。"
    fadeoutsecs(integer) : "音量过渡时间 - 停止（0-100）" : 0 : "声音从设置音量过渡到过渡音量所需的时间，当它停止播放时。"
    pitchstart(integer) : "过渡音调" : 100 : "开始/结束时的音调。与加速和减速一起使用。"
    spinup(integer) : "音调过渡时间 - 开始（0-100）" : 0 : "声音开始播放时，从过渡音调变为最终音调所需的时间。模拟对象激活时产生的噪音逐渐增强。"
    spindown(integer) : "音调过渡时间 - 停止（0-100）" : 0 : "声音停止播放时，从音调过渡到过渡音调所需的时间。模拟对象关闭时噪音逐渐减弱。"
    lfotype(choices) : "LFO类型" : 0 : "应用于声音的低频振荡类型。允许对声音进行微妙的修改。方波在高低值之间即时切换，而三角波在两者之间逐渐切换。" =
        [
        0: "无"
        1: "方波"
        2: "三角波"
        3: "随机"
        ]

    lforate(integer) : "LFO速率（0-1000）" : 0 : "低频振荡重复自身的频率。"
    lfomodpitch(integer) : "LFO对音调的影响（0-100）" : 0 : "低频振荡对音调的影响量。"
    lfomodvol(integer) : "LFO对音量的影响（0-100）" : 0 : "低频振荡对音量的影响量。"
    cspinup(integer) : "递增启动次数" : 0 : "似乎没有功能。"

    // 输入
    input Pitch(integer) : "设置声音音调，表示为从1到255的范围，其中100是声音的默认音调。"
    input PlaySound(void) : "开始声音或从头开始重新播放（如果循环）。"
    input StopSound(void) : "如果声音正在播放，则停止声音。只有在选中循环标志时才能正常工作。"
    input ToggleSound(void) : "在播放和停止之间切换声音。"
    input Volume(integer) : "设置声音音量，表示为从0到10的范围，其中10是最大声。"
    input FadeIn(integer) : "在指定的秒数内将声音淡入到全音量，范围从0到100秒。"
    input FadeOut(integer) : "在指定的秒数内将声音淡出为静音，范围从0到100秒。首先将声音强制到全音量！"
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/ambient_generic.vmt")
    sphere(radius)
= ambient_music: "播放求生之路特定音乐。"
    [
    message(sound) : "声音名称" : : "要播放的GameSound条目的名称。"

    // 输入
    input PlaySound(void) : "开始声音。"
    input StopSound(void) : "如果声音正在播放，则停止声音。"
    ]

@PointClass base(BaseEntityPoint, Angles) 
    studio("models/editor/cone_helper.mdl")
    sphere(spotlightlength)
    sphere(spotlightwidth)
= beam_spotlight: "一种绘制聚光灯的实体。当玩家从侧面看时，它将绘制一束光束，当它面向玩家时，它将绘制一个光晕。除非选中了“无动态光”生成标志，否则它还将在聚光灯末端所在的位置创建一个动态光。这个聚光灯完全是客户端的，它不会在客户端之间同步。"
    [
    spawnflags(flags)  =
        [
        1: "[1] 开始时打开" : 1
        2: "[2] 无动态光" : 0
        4: "[4] 开始旋转" : 0
        8: "[8] 反方向" : 0
        16: "[16] X轴" : 0
        32: "[32] Y轴" : 0
        ]

    maxspeed(integer) : "最大旋转速度" : 100 : "聚光灯的最大旋转速度，以每秒度数计。"
    spotlightlength(integer) : "聚光灯长度" : 500 : "聚光灯光束的长度。"
    spotlightwidth(integer) : "聚光灯宽度" : 50 : "聚光灯光束的宽度。"
    rendercolor(color255) : "颜色（R G B）" : "255 255 255"
    hdrcolorscale(float) : "HDR颜色比例。" : "0.7" : "在HDR模式下运行时乘以精灵颜色的浮点值。"

    // 输入
    input LightOn(void) : "打开聚光灯。"
    input LightOff(void) : "关闭聚光灯"
    input Start(void) : "开始旋转器旋转。"
    input Stop(void) : "停止旋转器旋转。"
    input Reverse(void) : "反转旋转器的旋转方向。"

    // 输出
    output OnLightOn(void) : "当灯光打开时触发。"
    output OnLightOff(void) : "当灯光关闭时触发。"
    ]

@PointClass base(BaseEntityPoint, EnableDisable) 
    sphere(minfalloff)
    sphere(maxfalloff)
    iconsprite("editor/color_correction.vmt")
= color_correction: "一个控制地图中颜色校正的实体。"
    [
    minfalloff(float) : "查找衰减开始距离" : "0.0" : "这是衰减区域开始的距离（-1 = 任何地方）"
    maxfalloff(float) : "查找衰减结束距离" : "200.0" : "这是衰减区域结束的距离（-1 = 任何地方）"
    maxweight(float) : "最大权重" : "1.0" : "这是此查找的最大权重"
    filename(string) : "查找表文件名" : : "这是查找表的文件名"
    fadeinduration(float) : "查找淡入持续时间" : "0.0" : "启用时查找淡入的持续时间。"
    fadeoutduration(float) : "查找淡出持续时间" : "0.0" : "禁用时查找淡出的持续时间。"
    spawnflags(flags)  =
        [
        1: "[1] 主" : 0
        2: "[2] 客户端模拟" : 0
        ]

    exclusive(choices) : "排他性" : 0 : "一个排他性的color_correction实体在启用时会禁用并淡出所有其他颜色校正。任何时候都应该只有一个活跃的排他性color_correction实体。" =
        [
        0: "否"
        1: "是"
        ]


    // 输入
    input SetFadeInDuration(float) : "设置'fadeInDuration'变量，用于在实体启用时淡入cc查找使用。"
    input SetFadeOutDuration(float) : "设置'fadeOutDuration'变量，用于在实体禁用时淡出cc查找使用。"
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/ficool2/commentary_auto.vmt")
    color(0 100 250)
= commentary_auto: "特定于解说的logic_auto版本。"
    [

    // 输入
    input MultiplayerSpawned(void) : "内部输入，触发OnCommentaryMultiplayerSpawn。"

    // 输出
    output OnCommentaryNewGame(void) : "在启用解说的情况下开始新游戏时触发。"
    output OnCommentaryMidGame(void) : "在地图中途启用解说时触发。"
    output OnCommentaryMultiplayerSpawn(void) : "当玩家在多人游戏中重生时触发。"
    ]

@PointClass base(BaseEntityPoint) 
    studio("models/infected/smoker.mdl")
= commentary_zombie_spawner: "僵尸手动生成点"
    [

    // 输入
    input SpawnZombie(string) : "现在生成特定的僵尸。字符串格式是僵尸类型后跟可选的目标名称（例如'smoker,BostonJoe'或'common_male_suit'）。僵尸类型：boomer, common_*, hunter, smoker, tank, witch"

    // 输出
    output OnSpawnedZombieDeath(void) : "由此实体生成的僵尸之一已死亡"
    ]

@PointClass base(BaseEntityPoint) 
	iconsprite("editor/comp_choreo_sceneset.vmt")
= comp_choreo_sceneset: "Chains a set of choreographed scenes together."
	[
	delay(float) : "Delay between each" : "0.1" : "Add a delay between each scene."
	only_once(choices) : "Clean up after starting" : 1 : "If set, Kill choreo scenes after starting so they only play once.If set, the Cancel input will not work properly." =
		[
		0: "No"
		1: "Yes"
		]

	busyactor(choices) : "If an Actor is talking..." : 1 : "What to do if an actor this scene needs is already talking when this scene is told to start." =
		[
		0: "Start immediately"
		1: "Wait for actor to finish"
		2: "Interrupt at next interrupt event"
		3: "Cancel at next interrupt event"
		]

	onplayerdeath(choices) : "On player death" : 0 : "What should this entity do if the player dies" =
		[
		0: "Do Nothing"
		1: "Cancel Script and return to AI"
		]

	scene01(scene) : "Scene 1"
	scene02(scene) : "Scene 2"
	scene03(scene) : "Scene 3"
	scene04(scene) : "Scene 4"
	scene05(scene) : "Scene 5"
	scene06(scene) : "Scene 6"
	scene07(scene) : "Scene 7"
	scene08(scene) : "Scene 8"
	scene09(scene) : "Scene 9"
	scene10(scene) : "Scene 10"
	scene11(scene) : "Scene 11"
	scene12(scene) : "Scene 12"
	scene13(scene) : "Scene 13"
	scene14(scene) : "Scene 14"
	scene15(scene) : "Scene 15"
	scene16(scene) : "Scene 16"
	scene17(scene) : "Scene 17"
	scene18(scene) : "Scene 18"
	scene19(scene) : "Scene 19"
	scene20(scene) : "Scene 20"

	// Inputs
	input Start(void) : "Start the choreo sequence playing."
	input Cancel(void) : "Stop the choreo sequence at any point."

	// Outputs
	output OnStart(void) : "Fired when the sequence starts."
	output OnFinish(void) : "Fired when the sequence is complete."
	]

@PointClass base(BaseEntityPoint) 
	iconsprite("editor/comp_flicker")
	line(255 255 255, targetname, target_mdl)
= comp_flicker: "Fires on/off inputs repeatedly to simulate a flicker-on effect. This converts to an info_target, and uses all of the FireUserX inputs/outputs."
	[
	target_mdl(target_destination) : "Model to Control" : : "An entity which will have skins swapped to turn on/off. This is simply a shortcut for adding OnTurnedOn/Off outputs."
	mdl_skin_on(integer) : "On Skin" : 0 : "The 'on' skin for the model. This is a shortcut for adding OnTurnedOn -> Skin outputs."
	mdl_skin_off(integer) : "Off Skin" : 1 : "The 'on' skin for the model. This is a shortcut for adding OnTurnedOff -> Skin outputs."
	total_time(float) : "Total Time" : "1.5" : "The overall time taken to complete the on or off flicker."
	flicker_min(float) : "Flicker Min" : "0.05" : "The delay used at the start of the on cycle, or at the end of the off cycle."
	flicker_max(float) : "Flicker Max" : "0.2" : "The delay used at the end of the on cycle, or at the start of the off cycle."
	variance(float) : "Variance" : "0.0" : "Random variance added/subtracted for each delay."

	// Inputs
	input TurnOn(void) : "Turn the target entities on."
	input TurnOff(void) : "Turn the target entities off."
	input FlickerOn(void) : "Flicker the target gradually on."
	input FlickerOff(void) : "Flicker the target gradually off."

	// Outputs
	output OnTurnedOn(void) : "Fired when the target should turn on."
	output OnTurnedOff(void) : "Fired when the target should turn off."
	output OnFlickerOnStart(void) : "Fired after the flicker on effect has started."
	output OnFlickerOffStart(void) : "Fired after the flicker off effect has started."
	output OnFlickerOnEnd(void) : "Fired after the flicker on effect has finished."
	output OnFlickerOffEnd(void) : "Fired after the flicker off effect has finished."
	]

@PointClass base(PlayerInputs) 
	iconsprite("editor/comp_player_input_helper.vmt")
= comp_player_input_helper: "Place this entity to trick Hammer into autocompleting inputs fired at !player and similar names. This is deleted during compile."
	[
	targetname(choices) : "Player Name" : "!player" : "The targetname to show for suggestions." =
		[
		"!player": "!player (SP / 1st Player)"
		"player": "player (All Players)"
		"!pvsplayer": "!pvsplayer (Player in nearby visleafs)"
		]

	]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/env_airstrike_indoors")
= env_airstrike_indoors: "室内空袭效果（崩塌的天花板）"
    [
    height(choices) : "效果高度" : -1 : "指定此效果使用哪个动画序列。（从地板到天花板的距离）" =
        [
        -1: "自动"
        0: "128单位"
        1: "144单位"
        2: "152单位"
        3: "160单位"
        4: "190单位"
        5: "300单位"
        6: "320单位"
        ]


    // 输入
    input DoEffect(void) : "执行一次效果"
    ]

@PointClass base(BaseEntityPoint, Angles) 
    studio()
= env_airstrike_outdoors: "室外空袭效果（爆炸的屋顶、地面）"
    [
    model(studio) : "模型" : "models/props_destruction/general_dest_roof_set.mdl" : "模型名称"
    modelgroup(target_destination) : "动画组" : : "一个或多个dynamic_props的目标名称，用于与我们的序列一起编排。"
    sequence1(string) : "随机序列1" : : "效果开始时模型播放的序列。"
    sequence2(string) : "随机序列2" : : "效果开始时模型播放的序列。"

    // 输入
    input DoEffect(void) : "执行一次效果"
    ]

@PointClass base(BaseEntityPoint) 
    color(255 0 0)
    iconsprite("editor/env_blood.vmt")
= env_blood: "用于产生血液效果的实体。"
    [
    spraydir(angle) : "喷射方向（俯仰 偏航 翻滚）" : "0 0 0" : "血液应该喷射的大致方向，以及追踪以应用贴花的方向。"
    color(choices) : "血液颜色" : 0 =
        [
        0: "红色（人类）"
        1: "黄色（外星人）"
        ]

    amount(string) : "血液量（模拟伤害）" : 100
    spawnflags(flags)  =
        [
        1: "[1] 随机方向" : 0
        2: "[2] 血液流" : 0
        4: "[4] 在玩家身上" : 0
        8: "[8] 喷射贴花" : 0
        16: "[16] 血雾" : 0
        32: "[32] 血滴" : 0
        64: "[64] 血腥" : 0
        ]


    // 输入
    input EmitBlood(void) : "触发血液效果。"
    ]

@SolidClass base(BaseEntity) 
    color(200 200 0)
= env_bubbles: "用于创建产生气泡的体积的实体。"
    [
    density(integer) : "气泡密度" : 2
    frequency(integer) : "气泡频率" : 2
    current(integer) : "水流速度" : 0 : "体积中水流的速度，用于移动气泡。"
    spawnflags(flags)  =
        [
        1: "[1] 初始关闭" : 0
        ]


    // 输入
    input Activate(void) : "激活气泡。"
    input Deactivate(void) : "停用气泡。"
    input Toggle(void) : "切换气泡的开关。"
    input SetDensity(integer) : "设置气泡密度。"
    input SetFrequency(integer) : "设置每秒气泡发射率。"
    input SetCurrent(integer) : "设置单位每秒的水流速度。"
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/ts2do/env_credits.vmt")
= env_credits: "控制从'scripts/credits.txt'加载的滚动字幕的实体。"
    [

    // 输入
    input RollCredits(void) : "开始滚动开始字幕。"
    input RollOutroCredits(void) : "开始滚动结束字幕。"
    input ShowLogo(void) : "显示HL2标志。"
    input SetLogoLength(float) : "设置标志显示的时间长度。默认为5.0。"

    // 输出
    output OnCreditsDone(void) : "当字幕滚动完毕时触发。"
    ]

@PointClass base(BaseEntityPoint, Angles) 
    sphere(fademindist)
    sphere(fademaxdist)
    iconsprite("editor/ficool2/env_detail_controller.vmt")
= env_detail_controller: "一个实体，允许你控制地图中细节精灵的最小和最大淡出距离。"
    [
    fademindist(float) : "开始淡出距离/像素" : 512 : "细节道具开始淡出的距离。"
    fademaxdist(float) : "结束淡出距离/像素" : 1024 : "细节道具停止淡出并完全停止绘制的距离。"
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/env_dof_controller.vmt")
    color(200 0 0)
    line(255 255 0, targetname, focus_target)
    sphere(near_blur)
    sphere(near_focus)
    sphere(far_blur)
    sphere(far_radius)
= env_dof_controller: "一个控制玩家景深设置的实体。景深模拟了场景中失焦区域的相机模糊。"
    [

    // 输入
    input SetNearBlurDepth(float) : "设置完全模糊使用近景模糊半径的焦点区域前面的距离。必须小于近景焦点深度。"
    input SetNearFocusDepth(float) : "近景焦点和远景焦点距离之间的区域完全在焦点中。必须小于远景焦点深度。"
    input SetFarFocusDepth(float) : "近景焦点和远景焦点距离之间的区域完全在焦点中。必须小于远景模糊深度。"
    input SetFarBlurDepth(float) : "设置完全模糊使用远景模糊半径的焦点区域之后的距离。必须大于远景焦点深度。"
    input SetNearBlurRadius(float) : "设置在近景模糊距离使用的模糊半径（以像素为单位）。设置为0以禁用近景模糊。"
    input SetFarBlurRadius(float) : "设置在远景模糊距离使用的模糊半径（以像素为单位）。设置为0以禁用远景模糊。"
    ]

@PointClass base(BaseEntityPoint, Angles) 
    studio("models/editor/env_dustpuff.mdl")
= env_dustpuff: "可释放尘埃团的实体。"
    [
    scale(float) : "比例" : 8 : "尘埃团的大小。"
    speed(float) : "速度" : 16 : "尘埃粒子应该移动的速度。"
    color(color255) : "尘埃颜色" : "128 128 128"

    // 输入
    input SpawnDust(void) : "产生一个尘埃团。"
    ]

@SolidClass base(BaseEntity, Angles) 
    color(200 200 0)
= env_embers: "用于创建产生火星的体积的实体。"
    [
    particletype(choices) : "火星类型" : 0 =
        [
        0: "普通"
        1: "平滑淡出"
        2: "拉扯"
        ]

    density(integer) : "密度（每秒粒子数）" : 50
    lifetime(integer) : "粒子寿命（秒）" : 4
    speed(integer) : "粒子速度（单位每秒）" : 32
    rendercolor(color255) : "火星颜色（R G B）" : "255 255 255"
    spawnflags(flags)  =
        [
        1: "[1] 开始时启动" : 0
        2: "[2] 切换" : 0
        ]

    ]

@PointClass base(BaseEntityPoint) 
    color(200 200 0)
    line(255 128 0, targetname, target)
    iconsprite("editor/ficool2/env_entity_igniter.vmt")
= env_entity_igniter: "一个点燃目标实体的实体。如果实体是一个动画模型，它将在其骨架上附加精灵火焰。否则实体将释放粒子火焰团。"
    [
    target(target_destination) : "要点燃的实体" : : "要点火的实体的名称。"
    lifetime(float) : "火焰持续时间（秒）" : 10 : "火焰的持续时间。"

    // 输入
    input Ignite(void) : "点燃目标实体。"
    ]

@PointClass base(BaseEntityPoint, Angles) 
    line(255 255 0, targetname, entitytemplate)
    iconsprite("editor/env_entity_maker.vmt")
    studio("models/editor/angle_helper.mdl")
= env_entity_maker: "在其原点生成指定的实体模板。如果设置为自动产生，它将在有空间且玩家不在看的时候产生模板。"
    [
    spawnflags(flags)  =
        [
        1: "[1] 启用自动产生（有空间时将产生）" : 0
        2: "[2] 自动产生：等待实体销毁" : 0
        4: "[4] 自动产生：即使玩家正在看" : 0
        8: "[8] 强制产生：仅当有空间时" : 0
        16: "[16] 强制产生：仅当玩家不在看时" : 0
        ]

    entitytemplate(target_destination) : "要产生的点模板" : : "要在这里产生的点模板的名称。"
    postspawnspeed(float) : "产生后移动速度" : 0 : "如果指定，模板中创建的所有实体将以指定的产生后移动方向移动这么快。"
    postspawndirection(angle) : "产生后移动方向" : "0 0 0" : "如果指定了产生后移动速度，模板中创建的所有实体将朝这个方向移动。"
    postspawndirectionvariance(float) : "产生后方向偏差" : "0.15" : "此偏差应用于模板中每个产生实体的产生后移动方向。使用它来给方向添加一些随机性。"
    postspawninheritangles(choices) : "产生后继承角度" : 0 : "如果在层级中，产生方向是世界空间还是父对象的局部空间。" =
        [
        0: "否"
        1: "是"
        ]


    // 输入
    input ForceSpawn(void) : "在此原点和角度产生模板的一个实例。"
    input ForceSpawnAtEntityOrigin(target_destination) : "在与指定实体具有相同原点和角度的位置产生模板的一个实例。"

    // 输出
    output OnEntitySpawned(void) : "当实体模板的一个实例被产生时触发。"
    output OnEntityFailedSpawn(void) : "当ForceSpawn输入未能产生模板时触发，无论是因为空间不足还是玩家视野内，具体取决于spawnflags。"
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/env_explosion.vmt")
    color(200 200 0)
    sphere(iRadiusOverride)
    line(255 255 0, targetname, ignoredEntity)
= env_explosion: "在其原点产生爆炸的实体。"
    [
    imagnitude(integer) : "威力" : 100 : "爆炸造成的伤害量。"
    iradiusoverride(integer) : "半径覆盖" : 0 : "如果指定，爆炸对实体造成伤害的半径。如果未指定，半径将基于威力。"
    fireballsprite(sprite) : "火球精灵" : "sprites/zerogxplode.vmt"
    damageforce(float) : "伤害力量" : 0 : "应用伤害的力量。如果未指定，爆炸不会推动实体。"
    rendermode(choices) : "渲染模式" : 5 =
        [
        0: "普通"
        4: "实体"
        5: "叠加"
        ]

    spawnflags(flags)  =
        [
        1: "[1] 无伤害" : 0
        2: "[2] 可重复" : 0
        4: "[4] 无火球" : 0
        8: "[8] 无烟" : 0
        16: "[16] 无贴花" : 0
        32: "[32] 无火花" : 0
        64: "[64] 无声音" : 0
        128: "[128] 随机方向" : 0
        256: "[256] 无火球烟" : 0
        512: "[512] 无粒子" : 0
        1024: "[1024] 无DLights" : 0
        2048: "[2048] 不限制最小值" : 0
        4096: "[4096] 不限制最大值" : 0
        8192: "[8192] 仅对表面以上造成伤害" : 0
        16384: "[16384] 通用伤害" : 0
        ]

    ignoredentity(target_destination) : "忽略的实体" : : "不伤害或影响命名的实体。"
    ignoredclass(choices) : "忽略的类" : 0 : "不伤害或影响这个类。" =
        [
        0: "无"
        1: "玩家"
        2: "玩家盟友"
        3: "关键玩家盟友"
        4: "蚁狮"
        5: "吊瓜"
        6: "npc_bullseyes"
        7: "市民 - 被动"
        8: "市民叛军"
        9: "联合"
        10: "联合直升机"
        11: "征兵"
        12: "头蟹"
        13: "飞刀"
        14: "城市警察"
        15: "军事"
        16: "扫描器"
        17: "追踪者"
        18: "沃蒂冈特"
        19: "僵尸"
        20: "原型狙击手"
        21: "导弹"
        22: "信号弹"
        23: "地球动物群"
        24: "被黑客攻击的滚雷"
        25: "联合猎人"
        ]


    // 输入
    input Explode(void) : "触发爆炸。"
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/env_fade")
    color(200 0 0)
= env_fade: "控制屏幕淡入淡出的实体。"
    [
    spawnflags(flags)  =
        [
        1: "[1] 从淡入" : 0
        2: "[2] 颜色叠乘" : 0
        4: "[4] 仅淡出！激活玩家" : 0
        8: "[8] 保持淡出（无限时长）" : 0
        ]

    duration(float) : "持续时间（秒）" : 2 : "屏幕淡入或淡出所需的时间。"
    holdtime(float) : "保持淡出（秒）" : 0 : "保持淡入/淡出状态的时间。"
    renderamt(integer) : "淡出透明度" : 255 : "淡出的透明度，其中0 = 完全透明，255 = 完全不透明。"
    rendercolor(color255) : "淡出颜色（R G B）" : "0 0 0"

    // 输入
    input Fade(void) : "开始屏幕淡出。"

    // 输出
    output OnBeginFade(void) : "当淡出开始时触发。"
    ]

@PointClass base(BaseEntityPoint, EnableDisable) 
    iconsprite("editor/env_fire")
    color(200 200 0)
    sphere(firesize)
= env_fire: "处理单个火焰的实体。火焰会对周围的env_fire实体造成热量'伤害'，并最终点燃附近的非燃烧env_fire实体，导致火势蔓延。"
    [
    health(integer) : "持续时间" : 30 : "火焰将燃烧的时间。"
    firesize(integer) : "大小" : 64 : "火焰的高度（世界单位）。"
    fireattack(integer) : "攻击" : 4 : "火焰增长到全强度所需的时间。"
    firetype(choices) : "类型" : 0 =
        [
        0: "自然"
        1: "等离子"
        ]

    spawnflags(flags)  =
        [
        1: "[1] 无限持续时间" : 0
        2: "[2] 无烟" : 0
        4: "[4] 开始时启动" : 0
        8: "[8] 初始全强" : 0
        16: "[16] 不下落" : 0
        32: "[32] 无光晕" : 0
        128: "[128] 熄灭时删除" : 0
        256: "[256] 从上方可见" : 0
        ]

    ignitionpoint(float) : "点火点" : 32 : "在这个火焰应该点燃之前需要承受的热量'伤害'量。"
    damagescale(float) : "伤害比例" : "1.0" : "火焰造成燃烧伤害的倍数。"

    // 输入
    input StartFire(void) : "开始燃烧。"
    input Extinguish(float) : "在指定的秒数内永久熄灭火焰。"
    input ExtinguishTemporary(float) : "在指定的秒数内暂时熄灭火焰。"

    // 输出
    output OnIgnited(void) : "当火焰第一次点燃时触发。"
    output OnExtinguished(void) : "当火焰完全熄灭时触发。"
    ]

@PointClass base(BaseEntityPoint) 
    sphere(fireradius)
    color(200 200 0)
    iconsprite("editor/ficool2/env_firesensor.vmt")
= env_firesensor: "一个检测周围热量变化的实体。"
    [
    spawnflags(flags)  =
        [
        1: "[1] 开始时启动" : 1
        ]

    fireradius(float) : "半径" : 128 : "检测热量变化的半径。"
    heatlevel(float) : "热量水平" : 32 : "检查的目标热量水平。当热量超过这个目标水平（增加或减少）时，输出被触发。"
    heattime(float) : "达到水平的时间" : 0 : "热量水平必须在目标水平之上持续的时间，才会触发'OnHeatLevelStart'输出。"

    // 输入
    input Enable(void) : "启用火焰传感器。"
    input Disable(void) : "禁用火焰传感器。"

    // 输出
    output OnHeatLevelStart(void) : "当热量水平持续了指定的时间时触发。"
    output OnHeatLevelEnd(void) : "当热量水平低于目标水平时触发。"
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/env_firesource")
    sphere(fireradius)
    color(200 200 0)
= env_firesource: "一个向所有附近的env_fire实体提供热量的实体。不能被熄灭。"
    [
    spawnflags(flags)  =
        [
        1: "[1] 开始时启动" : 0
        ]

    fireradius(float) : "半径" : 128 : "提供热量的半径。"
    firedamage(float) : "强度/伤害" : 10 : "在半径内应用于env_fire实体的热量'伤害'量。"

    // 输入
    input Enable(void) : "启用火源。"
    input Disable(void) : "禁用火源。"
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/fog_controller.vmt")
    color(255 255 255)
    color(200 0 0)
    studio("models/editor/cone_helper.mdl")
= env_fog_controller: "控制地图中雾和视距的实体。"
    [
    fogenable(choices) : "雾启用" : 1 =
        [
        0: "否"
        1: "是"
        ]

    fogblend(choices) : "雾混合" : 0 =
        [
        0: "否"
        1: "是"
        ]

    use_angles(choices) : "使用角度作为雾方向" : 0 =
        [
        0: "否"
        1: "是"
        ]

    fogcolor(color255) : "主雾颜色" : "255 255 255"
    fogcolor2(color255) : "次雾颜色" : "255 255 255"
    fogdir(string) : "主雾方向" : "1 0 0"
    fogstart(string) : "雾起始" : "500.0"
    fogend(string) : "雾结束" : "2000.0"
    fogmaxdensity(float) : "雾最大密度 [0..1]" : 1
    foglerptime(float) : "插值时间" : 0
    farz(string) : "远Z剪裁平面" : -1
    spawnflags(flags)  =
        [
        1: "[1] 主控（如果存在多个env_fog_controllers，具有优先权）" : 0
        ]

    hdrcolorscale(float) : "HDR颜色比例" : 1 : "在HDR模式下运行时乘以雾色的浮点值。"

    // 输入
    input SetStartDist(float) : "设置雾起始距离。"
    input SetEndDist(float) : "设置雾结束距离。"
    input SetMaxDensity(float) : "设置雾的最大密度。"
    input TurnOn(void) : "打开雾。"
    input TurnOff(void) : "关闭雾。"
    input SetColor(color255) : "设置主雾颜色。"
    input SetColorSecondary(color255) : "设置次雾颜色。"
    input SetFarZ(integer) : "设置远剪裁平面距离。"
    input SetAngles(string) : "设置用于次雾方向的角度。"
    input SetColorLerpTo(color255) : "设置主雾颜色。"
    input SetColorSecondaryLerpTo(color255) : "设置次雾颜色。"
    input SetStartDistLerpTo(float) : "设置雾起始距离。"
    input SetEndDistLerpTo(float) : "设置雾结束距离。"
    input StartFogTransition(void) : "开始雾变换。"
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/ficool2/env_funnel")
    color(200 200 0)
= env_funnel: "HL1共振级联序列中的吸入效果。"
    [
    spawnflags(flags)  =
        [
        1: "[1] 反向（排斥粒子而不是吸入）" : 0
        ]

    ]

@PointClass base(BaseEntityPoint) 
    color(200 0 0)
    iconsprite("editor/env_global.vmt")
= env_global: "控制游戏特定全局状态的实体。"
    [
    globalstate(string) : "要设置的全局状态"
    initialstate(choices) : "初始状态" : 0 =
        [
        0: "关闭"
        1: "开启"
        2: "死亡"
        ]

    counter(integer) : "计数器" : 0 : "与此全局相关联的整数计数器值。"
    spawnflags(flags)  =
        [
        1: "[1] 设置初始状态" : 0
        ]


    // 输入
    input TurnOn(void) : "将全局状态设置为开启。"
    input TurnOff(void) : "将全局状态设置为关闭。"
    input Toggle(void) : "切换全局状态在开启和关闭之间。"
    input Remove(void) : "将全局状态设置为死亡。"
    input SetCounter(integer) : "设置此全局的计数器值。"
    input AddToCounter(integer) : "增加此全局的计数器值。负数则减少。"
    input GetCounter(void) : "导致Counter输出被触发，传递此全局的当前计数器值。这个不太能正常工作。"

    // 输出
    output Counter(integer) : "响应GetCounter输入时触发，传递计数器的当前值。"
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/env_hudhint.vmt")
= env_hudhint: "控制HUD提示显示的实体。HUD提示用于向玩家显示绑定到特定命令的键。"
    [
    spawnflags(flags)  =
        [
        1: "[1] 所有玩家" : 0
        ]

    message(string) : "提示文本（本地化）" : : "这应该设置为与resource/valve_english.txt中所需的HUD提示条目匹配。"

    // 输入
    input ShowHudHint(void) : "显示提示信息。"
    input HideHudHint(void) : "隐藏提示信息。"
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/env_instructor_hint.vmt")
    line(255 255 0, targetname, hint_target)
    sphere(hint_range)
= env_instructor_hint: "一个实体，允许通过地图逻辑创建和控制教官课程。"
    [
    hint_replace_key(string) : "替换键" : : "同时显示时具有相同替换键的提示将相互替换。如果您希望同时显示多个提示，请为每个提示使用不同的值。"
    hint_target(target_destination) : "目标实体" : : "在其上方显示此提示的实体。所使用的实体必须在客户端存在，info_target_instructor_hint可以父级到仅服务器的实体。"
    hint_static(choices) : "定位" : 0 : "要么在目标实体的位置显示。要么直接在hud上固定位置显示提示。" =
        [
        0: "跟随目标实体"
        1: "在hud上显示"
        ]

    hint_allow_nodraw_target(choices) : "允许不可见目标" : 1 : "我们允许提示跟随设置了nodraw的实体吗？" =
        [
        0: "在nodraw上立即结束"
        1: "是"
        ]

    hint_caption(string) : "标题" : : "您的提示文本。"
    hint_activator_caption(string) : "激活者标题" : : "仅向激活玩家显示的提示文本。"
    hint_color(color255) : "标题颜色" : "255 255 255" : "标题文本的颜色"
    hint_forcecaption(choices) : "穿墙显示" : 0 : "如果提示被墙遮挡，我们是否显示标题文本？" =
        [
        0: "否"
        1: "被遮挡时显示"
        ]

    hint_icon_onscreen(choices) : "屏幕上的图标" : "icon_tip" : "当提示处于玩家视野内时使用的图标。" =
        [
        "use_binding": "显示控制代替"
        "icon_blank": "空白"
        "icon_bulb": "灯泡"
        "icon_caution": "小心"
        "icon_alert": "白色感叹号"
        "icon_alert_red": "红色感叹号"
        "icon_tip": "信息"
        "icon_skull": "眼睛"
        "icon_interact": "互动/拾取"
        "icon_button": "按钮"
        "icon_door": "门"
        "icon_useable_item": "操纵杆"
        "icon_arrow_plain_white_dn": "简单向下箭头"
        "icon_arrow_plain_white_up": "简单向上箭头"
        "icon_arrow_up": "向上箭头"
        "icon_arrow_right": "向右箭头"
        "icon_mouseRight": "右键点击"
        "icon_mouseLeft": "左键点击"
        "icon_mouseWheel_up": "鼠标滚轮向上"
        "icon_mouseWheel_down": "鼠标滚轮向下"
        "icon_mouseThree": "点击滚轮"
        "icon_key_generic": "空白键"
        "icon_key_wide": "空格键"
        "icon_key_right": "右键"
        "icon_key_left": "左键"
        "icon_key_down": "下键"
        "icon_key_up": "上键"
        "icon_dpad": "方向键"
        "icon_fire": "开火"
        "icon_present": "礼物"
        ]

    hint_icon_offscreen(choices) : "屏幕外的图标" : "icon_tip" : "当提示在玩家视野外时使用的图标。" =
        [
        "use_binding": "显示控制代替"
        "icon_blank": "空白"
        "icon_bulb": "灯泡"
        "icon_caution": "小心"
        "icon_alert": "白色感叹号"
        "icon_alert_red": "红色感叹号"
        "icon_tip": "信息"
        "icon_skull": "眼睛"
        "icon_interact": "互动/拾取"
        "icon_button": "按钮"
        "icon_door": "门"
        "icon_useable_item": "操纵杆"
        "icon_arrow_plain_white_dn": "简单向下箭头"
        "icon_arrow_plain_white_up": "简单向上箭头"
        "icon_arrow_up": "向上箭头"
        "icon_arrow_right": "向右箭头"
        "icon_mouseRight": "右键点击"
        "icon_mouseLeft": "左键点击"
        "icon_mouseWheel_up": "鼠标滚轮向上"
        "icon_mouseWheel_down": "鼠标滚轮向下"
        "icon_mouseThree": "点击滚轮"
        "icon_key_generic": "空白键"
        "icon_key_wide": "空格键"
        "icon_key_right": "右键"
        "icon_key_left": "左键"
        "icon_key_down": "下键"
        "icon_key_up": "上键"
        "icon_dpad": "方向键"
        "icon_fire": "开火"
        "icon_present": "礼物"
        ]

    hint_nooffscreen(choices) : "显示屏幕外" : 0 : "当提示在屏幕外时，我们是否显示图标和箭头？" =
        [
        0: "显示"
        1: "不显示"
        ]

    hint_binding(choices) : "绑定命令" : : "如果使用'显示键绑定'作为屏幕上的图标，该字段应为我们想要显示绑定的命令。" =
        [
        "": "未使用"
        "+forward": "前进"
        "+back": "后退"
        "+left": "向左平移"
        "+right": "向右平移"
        "+duck": "下蹲"
        "+jump": "跳跃"
        "+speed": "冲刺"
        "+reload": "装填"
        "+attack": "主要攻击"
        "+attack2": "次要攻击"
        "+use": "使用键"
        "+zoom": "放大"
        "-zoom": "缩小"
        ]

    hint_icon_offset(float) : "图标高度偏移" : 0 : "目标实体原点上方显示提示的高度偏移"
    hint_pulseoption(choices) : "尺寸脉动" : 0 : "图标尺寸可以脉动" =
        [
        0: "无脉动"
        1: "慢脉动"
        2: "快脉动"
        3: "紧急脉动"
        ]

    hint_alphaoption(choices) : "透明度脉动" : 0 : "图标透明度可以脉动" =
        [
        0: "无脉动"
        1: "慢脉动"
        2: "快脉动"
        3: "紧急脉动"
        ]

    hint_shakeoption(choices) : "震动" : 0 : "图标可以震动" =
        [
        0: "无震动"
        1: "轻微震动"
        2: "剧烈震动"
        ]

    hint_local_player_only(choices) : "仅本地玩家" : 0 : "提示将仅显示给本地玩家。" =
        [
        0: "否"
        1: "是"
        ]

    hint_timeout(integer) : "超时" : 0 : "提示的自动超时时间。0将持续到使用EndHint停止。"
    hint_range(float) : "显示范围" : 0 : "提示的可见范围。"
    hint_name(string) : "课程名称" : : "具有相同课程名称的提示使用共同的基础，并被视为同一课程类型的实例。"
    hint_display_limit(integer) : "显示限制" : 0 : "提示可以看到的次数。0表示无限制。"
    hint_instance_type(choices) : "实例类型" : 2 : "同时可以打开或激活单一课程类型的实例数量" =
        [
        0: "多个"
        1: "单个打开"
        2: "固定替换"
        3: "单个活跃"
        ]

    hint_auto_start(choices) : "首次看到时显示" : 1 : "玩家首次看到时，将自动为他们显示。" =
        [
        0: "否"
        1: "是"
        ]

    hint_suppress_rest(choices) : "移动前抑制休息" : 0 : "抑制屏幕中心的初始图标显示？" =
        [
        0: "否"
        1: "是"
        ]


    // 输入
    input ShowHint(string) : "开始显示提示。如果传递了实体名称作为参数，则仅向该实体显示提示。"
    input EndHint(void) : "如果提示尚未超时，则停止显示提示。"
    ]

@PointClass base(BaseEntityPoint, RenderFields) 
    color(255 128 0)
    studio("models/editor/axis_helper_thick.mdl")
    iconsprite("editor/ficool2/env_lightglow.vmt")
    sphere(minDist)
    sphere(maxDist)
    sphere(outerMaxDist)
    sphere(GlowProxySize)
= env_lightglow: "一个在世界中添加叠加光晕的实体，主要用于光源之上。"
    [
    rendercolor(color255) : "颜色（R G B）" : "255 255 255"
    verticalglowsize(integer) : "垂直尺寸" : 30
    horizontalglowsize(integer) : "水平尺寸" : 30
    mindist(integer) : "最小距离" : 500 : "该效果将完全透明的距离。"
    maxdist(integer) : "最大距离" : 2000 : "该效果将达到全强度的距离。"
    outermaxdist(integer) : "外部最大距离" : 0 : "如果大于最大距离，这是光晕将完全消失的长度，介于最大距离和这个长度之间。"
    glowproxysize(float) : "光晕代理几何尺寸" : 2 : "用于可见性测试的光晕尺寸。必须大于从精灵中心到空旷空间的距离。所以如果这个光晕在几何体内（比如灯泡），请将此值设置得比灯泡的半径大。任何时候这个半径的球体可见（从附近的几何体中突出），光晕就会被渲染。"
    hdrcolorscale(float) : "HDR颜色比例。" : "0.5" : "在HDR模式下运行时用于乘以精灵颜色的浮点值。"
    spawnflags(flags)  =
        [
        1: "[1] 仅从前面可见" : 0
        ]


    // 输入
    input Color(color255) : "更改光晕的渲染颜色。格式：<红 0-255> <绿 0-255> <蓝 0-255>"
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/ts2do/env_message.vmt")
= env_message: "一个在玩家HUD上绘制文本消息的实体。"
    [
    message(string) : "消息文本"
    spawnflags(flags)  =
        [
        1: "[1] 仅播放一次" : 0
        2: "[2] 所有客户端" : 0
        ]

    messagesound(sound) : "声效" : : "当消息显示时，这个声效将被播放，起源于这个实体。"
    messagevolume(string) : "音量 0-10" : 10 : "声效的音量。"
    messageattenuation(choices) : "声音半径" : 0 =
        [
        0: "小半径"
        1: "中半径"
        2: "大半径"
        3: "到处播放"
        ]


    // 输入
    input ShowMessage(void) : "显示消息并播放声音。"

    // 输出
    output OnShowMessage(void) : "当消息被激活时触发。"
    ]

@PointClass base(BaseEntityPoint, EnableDisable) 
    iconsprite("editor/env_microphone.vmt")
    sphere(MaxRange)
    color(0 0 255)
    line(64 64 64, targetname, target)
    line(255 255 0, targetname, target, targetname, SpeakerName)
= env_microphone: "一个充当麦克风的实体。它有两种工作模式。如果设置了'扬声器'，它会捕捉指定声音范围内的所有声音，并通过扬声器实体重新广播它们。在这种扬声器模式下，它会忽略Hears X生成标志并且不会触发声音级别输出。如果没有设置扬声器，它会在一个点测量声音级别，并输出声音级别作为0到1之间的值。在测量模式下，它只会听到与Hear X生成标志匹配的声音。"
    [
    target(target_destination) : "测量目标" : : "如果扬声器处于测量模式，这是要测量声音级别的实体的名称。"
    speakername(target_destination) : "扬声器目标" : : "任何被这个麦克风听到的声音都将通过哪个实体播放的名称。如果指定，麦克风将认为自己处于扬声器模式。"
    listenfilter(filterclass) : "监听过滤器" : : "指定麦克风可以听到的唯一实体的过滤器实体的名称。其他实体发出的声音将不会被听到。"
    speaker_dsp_preset(choices) : "扬声器DSP预设" : 0 : "仅在扬声器模式下有用。如果指定，当麦克风启用时，它将将全局dsp_speaker预设设置为这个值。然后通过扬声器播放的声音将受到所选DSP的影响。" =
        [
        0: "使用默认"
        50: "1 无效果"
        51: "2（1的副本）"
        52: "3（1的副本）"
        53: "4（1的副本）"
        54: "5（1的副本）"
        55: "6 扬声器，更响亮"
        56: "7 扬声器非常小"
        57: "8 扩音器，回音"
        58: "9 扬声器小"
        59: "10 扬声器微小"
        32: "32 爆炸闷音 1"
        33: "33 爆炸闷音 2"
        34: "34 爆炸闷音 3"
        35: "35 爆炸环 1"
        36: "36 爆炸环 2"
        37: "37 爆炸环 3"
        38: "38 ''爆炸环'' 4"
        44: "44 测试 1（高音）"
        45: "45 测试 2（低音）"
        46: "46 测试 3（沉默？）"
        47: "47 测试 4（失真）"
        48: "48 测试 5（长摆动）"
        49: "49 测试 6（沉默？）"
        ]

    spawnflags(flags)  =
        [
        1: "[1] 听战斗声音" : 1
        2: "[2] 听世界声音" : 1
        4: "[4] 听玩家声音" : 1
        8: "[8] 听子弹撞击声" : 1
        16: "[16] 吞噬通过扬声器路由的声音" : 0
        32: "[32] 听爆炸声" : 0
        64: "[64] 忽略非衰减声音" : 0
        ]

    sensitivity(float) : "灵敏度（0 - 10）" : 1 : "麦克风灵敏度，0=聋，1=默认，10=极其敏感）。仅适用于测量模式。"
    smoothfactor(float) : "平滑（0 - 1）" : 0 : "平滑因子，0=无平滑，1=最大平滑）。仅适用于测量模式。"
    maxrange(float) : "最大听力范围（0=无限）" : 240 : "超出此范围的声音将不会被听到，与衰减无关。警告：当麦克风处于扬声器模式时，将此设置为零（或大于1024的值）可能对性能非常不利！！"

    // 输入
    input SetSpeakerName(string) : "将麦克风输出设置为通过不同的扬声器实体。"

    // 输出
    output SoundLevel(float) : "在测量模式下，每当声音级别发生变化时触发。"
    output OnRoutedSound(void) : "每当通过指定的扬声器（如果有的话）路由出声音时触发。"
    output OnHeardSound(void) : "每当这个麦克风听到它关心的任何声音时触发。"
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/env_outtro_stats")
= env_outtro_stats: "一个在战役结束时控制结尾统计数据的实体。"
    [

    // 输入
    input RollStatsCrawl(void) : "开始滚动结尾统计数据。"
    input RollCredits(void) : "开始滚动结尾字幕。"

    // 输出
    output OnOuttroStatsDone(void) : "当统计数据滚动完毕或用户取消时触发。"
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/ficool2/env_particle_performance_monitor")
= env_particle_performance_monitor: "用于开启和关闭粒子吞吐量测量和显示的实体。"
    [

    // 输入
    input TurnOnDisplay(void) : "开启粒子模拟基准显示"
    input TurnOffDisplay(void) : "关闭粒子模拟基准显示"
    input StartMeasuring(void) : "开始测量粒子模拟速度"
    input StopMeasuring(void) : "停止测量粒子模拟速度"
    ]

@PointClass base(BaseEntityPoint) 
    color(200 200 0)
    line(200 200 200, targetname, psname)
    iconsprite("editor/ficool2/env_particlelight.vmt")
= env_particlelight: "一个用于照亮env_smokestack实体发出的烟雾粒子的实体。不照亮其他粒子类型。"
    [
    color(color255) : "颜色" : "255 0 0" : "此光源发出的颜色。"
    intensity(integer) : "强度" : 5000
    directional(choices) : "方向性" : 0 : "如果指定，那么这个光将使用粒子上的凹凸贴图。每个粒子系统可以有一个环境光和一个方向光。" =
        [
        0: "否"
        1: "是"
        ]

    psname(target_destination) : "粒子系统实体" : : "将此设置为你想要此灯光影响的env_smokestack的名称。"
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/vizzys/env_particlescript")
    studioprop()
= env_particlescript: "一个具有特殊动画事件的实体，可以由一个内置有为此实体设计的动画的模型在其.qc中触发。"
    [
    model(studio) : "脚本模型" : : "用于动画序列的模型。"

    // 输入
    input SetSequence(string) : "设置脚本模型的序列。"
    ]

@PointClass base(BaseEntityPoint) 
    sphere(inner_radius)
    iconsprite("editor/env_physexplosion.vmt")
    line(255 255 0, targetname, targetEntityName)
    cylinder(255 0 0, targetname, targetname, radius, targetname, targetentityname)
    color(128 128 128)
    sphere(radius)
= env_physexplosion: "一个在其原点创建爆炸的实体。如果设置了无伤害生成标志，爆炸将不可见，但会对其半径内的任何物理对象施加力。"
    [
    magnitude(string) : "威力" : 100 : "爆炸施加的物理力量。"
    radius(string) : "限制半径（0 = 自动）" : 0 : "如果指定，爆炸会在该半径内对实体造成伤害。如果未指定，半径将基于威力。"
    targetentityname(target_destination) : "限制实体" : : "如果指定，爆炸将只影响匹配的实体。"
    spawnflags(flags)  =
        [
        1: "[1] 无伤害 - 仅力量" : 1
        2: "[2] 推动玩家" : 0
        4: "[4] 径向推动 - 不作为球体" : 0
        8: "[8] 推动前测试LOS" : 0
        16: "[16] 如果推动则使玩家迷失方向" : 0
        ]

    inner_radius(float) : "内半径" : 0 : "如果不为零，LOS将从与这个球体相交的点计算。"

    // 输入
    input Explode(void) : "触发爆炸。"

    // 输出
    output OnPushedPlayer(void) : "当玩家被爆炸推动时触发。"
    ]

@PointClass base(BaseEntityPoint) 
    obb(boxmins, boxmaxs)
    iconsprite("editor/env_physics_blocker")
= env_physics_blocker: "一个阻止玩家和物理对象的实体。"
    [
    boxmins(vector) : "最小值" : "-8 -8 -8"
    boxmaxs(vector) : "最大值" : "8 8 8"
    initialstate(choices) : "初始状态" : 1 =
        [
        0: "禁用"
        1: "启用"
        ]

    blocktype(choices) : "阻止" : 0 =
        [
        0: "所有人"
        1: "幸存者"
        2: "玩家感染者"
        3: "所有特殊感染者（玩家和AI）"
        4: "所有玩家和物理对象"
        ]


    // 输入
    input Enable(void) : "启用阻止器"
    input Disable(void) : "禁用阻止器"
    ]

@PointClass base(BaseEntityPoint) 
    line(255 255 255, targetname, directionentityname)
    iconsprite("editor/ficool2/env_physimpact.vmt")
    sphere(distance)
    color(128 128 128)
= env_physimpact: "一个会对另一个实体造成物理冲击的实体。"
    [
    angles(angle) : "俯仰 偏航 翻滚（Y Z X）" : "0 0 0" : "冲击的方向。"
    magnitude(integer) : "威力" : 100 : "冲击的强度。"
    distance(integer) : "距离" : 0 : "冲击的投射距离（如果为0则使用默认值）。"
    directionentityname(target_destination) : "指向实体" : : "如果设置，将忽略'距离'和角度设置，将使用目标实体的方向和距离。"
    spawnflags(flags)  =
        [
        1: "[1] 无衰减" : 0
        2: "[2] 无限长度" : 0
        4: "[4] 忽视质量" : 0
        8: "[8] 应用力时忽略表面法线" : 1
        ]


    // 输入
    input Impact(void) : "触发冲击"
    ]

@PointClass base(BaseEntityPoint) 
    wirebox(mins, maxs)
    iconsprite("editor/env_player_blocker")
= env_player_blocker: "一个阻止任何指定类型的PC/NPC进入的实体。"
    [
    mins(vector) : "最小值" : "-4 -128 -80"
    maxs(vector) : "最大值" : "4 128 80"
    initialstate(choices) : "初始状态" : 1 =
        [
        0: "禁用"
        1: "启用"
        ]

    blocktype(choices) : "阻止对象" : 0 =
        [
        0: "所有人"
        1: "幸存者"
        2: "玩家感染者"
        3: "所有特殊感染者（玩家和AI）"
        ]


    // 输入
    input Enable(void) : "启用阻止器"
    input Disable(void) : "禁用阻止器"
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/env_player_surface_trigger.vmt")
    color(200 0 0)
= env_player_surface_trigger: "一个监控玩家站立的表面材质，并在其改变为/离开特定材质时触发输出的实体。"
    [
    gamematerial(choices) : "监控的游戏材质" : 0 : "要监控的材质。当玩家站在这种材质上/离开这种材质时，将触发该实体的输出。" =
        [
        0: "无功能（空气）"
        65: "A - 蚁狮"
        66: "B - 血肉"
        67: "C - 混凝土"
        68: "D - 泥土"
        69: "E - 蛋壳"
        70: "F - 肉类"
        71: "G - 格栅"
        72: "H - 外星肉体"
        73: "I - Clip"
        74: "J - 草地"
        75: "K - 雪地"
        76: "L - 塑料"
        77: "M - 金属"
        78: "N - 沙子"
        79: "O - 叶子"
        80: "P - 计算机"
        81: "Q - 沥青"
        83: "S - 泥浆"
        84: "T - 瓷砖"
        85: "U - 纸板"
        86: "V - 通风口"
        87: "W - 木头"
        88: "X - 假表面"
        89: "Y - 玻璃"
        90: "Z - 扭曲护盾"
        1: "1 - 黏土"
        2: "2 - 石膏"
        3: "3 - 岩石"
        4: "4 - 橡胶"
        5: "5 - 石膏板"
        6: "6 - 布料"
        7: "7 - 地毯"
        8: "8 - 纸张"
        9: "9 - 室内装潢"
        11: "11 - 泥巴"
        ]


    // 输入
    input Enable(void) : "开始监视玩家的表面。"
    input Disable(void) : "停止监视玩家的表面。"

    // 输出
    output OnSurfaceChangedToTarget(void) : "当玩家移动到指定的游戏材质上时触发。"
    output OnSurfaceChangedFromTarget(void) : "当玩家离开指定的游戏材质时触发。"
    ]

@PointClass base(BaseEntityPoint) 
    size(-2 -2 -2, 2 2 2)
    frustum(lightfov, nearz, farz, lightcolor, -1)
    studio("models/editor/cone_helper.mdl")
    iconsprite("editor/env_projectedtexture")
    line(255 255 255, targetname, target)
    sphere(nearz)
    sphere(farz)
= env_projectedtexture: "投影纹理实体。"
    [
    spawnflags(flags)  =
        [
        1: "[1] 启用" : 1
        ]

    target(target_destination) : "目标" : : "目标"
    lightfov(float) : "视场" : "90.0" : "投影纹理的视场"
    nearz(float) : "近Z" : "4.0" : "投影纹理的近Z"
    farz(float) : "远Z" : "750.0" : "投影纹理的远Z"
    enableshadows(choices) : "启用阴影" : 1 : "启用/禁用来自此投影纹理的阴影。" =
        [
        0: "否"
        1: "是"
        ]

    shadowquality(choices) : "阴影质量" : 1 : "阴影的质量。" =
        [
        0: "低"
        1: "高"
        ]

    lightonlytarget(choices) : "仅照亮目标" : 0 : "限制手电筒效果只影响目标实体。" =
        [
        0: "否"
        1: "是"
        ]

    lightworld(choices) : "照亮世界" : 1 : "控制手电筒是否影响静态世界几何体。" =
        [
        0: "否"
        1: "是"
        ]

    lightcolor(color255) : "光源颜色" : "255 255 255 200" : "光源颜色 RGB-强度"
    cameraspace(choices) : "相机空间" : 0 : "角度被解释为相对于相机。" =
        [
        0: "否"
        1: "是"
        ]

    texturename(string) : "纹理名称" : "effects/flashlight001" : "要“投影”到环境上的VTF纹理。请注意，env_projectedtexture直接使用.vtf文件，不使用.vmt文件。这里的材料浏览器仅用于协助寻找纹理，因为材料通常与它们的纹理同名。"
    textureframe(integer) : "纹理帧" : 0 : "如果VTF是多帧的，请指定要使用的帧。"

    // 输入
    input TurnOn(void) : "开启纹理"
    input TurnOff(void) : "关闭纹理"
    input SetFOV(float) : "设置视场"
    input Target(target_destination) : "设置一个新的目标实体指向。"
    input CameraSpace(bool) : "设置相机空间。"
    input SpotlightTexture(string) : "设置聚光灯纹理"
    input EnableShadows(bool) : "设置是否启用阴影。"
    ]

@PointClass base(BaseEntityPoint) 
    studio("models/editor/cone_helper.mdl")
    line(255 255 255, targetname, rocktargetname)
= env_rock_launcher: "岩石发射器"
    [
    rocktargetname(target_destination) : "目标名称" : : "要向其投掷岩石的实体的名称。"
    rockdamageoverride(integer) : "岩石伤害覆盖" : 0 : "用于替代默认岩石伤害的伤害值。"

    // 输入
    input LaunchRock(void) : "发射岩石"
    input SetTarget(target_destination) : "目标一个新的实体（按名称）"
    ]
@PointClass base(BaseEntityPoint) 
    iconsprite("editor/env_rockettrail")
= env_rockettrail: "连续的火箭火焰，用于HL2 RPG导弹。"
    [
    ]

@PointClass base(BaseEntityPoint) 
    color(200 0 0)
    iconsprite("editor/ficool2/env_screeneffect")
= env_screeneffect: "允许在玩家视角上播放屏幕空间效果。"
    [
    type(choices) : "效果类型" : 0 : "使用哪种效果。" =
        [
        0: "顾问眩晕"
        1: "开始模糊"
        2: "头晕视觉"
        ]


    // 输入
    input StartEffect(float) : "开始效果，持续时间以秒为单位作为传递参数。"
    input StopEffect(float) : "停止效果。"
    ]

@PointClass base(BaseEntityPoint) 
    color(200 0 0)
    iconsprite("editor/ficool2/env_screenoverlay")
= env_screenoverlay: "一个能够显示和控制一组屏幕覆盖层的实体，这些覆盖层将显示在玩家的视角上。适用于视觉效果，如醉酒效果，传送器残影等。"
    [
    overlayname1(material) : "覆盖层名称 1" : : "要显示的第一个覆盖层材料的名称。"
    overlaytime1(float) : "覆盖层持续时间 1" : "1.0" : "第一个覆盖层应该显示的时间长度，在此之后它将开始显示第二个覆盖层。设置为-1无限期显示第一个覆盖层。"
    overlayname2(material) : "覆盖层名称 2" : : "要显示的第二个覆盖层材料的名称。如果留空，覆盖层显示将结束，此实体将认为自己完成了。"
    overlaytime2(float) : "覆盖层持续时间 2" : "1.0" : "第二个覆盖层应该显示的时间长度，在此之后它将开始显示第三个覆盖层。设置为-1无限期显示第二个覆盖层。"
    overlayname3(material) : "覆盖层名称 3" : : "要显示的第三个覆盖层材料的名称。如果留空，覆盖层显示将结束，此实体将认为自己完成了。"
    overlaytime3(float) : "覆盖层持续时间 3" : "1.0" : "第三个覆盖层应该显示的时间长度，在此之后它将开始显示第四个覆盖层。设置为-1无限期显示第三个覆盖层。"
    overlayname4(material) : "覆盖层名称 4" : : "要显示的第四个覆盖层材料的名称。如果留空，覆盖层显示将结束，此实体将认为自己完成了。"
    overlaytime4(float) : "覆盖层持续时间 4" : "1.0" : "第四个覆盖层应该显示的时间长度，在此之后它将开始显示第五个覆盖层。设置为-1无限期显示第四个覆盖层。"
    overlayname5(material) : "覆盖层名称 5" : : "要显示的第五个覆盖层材料的名称。如果留空，覆盖层显示将结束，此实体将认为自己完成了。"
    overlaytime5(float) : "覆盖层持续时间 5" : "1.0" : "第五个覆盖层应该显示的时间长度，在此之后它将开始显示第六个覆盖层。设置为-1无限期显示第五个覆盖层。"
    overlayname6(material) : "覆盖层名称 6" : : "要显示的第六个覆盖层材料的名称。如果留空，覆盖层显示将结束，此实体将认为自己完成了。"
    overlaytime6(float) : "覆盖层持续时间 6" : "1.0" : "第六个覆盖层应该显示的时间长度，在此之后它将开始显示第七个覆盖层。设置为-1无限期显示第六个覆盖层。"
    overlayname7(material) : "覆盖层名称 7" : : "要显示的第七个覆盖层材料的名称。如果留空，覆盖层显示将结束，此实体将认为自己完成了。"
    overlaytime7(float) : "覆盖层持续时间 7" : "1.0" : "第七个覆盖层应该显示的时间长度，在此之后它将开始显示第八个覆盖层。设置为-1无限期显示第七个覆盖层。"
    overlayname8(material) : "覆盖层名称 8" : : "要显示的第八个覆盖层材料的名称。如果留空，覆盖层显示将结束，此实体将认为自己完成了。"
    overlaytime8(float) : "覆盖层持续时间 8" : "1.0" : "第八个覆盖层应该显示的时间长度，在此之后它将开始显示第九个覆盖层。设置为-1无限期显示第八个覆盖层。"
    overlayname9(material) : "覆盖层名称 9" : : "要显示的第九个覆盖层材料的名称。如果留空，覆盖层显示将结束，此实体将认为自己完成了。"
    overlaytime9(float) : "覆盖层持续时间 9" : "1.0" : "第九个覆盖层应该显示的时间长度，在此之后它将开始显示第十个覆盖层。设置为-1无限期显示第九个覆盖层。"
    overlayname10(material) : "覆盖层名称 10" : : "要显示的第十个覆盖层材料的名称。如果留空，覆盖层显示将结束，此实体将认为自己完成了。"
    overlaytime10(float) : "覆盖层持续时间 10" : "1.0" : "第十个覆盖层应该显示的时间长度，在此之后此实体将停止显示覆盖层。设置为-1无限期显示第十个覆盖层。"

    // 输入
    input StartOverlays(void) : "开始显示第一个覆盖层。"
    input StopOverlays(void) : "停止显示任何覆盖层。"
    input SwitchOverlay(integer) : "切换到显示特定的覆盖层。在参数中传入所需的覆盖层编号。"
    ]

@PointClass base(BaseEntityPoint) 
    sphere(radius)
    iconsprite("editor/env_shake.vmt")
    color(200 0 0)
= env_shake: "一个控制玩家屏幕震动的实体。"
    [
    spawnflags(flags)  =
        [
        1: "[1] 全局震动" : 0
        4: "[4] 空中" : 0
        8: "[8] 物理" : 0
        16: "[16] 绳索" : 0
        32: "[32] 不震动视图（仅用于震动绳索或物理）" : 0
        64: "[64] 不振动控制器" : 0
        ]

    amplitude(float) : "振幅（0-16）" : 4 : "屏幕震动中的噪声量。应该在0到16之间。"
    radius(float) : "效果半径" : 500 : "此实体周围影响玩家的半径。"
    duration(float) : "持续时间（秒）" : 1 : "震动玩家屏幕的时间长度。"
    frequency(float) : "频率" : "2.5" : "用于应用屏幕震动的频率。应该是0到255之间的值，其中0.1=急动，255.0=隆隆声。"

    // 输入
    input Amplitude(string) : "设置振幅（0-16）"
    input Frequency(string) : "设置频率。应该是0到255之间的值，其中0.1=急动，255.0=隆隆声。"
    input StartShake(void) : "开始震动。"
    input StopShake(void) : "停止震动。"
    ]

@PointClass base(BaseEntityPoint) 
    color(255 255 255)
    color(200 200 0)
    iconsprite("editor/env_smokestack.vmt")
    sphere(jetlength)
= env_smokestack: "一个不断喷出烟雾的实体。参见particlezoo.vmf中的示例用法。您可以在烟囱附近放置两个env_particlelight实体，以为其粒子添加环境光。"
    [
    initialstate(choices) : "初始状态" : 0 =
        [
        0: "关闭"
        1: "开启"
        ]

    basespread(integer) : "基部扩散" : 20 : "烟雾粒子产生时起源的随机扩散量。"
    spreadspeed(integer) : "扩散速度" : 15 : "烟雾粒子产生后速度的随机扩散量。"
    speed(integer) : "速度" : 30 : "烟雾粒子产生后移动的速度。"
    startsize(integer) : "粒子起始尺寸" : 20 : "烟雾粒子最初发射时的尺寸。"
    endsize(integer) : "粒子结束尺寸" : 30 : "烟雾粒子完全消失时的尺寸。"
    rate(integer) : "发射率" : 20 : "发射烟雾粒子的速率（即每秒发射的粒子数）。"
    jetlength(integer) : "烟雾尾迹长度" : 180 : "烟囱的长度。烟雾粒子的寿命是从这个和粒子速度推导出来的。"
    windangle(integer) : "风向X/Y角度" : 0 : "这指定了风的方向。它是XY平面上的一个角度。WindSpeed指定了风的强度。"
    windspeed(integer) : "风速" : 0 : "风的强度。"
    smokematerial(material) : "粒子材料" : "particle/SmokeStack.vmt"
    twist(integer) : "扭曲" : 0 : "烟雾粒子围绕原点扭曲的量，以每秒度数计。"
    roll(float) : "滚动速度" : 0 : "滚动的角度，以每秒度数计。"
    rendercolor(color255) : "基础颜色（R G B）" : "255 255 255"
    renderamt(integer) : "透明度" : 255

    // 输入
    input TurnOn(void) : "打开烟囱。"
    input TurnOff(void) : "关闭烟囱。"
    input Toggle(void) : "切换烟囱的开/关状态。"
    input JetLength(integer) : "设置烟雾轨迹的长度。"
    input Rate(integer) : "设置发射烟雾粒子的速率（每秒粒子数）。"
    input Speed(integer) : "设置烟雾粒子生成后的移动速度。"
    input SpreadSpeed(integer) : "设置烟雾粒子生成后的速度随机扩散量。"
    ]

@PointClass base(BaseEntityPoint) 
    color(200 50 0)
    iconsprite("editor/ficool2/env_smoketrail")
    sphere(spawnradius)
= env_smoketrail: "一个创造烟雾轨迹的实体。"
    [
    opacity(float) : "精灵不透明度" : "0.75" : "精灵的不透明度（范围从0 - 1）。"
    spawnrate(float) : "生成速率" : 20 : "每秒发射的粒子数。"
    lifetime(float) : "粒子寿命" : "5.0" : "每个粒子的寿命秒数。"
    startcolor(color255) : "起始颜色" : "192 192 192" : "发射粒子的起始颜色。"
    endcolor(color255) : "结束颜色" : "160 160 160" : "发射粒子的结束颜色。"
    emittime(float) : "发射器寿命" : 0 : "env_smoketrail停止发射粒子之前的秒数。0意味着永不停止发射粒子。"
    minspeed(float) : "最小随机速度" : 10 : "发射粒子的最小随机方向速度。"
    maxspeed(float) : "最大随机速度" : 20 : "发射粒子的最大随机方向速度。"
    mindirectedspeed(float) : "最小定向速度" : 0 : "沿env_smoketrail的前方方向（x轴）使用的发射粒子的最小速度。"
    maxdirectedspeed(float) : "最大定向速度" : 0 : "沿env_smoketrail的前方方向（x轴）使用的发射粒子的最大速度。"
    startsize(float) : "起始粒子尺寸" : 15 : "起始粒子尺寸。"
    endsize(float) : "结束粒子尺寸" : 50 : "结束粒子尺寸。"
    spawnradius(float) : "生成半径" : 15 : "粒子从env_smoketrail发射的距离。"
    firesprite(sprite) : "火焰精灵" : "sprites/firetrail.vmt"
    smokesprite(sprite) : "烟雾精灵" : "sprites/whitepuff.vmt"
    ]

@PointClass base(BaseEntityPoint, EnableDisable) 
    sphere(radius)
    iconsprite("editor/env_soundscape.vmt")
    line(255 255 255, targetname, position0)
    line(255 255 255, targetname, position1)
    line(255 255 255, targetname, position2)
    line(255 255 255, targetname, position3)
    line(255 255 255, targetname, position4)
    line(255 255 255, targetname, position5)
    line(255 255 255, targetname, position6)
    line(255 255 255, targetname, position7)
= env_soundscape: "一个控制区域声音的实体。任何时候激活的声音环境是最后一个对玩家有视线，并且在半径范围内的。"
    [
    radius(integer) : "半径" : 128 : "如果设置为-1，则只要玩家能看到它（不管距离多远），就可以听到声音环境。"
    soundscape(choices) : "声音环境" : "无" : "使用的声音环境的名称。对应于scripts/目录中的soundscapes*.txt文件中的条目。" =
        [
        "无": "无"
        "自动": "自动"
        "自动_对话": "自动（对话）"
        "通用室内": "室内"
        "通用室外": "室外"
        ]

    position0(target_destination) : "声音位置0" : : "将在声音环境文本文件内引用的声音位置。通常用于在世界内定位一组声音。"
    position1(target_destination) : "声音位置1" : : "将在声音环境文本文件内引用的声音位置。通常用于在世界内定位一组声音。"
    position2(target_destination) : "声音位置2" : : "将在声音环境文本文件内引用的声音位置。通常用于在世界内定位一组声音。"
    position3(target_destination) : "声音位置3" : : "将在声音环境文本文件内引用的声音位置。通常用于在世界内定位一组声音。"
    position4(target_destination) : "声音位置4" : : "将在声音环境文本文件内引用的声音位置。通常用于在世界内定位一组声音。"
    position5(target_destination) : "声音位置5" : : "将在声音环境文本文件内引用的声音位置。通常用于在世界内定位一组声音。"
    position6(target_destination) : "声音位置6" : : "将在声音环境文本文件内引用的声音位置。通常用于在世界内定位一组声音。"
    position7(target_destination) : "声音位置7" : : "将在声音环境文本文件内引用的声音位置。通常用于在世界内定位一组声音。"

    // 输入
    input Enable(void) : "启用声音环境。"
    input Disable(void) : "禁用声音环境。"
    input ToggleEnabled(void) : "切换声音环境的启用状态。"

    // 输出
    output OnPlay(void) : "当这个声音环境成为激活的时触发。"
    ]

@PointClass base(BaseEntityPoint, EnableDisable) 
    sphere(radius)
    line(255 255 255, targetname, MainSoundscapeName)
    line(128 128 128, targetname, position0)
    line(128 128 128, targetname, position1)
    line(128 128 128, targetname, position2)
    line(128 128 128, targetname, position3)
    line(128 128 128, targetname, position4)
    line(128 128 128, targetname, position5)
    line(128 128 128, targetname, position6)
    line(128 128 128, targetname, position7)
    iconsprite("editor/env_soundscape_proxy.vmt")
= env_soundscape_proxy: "一个充当声音环境的实体，但从另一个env_soundscape实体获取其所有声音参数。"
    [
    mainsoundscapename(target_destination) : "声音环境实体" : : "获取所有声音参数的声音环境。"
    position0(target_destination) : "声音位置0" : : "将在声音环境文本文件内引用的声音位置。通常用于在世界内定位一组声音。"
    position1(target_destination) : "声音位置1" : : "将在声音环境文本文件内引用的声音位置。通常用于在世界内定位一组声音。"
    position2(target_destination) : "声音位置2" : : "将在声音环境文本文件内引用的声音位置。通常用于在世界内定位一组声音。"
    position3(target_destination) : "声音位置3" : : "将在声音环境文本文件内引用的声音位置。通常用于在世界内定位一组声音。"
    position4(target_destination) : "声音位置4" : : "将在声音环境文本文件内引用的声音位置。通常用于在世界内定位一组声音。"
    position5(target_destination) : "声音位置5" : : "将在声音环境文本文件内引用的声音位置。通常用于在世界内定位一组声音。"
    position6(target_destination) : "声音位置6" : : "将在声音环境文本文件内引用的声音位置。通常用于在世界内定位一组声音。"
    position7(target_destination) : "声音位置7" : : "将在声音环境文本文件内引用的声音位置。通常用于在世界内定位一组声音。"

    // 输入
    input Enable(void) : "启用声音环境。"
    input Disabled(void) : "禁用声音环境。"
    input ToggleEnabled(void) : "切换声音环境的启用状态。"

    // 输出
    output OnPlay(void) : "当这个声音环境成为激活的时触发。"
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/env_spark.vmt")
    color(200 200 0)
    studio("models/editor/cone_helper.mdl")
= env_spark: "用于在其原点创建火花的实体。"
    [
    maxdelay(string) : "最大延迟" : 0 : "火花之间的最长延迟时间（秒）。"
    magnitude(choices) : "大小" : 1 : "火花的大小。" =
        [
        1: "小"
        2: "中"
        5: "大"
        8: "巨大"
        ]

    traillength(choices) : "火花尾迹长度" : 1 =
        [
        1: "短"
        2: "中"
        3: "长"
        ]

    spawnflags(flags)  =
        [
        64: "[64] 开始时打开" : 0
        128: "[128] 发光" : 0
        256: "[256] 无声" : 0
        512: "[512] 有方向性" : 0
        ]


    // 输入
    input StartSpark(void) : "开始火花效果。"
    input StopSpark(void) : "停止火花效果。"
    input ToggleSpark(void) : "切换火花效果的开/关状态。"
    input SparkOnce(void) : "火花一次。"
    ]

@PointClass base(BaseEntityPoint, ResponseContext) 
    line(255 255 255, targetname, target)
    iconsprite("editor/ambient_generic.vmt")
= env_speaker: "公告扬声器"
    [
    delaymin(string) : "公告间最短延迟" : 15
    delaymax(string) : "公告间最长延迟" : 135
    spawnflags(flags)  =
        [
        1: "[1] 开始时静音" : 0
        2: "[2] 到处播放" : 0
        ]

    rulescript(string) : "上下文规则脚本" : : "包含播放适当声音规则的脚本文件。"
    concept(string) : "概念名称" : : "用作主要搜索键的高级概念名称。"

    // 输入
    input TurnOn(void) : "打开随机公告。"
    input TurnOff(void) : "关闭随机公告。"
    input Toggle(void) : "切换随机公告的开/关状态。"
    ]

@PointClass base(BaseEntityPoint) 
    color(32 200 255)
    studio("models/editor/env_splash.mdl")
= env_splash: "一个在其原点创建溅水效果的实体。如果设置了'找到水面'生成标志，它将代替向下追踪到自身下方以找到水面上用来创建溅水的位置。"
    [
    scale(float) : "溅水的规模" : "8.0"
    spawnflags(flags)  =
        [
        1: "[1] 自动找到水面（将实体放置在水面上方）" : 0
        2: "[2] 深度减弱（在10英尺水深中完全减弱）" : 1
        ]


    // 输入
    input Splash(void) : "创建溅水效果。"
    ]

@PointClass base(BaseEntityPoint, RenderFields) 
    studio("models/editor/axis_helper_white.mdl")
    sprite()
    color(20 140 20)
    sphere(GlowProxySize)
= env_sprite: "一个控制在世界中绘制精灵的实体。"
    [
    framerate(float) : "帧率" : "10.0" : "精灵应该以多快的速度动画，如果有的话。"
    model(sprite) : "精灵名称" : "sprites/glow01.vmt" : "要绘制的精灵的材质。"
    scale(float) : "比例" : "0.25" : "精灵的比例乘数。"
    spawnflags(flags)  =
        [
        1: "[1] 开始时打开" : 0
        2: "[2] 播放一次" : 0
        ]

    rendermode(choices) : "渲染模式" : 9 : "指定精灵的渲染行为。" =
        [
        3: "发光"
        9: "世界空间发光"
        0: "正常"
        1: "颜色"
        2: "纹理"
        4: "实体"
        5: "加法"
        7: "加法帧分数"
        10: "不渲染"
        ]

    glowproxysize(float) : "发光代理几何体的大小。" : "2.0" : "用于可见性测试的发光尺寸。必须大于从精灵中心到空旷空间的距离。所以如果这个发光在几何体内（比如灯泡），请将此值设置得比灯泡的半径大。任何时候这个半径的球体可见（从附近的几何体中突出），发光就会被渲染。"
    hdrcolorscale(float) : "HDR颜色比例。" : "0.7" : "在HDR模式下运行时用于乘以精灵颜色的浮点值。"

    // 输入
    input ColorRedValue(float) : "设置红色通道的值（0 - 255）。"
    input ColorGreenValue(float) : "设置绿色通道的值（0 - 255）。"
    input ColorBlueValue(float) : "设置蓝色通道的值（0 - 255）。"
    input SetScale(float) : "设置精灵的比例（0 - 8.0）。"
    input HideSprite(void) : "隐藏精灵。在收到'显示精灵'输入之前不会绘制。"
    input ShowSprite(void) : "显示精灵。"
    input ToggleSprite(void) : "切换精灵的隐藏和显示。"
    ]

@PointClass base(BaseEntityPoint, RenderFields) 
    iconsprite("editor/env_spritetrail.vmt")
    sphere(startwidth)
    sphere(endwidth)
= env_spritetrail: "你可以为任何你心爱的东西制作一个神奇的尾迹。"
    [
    lifetime(float) : "生命周期" : "0.5"
    startwidth(float) : "开始宽度" : "8.0"
    endwidth(float) : "结束宽度" : "1.0"
    spritename(sprite) : "精灵名称" : "sprites/bluelaser1.vmt"
    renderamt(integer) : "FX量（0 - 255）" : 255 : "FX量由选定的渲染模式使用。"
    rendercolor(color255) : "FX颜色（R G B）" : "255 255 255" : "FX颜色由选定的渲染模式使用。"
    rendermode(choices) : "渲染模式" : 5 =
        [
        0: "正常"
        4: "实体"
        5: "加法"
        ]

    ]

@PointClass base(BaseEntityPoint, RenderFields) 
    color(255 255 255)
    color(200 200 0)
    studioprop("models/editor/spot_cone_fixed.mdl")
    frustum(spreadspeed, _frustum_near, jetlength, rendercolor, -1)
= env_steam: "用于创建蒸汽喷射的实体。"
    [
    spawnflags(flags)  =
        [
        1: "[1] 自发光" : 0
        ]

    initialstate(choices) : "开始启用" : 0 =
        [
        0: "否"
        1: "是"
        ]

    type(choices) : "粒子类型" : 0 =
        [
        0: "正常"
        1: "热浪"
        ]

    spreadspeed(integer) : "扩散速度" : 15 : "粒子生成后速度的随机扩散量。"
    speed(integer) : "速度" : 120 : "粒子生成后移动的默认速度。"
    startsize(integer) : "粒子开始大小" : 10 : "粒子生成时的初始大小。"
    endsize(integer) : "粒子结束大小" : 25 : "粒子在完全移除时的大小。"
    rate(integer) : "发射率" : 26 : "粒子发射的速率。即每秒发射的粒子数。"
    rendercolor(color255) : "颜色（R G B）" : "60 65 68" : "蒸汽的颜色。只有在自发光标志打开时才有效，但否则可以用来设置在Hammer中显示的颜色。"
    jetlength(integer) : "蒸汽喷射长度" : 80 : "喷射长度决定了每个粒子的生命周期。"
    renderamt(integer) : "透明度" : 255
    rollspeed(float) : "旋转速度" : 8 : "粒子旋转的速度"

    // 输入
    input TurnOn(void) : "打开蒸汽喷射。"
    input TurnOff(void) : "关闭蒸汽喷射。"
    input Toggle(void) : "切换蒸汽喷射的开/关状态。"
    input JetLength(integer) : "设置蒸汽喷射的长度。"
    input Rate(integer) : "设置粒子发射速率，单位为每秒粒子数。"
    input Speed(integer) : "设置粒子的默认速度，单位为每秒单位数。"
    input SpreadSpeed(integer) : "设置扩散速度，单位为每秒单位数。"
    ]

@PointClass base(BaseEntityPoint, RenderFields) 
    color(255 0 0)
    color(200 0 0)
    iconsprite("editor/env_sun.vmt")
    line(255 255 0, targetname, target)
= env_sun: "一个控制和绘制天空中太阳效果的实体。"
    [
    target(target_destination) : "观察者实体" : : "用于确定太阳在天空盒中位置的实体名称。太阳应该沿着从该实体到env_sun实体的线排列。"
    use_angles(choices) : "使用角度" : 0 : "旧的定位env_sun的方法是将其指向一个目标。新的方法是指定角度。如果使用新方法，请将此属性设置为是。" =
        [
        0: "否"
        1: "是"
        ]

    pitch(integer) : "俯仰" : 0
    rendercolor(color255) : "太阳颜色（R G B）" : "100 80 80"
    overlaycolor(color255) : "覆盖颜色（R G B）" : "0 0 0" : "值为0 0 0将采用旧方式。"
    size(integer) : "大小" : 16
    overlaysize(integer) : "覆盖大小" : -1 : "值为-1表示覆盖将采用旧方式。"
    material(sprite) : "材质名称" : "sprites/light_glow02_add_noz" : "内部发光的材质。"
    overlaymaterial(sprite) : "覆盖材质名称" : "sprites/light_glow02_add_noz" : "覆盖发光的材质。"
    hdrcolorscale(float) : "HDR颜色比例。" : "0.5" : "在HDR模式下运行时用于乘以精灵颜色的浮点值。"

    // 输入
    input TurnOn(void) : "启用太阳渲染。"
    input TurnOff(void) : "禁用太阳渲染。"
    input SetColor(color255) : "更改太阳的颜色。格式：<红 0-255> <绿 0-255> <蓝 0-255>"
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/env_texturetoggle.vmt")
    line(255 255 0, targetname, target)
= env_texturetoggle: "一个允许你改变其他刷子建造实体或覆盖物上的纹理的实体。"
    [
    target(target_destination) : "目标刷子或覆盖物名称。"

    // 输入
    input IncrementTextureIndex(void) : "将目标刷子的当前纹理帧数增加一。"
    input SetTextureIndex(integer) : "将目标刷子的纹理帧数设置为指定的索引。"
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/env_tonemap_controller.vmt")
    color(200 0 0)
= env_tonemap_controller: "一个控制玩家HDR色调映射的实体。可以将其看作是控制玩家眼睛曝光的方法。"
    [
    spawnflags(flags)  =
        [
        1: "[1] 主控（如果存在多个env_tonemap_controllers，具有优先权）" : 0
        ]


    // 输入
    input SetTonemapScale(integer) : "设置玩家的色调映射比例。应该是0到2之间的值，其中0是眼睛完全闭合，1是使用未改变的自动曝光（默认），2是眼睛完全张开。"
    input BlendTonemapScale(string) : "从玩家当前的色调映射比例过渡到新的比例。参数语法如下：<目标色调映射比例> <过渡持续时间>。例如：'0.5 10'将在10秒内从当前色调映射比例过渡到0.5。色调映射比例是0到2之间的值，其中0是眼睛完全闭合，1是使用未改变的自动曝光（默认），2是眼睛完全张开。"
    input UseDefaultAutoExposure(void) : "恢复使用默认的色调映射自动曝光。"
    input SetAutoExposureMin(float) : "设置自定义色调映射自动曝光最小值。"
    input SetAutoExposureMax(float) : "设置自定义色调映射自动曝光最大值。"
    input SetBloomScale(float) : "设置自定义泛光比例。"
    input UseDefaultBloomScale(void) : "恢复使用默认的泛光比例。"
    input SetTonemapRate(float) : "设置自动曝光调整的速率。"
    input SetBloomExponent(float) : "设置自定义泛光指数。"
    input SetBloomSaturation(float) : "设置自定义泛光饱和度。"
    input SetTonemapPercentBrightPixels(float) : "设置高于某一亮度的像素百分比的目标。（默认：2）"
    input SetTonemapPercentTarget(float) : "为SetTonemapPercentBrightPixels设置自定义亮度目标。（默认：60）"
    input SetTonemapMinAvgLum(float) : "设置自定义色调映射参数（询问Alex详情；默认：3）。"
    ]

@PointClass base(BaseEntityPoint) 
    sphere(radius)
    iconsprite("editor/ficool2/env_viewpunch.vmt")
    color(200 200 0)
= env_viewpunch: "对玩家造成视角冲击。"
    [
    spawnflags(flags)  =
        [
        1: "[1] 对所有玩家造成冲击(忽略半径)" : 0
        2: "[2] 对空中的玩家造成冲击" : 0
        ]

    punchangle(angle) : "冲击角度" : "0 0 90" : "要应用的冲击角度。"
    radius(float) : "影响半径" : 500 : "此实体周围影响玩家的半径。"

    // 输入
    input ViewPunch(void) : "执行视角冲击。"
    ]

@PointClass base(BaseEntityPoint, EnableDisable) 
    studio("models/editor/cone_helper.mdl")
= env_weaponfire: "武器开火"
    [
    targetarc(float) : "目标弧度" : 40 : "实体将搜索目标的弧度(度)"
    targetrange(float) : "目标范围" : 3600 : "实体将搜索目标的距离(英寸)"
    filtername(filterclass) : "目标过滤器" : : "用于确定实体是否为有效目标的过滤器"
    damagemod(float) : "伤害修正" : "1.0" : "用于增加或减少每次射击的伤害量"
    weapontype(choices) : "武器类型" : 1 =
        [
        1: "突击步枪"
        2: "狩猎步枪"
        3: "自动霰弹枪"
        ]

    targetteam(choices) : "目标队伍" : 3 =
        [
        -1: "任何"
        2: "幸存者"
        3: "感染者"
        ]

    ignoreplayers(choices) : "忽略玩家" : 0 =
        [
        0: "否"
        1: "是"
        ]

    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/env_wind.vmt")
    color(200 0 0)
    sphere(windradius)
    sphere(windradiusinner)
= env_wind: "用于控制地图中风的实体。部分功能。"
    [
    minwind(integer) : "最小常规速度" : 20 : "闲置时风的最小速度。"
    maxwind(integer) : "最大常规速度" : 50 : "闲置时风的最大速度。"
    mingust(integer) : "最小阵风速度" : 100 : "阵风的最小速度。"
    maxgust(integer) : "最大阵风速度" : 250 : "阵风的最大速度。"
    mingustdelay(integer) : "最小阵风延迟" : 10 : "随机阵风之间的最小时间延迟。"
    maxgustdelay(integer) : "最大阵风延迟" : 20 : "随机阵风之间的最大时间延迟。"
    gustduration(integer) : "阵风持续时间" : 5 : "阵风持续的时间。"
    gustdirchange(integer) : "最大阵风方向变化(度)" : 20 : "由于阵风导致的风向最大变化量。"

    // 输出
    output OnGustStart(void) : "阵风开始时触发。"
    output OnGustEnd(void) : "阵风结束时触发。"
    ]

@PointClass base(BaseEntityPoint) 
    color(200 0 0)
    iconsprite("editor/ficool2/env_zoom.vmt")
    frustum(fov, 4, 250, 250 250 250, -1)
= env_zoom: "一个用于控制玩家FOV的实体。适用于控制玩家视角的场景，或者玩家可用的望远镜/望远镜等。"
    [
    rate(float) : "达到目标所需秒数" : "1.0" : "达到指定FOV所需的时间量。"
    fov(integer) : "目标FOV" : 75 : "此实体激活时应设定玩家FOV的FOV值。"
    spawnflags(flags)  =
        [
        1: "[1] 允许套装变焦" : 0
        ]


    // 输入
    input Zoom(void) : "开始控制玩家的FOV。"
    input UnZoom(void) : "停止控制玩家的FOV。"
    ]

@FilterClass base(BaseEntityPoint) 
    color(0 255 0)
    iconsprite("editor/ficool2/filter_base.vmt")
= filter_base: "基础过滤器，所有其他过滤器都基于此过滤器。此过滤器接受任何实体。"
    [
    negated(choices) : "过滤模式" : 0 : "如果设置为允许，只有符合条件的实体才能通过过滤器。如果设置为不允许，只有不符合条件的实体才能通过过滤器。" =
        [
        0: "允许符合条件的实体"
        1: "不允许符合条件的实体"
        ]


    // 输入
    input TestActivator(void) : "测试激活者是否通过过滤器并触发OnPass或OnFail输出。"

    // 输出
    output OnPass(void) : "如果激活者通过过滤器，则响应TestActivator输入触发。"
    output OnFail(void) : "如果激活者未通过过滤器，则响应TestActivator输入触发。"
    ]

@SolidClass base(BaseEntityBrush, EnableDisable) 
    line(255 255 0, targetname, fogname)
    line(255 255 0, targetname, postprocessname)
    line(255 255 0, targetname, colorcorrectionname)
= fog_volume: "用于控制地图中雾的实体。"
    [
    fogname(target_destination) : "雾名称" : : "与此体积关联的雾实体的名称。"
    postprocessname(target_destination) : "后处理名称" : : "与此体积关联的后处理实体的名称。"
    colorcorrectionname(target_destination) : "色彩校正名称" : : "与此体积关联的color_correction实体的名称。"
    ]

@SolidClass base(BaseEntity) 
    color(0 255 255)
    line(255 255 0, targetname, target)
= func_areaportal: "用于管理地图可见性的门户刷子。门户定义了地图中的区域，这些区域是地图中相互连接的空间。门户的两侧不能触碰到同一个区域，例如，一个甜甜圈形状的地图需要至少两个门户来将地图分为两个区域。一个线性地图可以用一个区域门户将地图分为两个区域。"
    [
    target(target_destination) : "关联门的名称" : : "(可选)一个prop_door_rotating或func_door的名称，其开/关状态控制此区域门户的开/关状态。"
    startopen(choices) : "初始状态" : 1 =
        [
        0: "关闭"
        1: "打开"
        ]

    portalversion(integer) readonly : "门户版本" : 1 : "(不要更改)。区分使用新引擎功能的地图和发货的HL2地图。"

    // 输入
    input Open(void) : "打开门户。当门户打开时可以透过看。"
    input Close(void) : "关闭门户。当门户关闭时不可透过看。"
    input Toggle(void) : "切换门户的开/关状态。"
    ]

@SolidClass base(BaseEntity) 
    color(0 128 255)
    sphere(FadeStartDist)
    sphere(FadeDist)
    line(255 255 0, targetname, target)
    line(255 255 0, targetname, backgroundbmodel)
= func_areaportalwindow: "用于优化地图可见性的实体。如果您用它们封闭一个区域，当观察者移动到指定距离远离它们时，它们将变得不透明，区域内的部分将不会被绘制。窗口刷子应该包围func_areaportal窗口，以便没有部分被窗口剔除。如果您使用可选的前景刷子，那么它应该包围窗口刷子。两个刷模型的绘制都将被禁用，因为areaportal将自己渲染它们。"
    [
    target(target_destination) : "渲染窗口" : : "作为窗口渲染的刷模型的名称。"
    fadestartdist(integer) : "淡入开始距离" : 128 : "当观察者距离小于此距离时，透明度设置为'TranslucencyLimit'。"
    fadedist(integer) : "淡出结束距离" : 512 : "当观察者在此距离时，门户变得实体并关闭。如果设置为零，窗口将始终关闭。"
    translucencylimit(float) : "透明度限制" : 0 : "这可以用来限制窗口的透明度，防止它变得完全不可见。这可以与不透明材料一起使用，充当窗口。"
    backgroundbmodel(target_destination) : "前景刷模型" : : "(可选)在淡入刷模型之后绘制的刷模型。这个模型应该是半透明的，这样你才能看穿它。"
    portalversion(integer) readonly : "门户版本" : 1 : "(不要更改)。区分使用新引擎功能的地图和发货的HL2地图。"

    // 输入
    input SetFadeStartDistance(integer) : "设置淡入开始距离。"
    input SetFadeEndDistance(integer) : "设置淡出结束距离。如果设置为零，这将强制窗口关闭。"
    ]

@SolidClass base(BaseEntityBrush) = func_clip_vphysics: "对vphysics来说是实体的刷子实体。"
    [
    filtername(filterclass) : "过滤器名称" : : "用于查看激活者是否与我碰撞的过滤器。有关更多解释，请参阅filter_activator_name。允许意味着'允许阻止'对于这个实体。"

    // 输入
    input Enable(void) : "启用此实体。"
    input Disable(void) : "禁用此实体。"
    ]

@SolidClass base(BaseEntityBrush, BModelParticleSpawner) 
    sphere(distmax)
= func_dustcloud: "在其体积内生成半透明尘埃云的刷子实体。"
    [
    alpha(integer) : "透明度" : 30
    sizemin(string) : "最小粒子大小" : 100
    sizemax(string) : "最大粒子大小" : 200
    ]

@SolidClass base(BaseEntityBrush, BModelParticleSpawner) 
    sphere(distmax)
= func_dustmotes: "在其体积内生成闪闪发光的尘埃微粒的刷子实体。"
    [
    alpha(integer) : "粒子透明度(0 - 255)" : 30 : "粒子的透明度。"
    sizemin(string) : "最小粒子大小" : 100 : "此值决定粒子可能的最小尺寸。"
    sizemax(string) : "最大粒子大小" : 200 : "此值决定粒子可能的最大尺寸。"
    fallspeed(integer) : "粒子下落速度" : : "粒子下落到地面的速度。"

    // 输入
    input TurnOn(void) : "开启。"
    input TurnOff(void) : "关闭。"
    ]

@SolidClass base(BaseEntityBrush, EnableDisable) = func_extinguisher: "一个接触到它的火焰实体将被删除的刷子实体。"
    [
    spawnflags(flags)  =
        [
        1: "[1] 火" : 1
        2: "[2] 酸" : 1
        4: "[4] 烟火" : 1
		]

	]

@PointClass base(BaseEntityPoint) 
    size(-16 -16 0, 16 16 72)
    color(127 127 127)
= func_ladderendpoint: "用于指定梯子端点的实体。该实体是功能性的，但已被更容易使用的func_useableladder实体所取代。仅为了向后兼容而保留！\n\n要有效，必须在关卡激活时，完整大小的玩家外壳在起点和终点之间的追踪不能被阻挡。角度决定了如果玩家按下+jump按钮，则玩家离开梯子的方向。\n\n注意：此实体在Counter-Strike: Source中不起作用。在CS:S中，请使用func_ladder。"
    [
    target(target_destination) : "Other" : : "梯子是在两个相互指向的func_ladderendpoint之间进行的。"
    ]

@SolidClass base(BaseEntityBrush, NavAttributeRegion) = func_nav_attribute_region: "一个刷子实体，用于在生成期间将属性应用于导航区域的区域。"
    [
    spawnflags(flags)  =
        [
        2: "[2] 空（无游荡者）" : 0
        32: "[32] 战斗站" : 0
        64: "[64] 终章" : 0
        128: "[128] 任务开始" : 0
        256: "[256] 战场" : 0
        2048: "[2048] 检查点" : 0
        8192: "[8192] 无暴徒" : 0
        32768: "[32768] 救援车辆" : 0
        65536: "[65536] 救援衣柜" : 0
        524288: "[524288] 无威胁" : 1
        1048576: "[1048576] 躺下" : 1
        ]

    ]

@SolidClass base(BaseEntityBrush, EnableDisable) = func_nav_avoidance_obstacle: "告诉机器人避开触摸其AABB的导航区域的刷子实体。"
    [
    ]

@SolidClass base(BaseEntityBrush, NavBlocker) = func_nav_blocker: "一个可以阻挡触摸其AABB的导航区域的刷子实体。"
    [
    startdisabled(choices) : "开始时禁用" : 0 =
        [
        0: "否"
        1: "是"
        ]

    ]

@SolidClass base(BaseEntityBrush) = func_nav_connection_blocker: "一个刷子实体，阻止在其体积中创建导航网格（在创建时）连接。"
    [
    ]

@SolidClass base(BaseEntity) 
    color(0 255 255)
= func_occluder: "用于管理地图中动态可见性的遮挡刷子。遮挡器用于动态确定哪些物体在它们后面，以防止尝试绘制它们。"
    [
    startactive(choices) : "初始状态" : 1 =
        [
        0: "非活动"
        1: "活动"
        ]


    // 输入
    input Deactivate(void) : "停用遮挡器，当非活动时，它可以被看穿。"
    input Activate(void) : "激活遮挡器。当活动时，它不能被看穿。"
    input Toggle(void) : "切换遮挡器的活动/非活动状态。"
    ]

@SolidClass base(BaseEntity) = func_precipitation: "一个刷子实体，在其体积内创建雨和雪。"
    [
    renderamt(integer) : "密度 (0-100%)" : 5 : "这是从刷子顶部下落的粒子的数量。然而，第一个粒子与第二个粒子之间的距离取决于刷子体积大小！稍后可以用'Alpha'输入来更改。"
    rendercolor(color255) : "颜色 (R G B)" : "100 100 100" : "添加到渲染为透明的精灵上的颜色（可能是雨和雪粒子）"
    preciptype(choices) : "降水类型" : 0 =
        [
        0: "雨"
        1: "雪"
        2: "灰"
        3: "降雪"
        4: "粒子雨"
        5: "粒子灰"
        6: "粒子暴雨"
        8: "粒子虫子"
        9: "粒子烟"
        ]

    spawnflags(flags)  =
        [
        ]


    // 输入
    input Alpha(integer) : "更改雨的密度，并可能添加额外的粒子效果，如雾或树叶。接受从-1到255的输入。"
    ]

@SolidClass base(BaseEntityBrush) = func_precipitation_blocker: "一个刷子实体，阻止在其体积内的雨和雪。"
    [
    ]

@SolidClass base(BaseEntityBrush, EnableDisable) = func_ragdoll_fader: "一个刷子实体，将淡出任何接触它的布娃娃。"
    [
    ]

@SolidClass base(BaseEntity) = func_smokevolume: "一个刷子实体，在其体积内产生烟雾粒子。"
    [
    spawnflags(flags)  =
        [
        1: "[1] 自发光" : 0
        ]

    color1(color255) : "粒子颜色1 (R G B)" : "255 255 255"
    color2(color255) : "粒子颜色2 (R G B)" : "255 255 255"
    material(material) : "材质" : "particle/particle_smokegrenade" : "粒子使用的材质"
    particledrawwidth(float) : "粒子绘制宽度 (单位)" : 120 : "粒子的大小，以单位/英寸为单位。"
    particlespacingdistance(float) : "粒子间距离 (单位)" : 80 : "体积内粒子之间的距离。数字越小，粒子越密集，过度绘制就越多。最好保持尽可能高，以免看起来不好。"
    densityrampspeed(float) : "密度坡度速度 (秒)" : 1 : "从密度0到密度1的时间，以秒为单位。"
    rotationspeed(float) : "旋转速度 (度/秒)" : 10 : "粒子应旋转的速度，以度每秒为单位。"
    movementspeed(float) : "移动速度 (单位/秒)" : 10 : "粒子应移动的速度，以单位/英寸每秒为单位。"
    density(float) : "密度 [0..1]" : 1
    maxdrawdistance(float) : "最大绘制距离 (0为无限制)" : 0

    // 输入
    input SetRotationSpeed(float) : "设置粒子旋转速度（以度每秒为单位）。"
    input SetMovementSpeed(float) : "设置粒子移动速度（以英寸每秒为单位）。"
    input SetDensity(float) : "设置粒子密度。范围应为0到1。"
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/func_timescale")
= func_timescale: "调整服务器和客户端的时间尺度。"
    [
    desiredtimescale(float) : "期望的时间尺度。" : "1.0" : "要混合的时间尺度，这是一个乘法值，1.0是正常时间，0.5是半速，2.0是双倍速度。"
    acceleration(float) : "每秒加速度" : "0.05" : "每秒变化的速度增加到最大。"
    minblendrate(float) : "每秒最小混合" : "0.1" : "从当前时间尺度混合到期望时间尺度时的每秒最小变化。"
    blenddeltamultiplier(float) : "每帧增量乘数" : "3.0" : "期望和当前之间的每帧增量乘以此值，得到每秒的最大变化。"

    // 输入
    input Start(void) : "开始混合到期望的时间尺度。"
    input Stop(void) : "停止并混合回默认时间尺度（1.0f）。"
    input Reset(void) : "立即重置为正常时间尺度（1.0f）。"
    ]

@PointClass base(BaseEntityPoint) 
    sweptplayerhull()
= func_useableladder: "半条命2的梯子。处理玩家自动上下梯子，以及使用+use上梯子。\n\n另见'info_ladder_dismount'，用于指定梯子自动下梯点。\n\n注意：此实体在Counter-Strike: Source中不起作用。使用func_ladder。"
    [
    spawnflags(flags)  =
        [
        1: "[1] 假梯子" : 0
        ]

    point0(vector) : "开始" : : "梯子的一个端点。"
    point1(vector) : "结束" : : "梯子的另一个端点。"
    startdisabled(choices) : "开始时禁用" : 0 =
        [
        0: "否"
        1: "是"
        ]

    laddersurfaceproperties(string) : "表面属性（可选）"

    // 输入
    input Enable(void) : "启用这个梯子。"
    input Disable(void) : "禁用这个梯子。"

// 输出
output OnPlayerGotOnLadder(void) : "当玩家开始使用梯子时触发。"
output OnPlayerGotOffLadder(void) : "当玩家停止使用梯子时触发。"
]

@SolidClass base(BaseEntityBrush) = func_vehicleclip: "充当影响车辆实体的功能性剪辑或障碍物。应使用tools/toolscontrolclip纹理。"
[

// 输入
input Kill(void) : "从世界中移除此实体"
input Enable(void) : "启用与车辆的碰撞"
input Disable(void) : "禁用与车辆的碰撞"
]

@PointClass base(BaseEntityPoint) 
line(255 255 255, targetname, master)
iconsprite("editor/game_end.vmt")
= game_end: "结束多人游戏的实体。"
[

// 输入
input EndGame(void) : "结束多人游戏。"
]

@PointClass base(BaseEntityPoint) 
iconsprite("editor/ficool2/game_gib_manager")
color(200 0 0)
= game_gib_manager: "用于控制世界中碎片数量的实体，出于性能考虑。"
[
maxpieces(integer) : "最大碎片数量" : -1 : "设置一次可以生成的最大碎片数量。（-1=无限制）"
maxpiecesdx8(integer) : "DX8下的最大碎片数量" : -1 : "设置在DX8下一次可以生成的最大碎片数量。（-1=使用最大碎片数量设置）"
allownewgibs(choices) : "允许生成新碎片" : 0 : "如果为真，当达到最大碎片数量时，新生成的碎片将移除最旧的碎片。如果为假，一旦达到碎片限制，将不会生成新碎片。" =
[
0: "否"
1: "是"
]


// 输入
input SetMaxPieces(integer) : "设置最大碎片数量。"
input SetMaxPiecesDX8(integer) : "设置DX8下的最大碎片数量。"
]

@PointClass base(BaseEntityPoint) 
line(255 255 255, targetname, master)
iconsprite("editor/ficool2/game_player_equip")
= game_player_equip: "一个给激活它的玩家提供装备的实体。使用时，向此实体添加新键，每个键是武器/物品的类名，相应的值是要给使用此实体的玩家的这些武器/物品的数量。\n\n自CSGO以来：\n如果没有设置'仅使用'的生成标志，那么玩家只需触摸此实体即可获得装备（或使用TriggerForAllPlayers输入）。如果设置了先剥离玩家的标志，玩家将在获得此实体指定的物品之前被剥离所有武器和物品（包括护甲）。"
[
spawnflags(flags)  =
[
1: "[1] 仅使用" : 0
]

]

@PointClass base(BaseEntityPoint) 
line(255 255 255, targetname, master)
iconsprite("editor/ficool2/game_player_team")
line(255 255 0, targetname, target)
color(200 0 0)
= game_player_team: "一个改变激活它的玩家队伍的实体。"
[
spawnflags(flags)  =
[
1: "[1] 触发时移除" : 0
2: "[2] 杀死玩家" : 0
4: "[4] 碎尸玩家" : 0
]

target(target_destination) : "代表所需队伍的game_team_master。"

// 输入
input Use(void) : "改变!activator玩家的队伍。"
]

@PointClass base(BaseEntityPoint) 
color(200 0 0)
iconsprite("editor/ficool2/game_ragdoll_manager")
= game_ragdoll_manager: "一个用于控制世界中布娃娃数量的实体，出于性能考虑。"
[
maxragdollcount(integer) : "最大布娃娃数量" : -1 : "设置世界中可以同时存在的最大布娃娃数量（如果它们被标记为淡出）。设置为-1如果你想使用默认值（g_ragdoll_maxcount）。"
maxragdollcountdx8(integer) : "DX8硬件上的最大布娃娃数量" : -1 : "设置DX8硬件上世界中可以同时存在的最大布娃娃数量（如果它们被标记为淡出）。设置为-1如果你想使用'最大布娃娃数量'的值。"
saveimportant(choices) : "保存重要的布娃娃" : 0 : "布娃娃管理器是否应确保不删除盟友布娃娃？" =
[
0: "否"
1: "是"
]


// 输入
input SetMaxRagdollCount(integer) : "设置最大布娃娃数量。"
input SetMaxRagdollCountDX8(integer) : "设置DX8硬件上的最大布娃娃数量。"
]

@PointClass base(BaseEntityPoint) 
iconsprite("editor/game_scavenge_progress_display")
= game_scavenge_progress_display
[
max(float) : "最大值" : 0 : "要收集的物品数量。"

// 输入
input TurnOn(void) : "打开显示。"
input TurnOff(void) : "关闭显示。"
input SetTotalItems(integer) : "设置目标（或总共）的搜寻物品数量。"
]

@PointClass base(BaseEntityPoint) 
line(255 255 255, targetname, master)
iconsprite("editor/ts2do/game_score")
color(200 0 0)
= game_score: "一个给激活它的玩家或特定队伍加分/扣分的实体。"
[
spawnflags(flags)  =
[
1: "[1] 允许负数" : 0
2: "[2] 队伍分数" : 0
]

points(integer) : "要添加的分数（+/-）" : 1

// 输入
input ApplyScore(void) : "给玩家加分。"
]

@PointClass base(BaseEntityPoint) 
line(255 255 255, targetname, master)
iconsprite("editor/game_text.vmt")
color(200 0 0)
= game_text: "在玩家屏幕上显示文本的实体。"
[
spawnflags(flags)  =
[
1: "[1] 所有玩家" : 0
]

message(string) : "消息文本" : : "要在屏幕上显示的消息。"
x(float) : "X位置" : -1 : "在玩家屏幕上绘制文本的水平位置。值应在0和1之间，其中0是屏幕的最左侧，1是最右侧。-1表示文本居中。"
y(float) : "Y位置" : "0.6" : "在玩家屏幕上绘制文本的垂直位置。值应在0和1之间，其中0是屏幕的顶部，1是底部。-1表示文本居中。"
effect(choices) : "文本效果" : 0 =
[
0: "淡入/淡出"
1: "字幕"
2: "扫出"
]

color(color255) : "文本颜色" : "100 100 100" : "文本的主色。"
color2(color255) : "过渡颜色" : "240 110 0" : "显示文本时使用的次要颜色。"
fadein(float) : "淡入时间/字符扫描时间" : "1.5" : "文本完全淡入应花费的时间。"
fadeout(float) : "淡出时间" : "0.5" : "在保持时间过后，文本开始淡出前应保持在屏幕上的时间。"
holdtime(float) : "保持时间" : "1.2" : "文本在淡入后应在屏幕上保持的时间，然后开始淡出。"
fxtime(float) : "扫描时间（仅限扫描效果）" : "0.25" : "如果'文本效果'设置为扫出，这是扫出文本中所有字母应花费的时间。"
channel(choices) : "文本频道" : 1 : "你可以一次在屏幕上有多达六条独立的game_text消息，存储在频道中。选择此文本应放置在哪个频道，这将覆盖该频道中已有的任何活动消息。" =
[
0: "频道0（警告：可能被HUD使用）"
1: "频道1"
2: "频道2"
3: "频道3"
4: "频道4"
5: "频道5（警告：可能被HUD使用）"
]


// 输入
input Display(void) : "显示消息文本。"
]

@PointClass base(BaseEntityPoint) 
color(200 0 0)
iconsprite("editor/ficool2/game_ui.vmt")
= game_ui: "当玩家看着它时用于覆盖玩家输入的实体。"
[
spawnflags(flags)  =
[
32: "[32] 冻结玩家" : 1
64: "[64] 隐藏武器" : 1
128: "[128] +使用停用" : 1
256: "[256] 跳跃停用" : 1
]

fieldofview(float) : "视野" : "-1.0" : "在确定玩家输入是否仍在控制之下时，视角检查中的容差量。1.0 = 正前方，0.0 = +/- 90度，-1.0 = 所有方向。如果玩家不在容差范围内，玩家将重新获得控制权。"

// 输入
input Deactivate(void) : "返回玩家控制。"
input Activate(string) : "获取玩家控制。"

// 输出
output PlayerOn(void) : "每当此实体开始控制玩家的输入时触发。"
output PlayerOff(void) : "每当此实体停止控制玩家的输入时触发。"
output PressedMoveLeft(void) : "每当玩家按下向左移动键时触发。"
output PressedMoveRight(void) : "每当玩家按下向右移动键时触发。"
output PressedForward(void) : "每当玩家按下向前移动键时触发。"
output PressedBack(void) : "每当玩家按下向后移动键时触发。"
output PressedAttack(void) : "每当玩家按下攻击键时触发。"
output PressedAttack2(void) : "每当玩家按下次要攻击键时触发。"
output UnpressedMoveLeft(void) : "每当玩家释放向左移动键时触发。"
output UnpressedMoveRight(void) : "每当玩家释放向右移动键时触发。"
output UnpressedForward(void) : "每当玩家释放向前移动键时触发。"
output UnpressedBack(void) : "每当玩家释放向后移动键时触发。"
output UnpressedAttack(void) : "每当玩家释放攻击键时触发。"
output UnpressedAttack2(void) : "每当玩家释放次要攻击键时触发。"
output XAxis(string) : "每当玩家输入的X轴改变时触发的输出。例如，当玩家按下向左移动键时为-1，当玩家按下向右移动键时为1，如果两者都没有，则为0。"
output YAxis(string) : "每当玩家输入的Y轴改变时触发的输出。例如，当玩家按下向后移动键时为-1，当玩家按下向前移动键时为1，如果两者都没有，则为0。"
output AttackAxis(string) : "每当玩家的攻击键状态改变时触发的输出。例如，当玩家按下攻击键时为1，否则为0。"
output Attack2Axis(string) : "每当玩家的次要攻击键状态改变时触发的输出。例如，当玩家按下次要攻击键时为1，否则为0。"
]

@PointClass base(BaseEntityPoint) 
iconsprite("editor/ficool2/game_weapon_manager")
= game_weapon_manager: "用于限制世界中特定武器类型数量的实体。在NPC快速生成、死亡并掉落武器的地方很有用。"
[
weaponname(string) : "武器类名" : : "要限制的武器类型的类名。"
maxpieces(integer) : "关卡中允许的最大数量" : 0 : "世界中允许的指定武器类型的最大数量。"
ammomod(float) : "弹药修正" : 1 : "武器掉落弹药量的修正值。"

// 输入
input SetMaxPieces(float) : "调整允许的最大武器数量。"
input SetAmmoModifier(float) : "调整弹药修正值。"
]

@SolidClass base(BaseEntityBrush) = game_zone_player: "用于计数区域内玩家数量的实体。"
    [

    // Inputs
    input CountPlayersInZone(void) : "计数区域内的玩家数量，并触发相应的输出。"

    // Outputs
    output OnPlayerInZone(void) : "每当计数发现有玩家在区域内时触发，以玩家为激活者。"
    output OnPlayerOutZone(void) : "每当计数发现有玩家在区域外时触发，以玩家为激活者。"
    output PlayersInCount(integer) : "计数后触发，并包含找到的区域内玩家数量。"
    output PlayersOutCount(integer) : "计数后触发，并包含找到的区域外玩家数量。"
    ]

@BaseClass base(BaseEntityPoint) = gibshooterbase
    [
    angles(angle) : "碎片方向（俯仰偏航翻滚）" : "0 0 0" : "碎片飞行的方向。"
    m_igibs(integer) : "碎片数量" : 3 : "每次激活时射出的总碎片数。"
    delay(float) : "射击间隔" : 0 : "射出每个碎片之间的延迟（秒）。如果为0，所有碎片同时射出。"
    gibangles(angle) : "碎片角度（俯仰偏航翻滚）" : "0 0 0" : "生成碎片的方向。"
    gibanglevelocity(float) : "最大角速度" : 0 : "碎片应旋转的速度（度/秒）。它们将在x和y轴上以这个速度的10%到100%旋转。"
    m_flvelocity(integer) : "碎片速度" : 200 : "射出碎片的速度。"
    m_flvariance(float) : "路径偏差" : "0.15" : "碎片射出方向的偏差程度。"
    m_flgiblife(float) : "碎片寿命" : 4 : "碎片存在的时间（秒），正负5%。"
    simulation(choices) : "模拟类型" : 0 : "用于射出的碎片的物理模拟类型。" =
        [
        0: "点"
        1: "物理"
        2: "布娃娃"
        ]

    lightingorigin(target_destination) : "光照源" : : "选择一个info_lighting来指定从哪里采样光照，用于这个射手生成的所有碎片，而不是它们自己的起源。"
    spawnflags(flags)  =
        [
        1: "[1] 可重复" : 0
        4: "[4] 严格移除生命周期后" : 0
        ]


    // Inputs
    input Shoot(void) : "强制碎片射手创建并射出一个碎片。"
    ]

@PointClass base(BaseEntityPoint) 
    color(200 0 0)
    iconsprite("editor/ficool2/hammer_updateignorelist")
    line(200 0 0, targetname, ignoredname01)
    line(200 0 0, targetname, ignoredname02)
    line(200 0 0, targetname, ignoredname03)
    line(200 0 0, targetname, ignoredname04)
    line(200 0 0, targetname, ignoredname05)
    line(200 0 0, targetname, ignoredname06)
    line(200 0 0, targetname, ignoredname07)
    line(200 0 0, targetname, ignoredname08)
    line(200 0 0, targetname, ignoredname09)
    line(200 0 0, targetname, ignoredname10)
    line(200 0 0, targetname, ignoredname11)
    line(200 0 0, targetname, ignoredname12)
    line(200 0 0, targetname, ignoredname13)
    line(200 0 0, targetname, ignoredname14)
    line(200 0 0, targetname, ignoredname15)
    line(200 0 0, targetname, ignoredname16)
= hammer_updateignorelist: "指定要被hammer_update_safe_entities控制台命令忽略的实体。在这里输入你希望排除在实体列表之外的目标名字。一个地图中可能存在多个这样的实体。"
    [
    ignoredname01(target_destination) : "被忽略的名字 01" : : "在hammer_update_safe_entities期间不将此实体的信息发送回hammer。"
    ignoredname02(target_destination) : "被忽略的名字 02" : : "在hammer_update_safe_entities期间不将此实体的信息发送回hammer。"
    ignoredname03(target_destination) : "被忽略的名字 03" : : "在hammer_update_safe_entities期间不将此实体的信息发送回hammer。"
    ignoredname04(target_destination) : "被忽略的名字 04" : : "在hammer_update_safe_entities期间不将此实体的信息发送回hammer。"
    ignoredname05(target_destination) : "被忽略的名字 05" : : "在hammer_update_safe_entities期间不将此实体的信息发送回hammer。"
    ignoredname06(target_destination) : "被忽略的名字 06" : : "在hammer_update_safe_entities期间不将此实体的信息发送回hammer。"
    ignoredname07(target_destination) : "被忽略的名字 07" : : "在hammer_update_safe_entities期间不将此实体的信息发送回hammer。"
    ignoredname08(target_destination) : "被忽略的名字 08" : : "在hammer_update_safe_entities期间不将此实体的信息发送回hammer。"
    ignoredname09(target_destination) : "被忽略的名字 09" : : "在hammer_update_safe_entities期间不将此实体的信息发送回hammer。"
    ignoredname10(target_destination) : "被忽略的名字 10" : : "在hammer_update_safe_entities期间不将此实体的信息发送回hammer。"
    ignoredname11(target_destination) : "被忽略的名字 11" : : "在hammer_update_safe_entities期间不将此实体的信息发送回hammer。"
    ignoredname12(target_destination) : "被忽略的名字 12" : : "在hammer_update_safe_entities期间不将此实体的信息发送回hammer。"
    ignoredname13(target_destination) : "被忽略的名字 13" : : "在hammer_update_safe_entities期间不将此实体的信息发送回hammer。"
    ignoredname14(target_destination) : "被忽略的名字 14" : : "在hammer_update_safe_entities期间不将此实体的信息发送回hammer。"
    ignoredname15(target_destination) : "被忽略的名字 15" : : "在hammer_update_safe_entities期间不将此实体的信息发送回hammer。"
    ignoredname16(target_destination) : "被忽略的名字 16" : : "在hammer_update_safe_entities期间不将此实体的信息发送回hammer。"
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/info_ambient_mob")
= info_ambient_mob: "用于环境移动群的起始/结束位置。（使用时需谨慎！）"
    [
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/info_ambient_mob_end")
= info_ambient_mob_end: "环境移动群的结束位置。"
    [
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/info_ambient_mob_start")
= info_ambient_mob_start: "环境移动群的潜在起始位置。"
    [
    ]

@PointClass base(BaseEntityPoint) 
    studio("models/editor/camera.mdl")
    iconsprite("editor/info_camera_link.vmt")
    line(255 255 0, targetname, target)
    line(255 255 0, targetname, target, targetname, Pointcamera)
= info_camera_link: "一个可以使用点摄像机为实体使用的材料渲染图像的实体。要创建材料，请在 .vmt 文件中使用特殊标识符 _rt_Camera 作为 $baseTexture（或任何你想要的纹理，比如 envmap 等），然后将 'target' 字段连接到使用该材料的实体，将 'PointCamera' 字段连接到你想要显示在该实体材料上的点摄像机。"
    [
    target(target_destination) : "使用 _rt_camera 材料的实体"
    pointcamera(target_destination) : "摄像机名称" : : "地图中点摄像机实体的名称，材料将从此处渲染。"

    // 输入
    input SetCamera(string) : "设置要使用的摄像机。参数应为地图中点摄像机实体的名称。"
    ]

@SolidClass base(BaseEntityBrush) 
    line(255 255 255, targetname, landmark)
= info_changelevel: "标记级别变化的实体。\n在两个地图中放置 info_landmark 实体，标记每个地图中的“相同”位置。\n提示和技巧：要在下一个级别中触发事件，使用 OnLevelChange 输出在当前级别中打开一个 env_global。在下一个级别中创建一个 logic_auto 检查由 env_global 设置的状态。\n\n要控制哪些实体通过级别转换，请创建一个或多个 info_transitions 并给它们命名为地标的名称。任何在 info_transition(s) 内的实体都将转移到下一个地图。"
    [
    map(string) : "新地图名称"
    landmark(target_destination) : "地标名称"
    spawnflags(flags)  =
        [
        2: "[2] 禁用触摸" : 0
        4: "[4] 到前一章" : 0
        ]


    // 输出
    output OnChangeLevel(void) : "当级别变化时触发。"
    ]

@PointClass base(BaseEntityPoint) 
    halfgridsnap
    iconsprite("editor/info_constraint_anchor.vmt")
    color(128 128 128)
    line(128 128 128, targetname, parentname)
= info_constraint_anchor: "用于将约束附着到实体上的局部位置的实体。通常约束会附着到物体的质心。将所需的约束附着到这个实体，然后将这个实体作为父级附着到你想要应用约束的实体上。"
    [
    massscale(float) : "质量比例" : 1 : "在约束求解器中用于缩放此体的质量的量。"
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/info_director")
= info_director
    [

    // 输入
    input PanicEvent(void) : "当发生导演应该知道的重大事件时触发。"
    input ForceSurvivorPositions(void) : "使每个幸存者站在 info_survivor_position 上。"
    input ReleaseSurvivorPositions(void) : "允许幸存者再次自由移动。"
    input FireConceptToAny(string) : "向任何能够说出它的幸存者发出语音概念。"
    input StartIntro(void) : "当介绍开始时触发。"
    input FinishIntro(void) : "当介绍结束时触发。"
    input EnableTankFrustration(void) : "可用于启用坦克挫败计量器。"
    input DisableTankFrustration(void) : "可用于禁用坦克挫败计量器。"
    input ScriptedPanicEvent(string) : "当自定义恐慌事件想要发生时触发。"
    input ForcePanicEvent(void) : "无论发生什么，都触发恐慌事件。"
    input EndCustomScriptedStage(void) : "结束自定义脚本阶段。"
    input IncrementTeamScore(integer) : "增加一个队伍的得分。（2=幸存者，3=感染者）"
    input BeginScript(string) : "开始导演脚本"
    input EndScript(void) : "结束导演脚本"
    input CreateNewJournal(string) : "创建新日志"
    input WriteToJournal(string) : "向 I/O 日志中添加任务"
    input ExecuteJournal(string) : "执行指定日志中的所有任务"

    // 输出
    output OnGameplayStart(void) : "当地图加载、所有玩家加入并开始游戏时触发。"
    output OnPanicEventFinished(void) : "当恐慌事件结束时触发。"
    output OnCustomPanicStageFinished(void) : "当自定义恐慌事件或自定义终章的每个阶段结束时触发。"
    output OnTeamScored(void) : "当一个队伍在搜集模式中放置了搜集物品时触发。"
    output OnScavengeRoundStart(void) : "当搜集回合开始时触发。"
    output OnScavengeOvertimeStart(void) : "计时器已用尽，游戏进入加时赛。"
    output OnScavengeOvertimeCancel(void) : "时钟增加了时间，结束了加时赛。"
    output OnScavengeTimerExpired(void) : "时间已用尽，游戏未进入加时赛。"
    output OnScavengeIntensityChanged(integer) : "强度级别已改变。1 = 最高强度，数字越大强度越低。"
    output OnUserDefinedScriptEvent1(void) : "从 Squirrel 脚本中触发的通用用户定义事件。"
    output OnUserDefinedScriptEvent2(void) : "从 Squirrel 脚本中触发的通用用户定义事件。"
    output OnUserDefinedScriptEvent3(void) : "从 Squirrel 脚本中触发的通用用户定义事件。"
    output OnUserDefinedScriptEvent4(void) : "从 Squirrel 脚本中触发的通用用户定义事件。"
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/info_target.vmt")
= info_elevator_floor: "电梯楼层高度目标。"
    [

    // 输出
    output OnReachedFloor(void) : "当电梯到达此楼层时触发。"
    ]

@PointClass base(BaseEntityPoint, EnableDisable) 
    iconsprite("editor/info_game_event_proxy.vmt")
    sphere(range)
= info_game_event_proxy: "一旦被看到，就会生成一个简单的游戏事件的实体。"
    [
    event_name(string) : "事件名称" : : "从 modevents.res 中按名称触发的事件"
    range(float) : "范围" : 512 : "玩家必须接近的距离才能生成事件。"
    spawnflags(flags)  =
        [
        1: "[1] 自动检测可见性" : 1
        ]


    // 输入
    input GenerateGameEvent(void) : "生成我的游戏事件。（此实体作为主题发送）"
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/info_gamemode.vmt")
= info_gamemode: "游戏模式触发器。"
    [

    // 输出
    output OnCoop(void) : "当地图在合作游戏中生成时触发。"
    output OnVersus(void) : "当地图在对抗游戏中生成时触发。"
    output OnSurvival(void) : "当地图在生存游戏中生成时触发。"
    output OnScavenge(void) : "当地图在搜集模式中生成时触发。"
    output OnCoopPostIO(void) : "在由 OnCoop 生成的所有实体 IO 完成后触发。"
    output OnVersusPostIO(void) : "在由 OnVersus 生成的所有实体 IO 完成后触发"
    output OnSurvivalPostIO(void) : "在由 OnSurvival 生成的所有实体 IO 完成后触发"
    output OnScavengePostIO(void) : "在由 OnScavenge 生成的所有实体 IO 完成后触发"
    output OnScavengeMatchStart(void) : "在搜集比赛的第一次地图加载时触发。不会在回合重启时触发。"
    output OnNavAnalyze(void) : "当地图使用 -navanalyze 命令行加载时触发。"
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/info_target.vmt")
= info_goal_infected_chase: "一个吸引感染者的实体，就像管状炸弹一样，让他们在片尾时有事可做。将此实体与逃生车辆或 func_tracktrain 层次化，使地图中的所有感染者都追逐它！"
    [

    // 输入
    input Enable(void) : "开始吸引地图中的所有感染者。"
    input Disable(void) : "停止吸引感染者。"
    ]

@PointClass base(BaseEntityPoint, HintNode) 
    studio("models/editor/node_hint.mdl")
    color(255 255 255)
    sphere(radius)
= info_hint: "一个不用于导航的提示。它们不会进入节点图，也不会落到地面。使用这些为 NPC 提供一些空间上下文，比如“如果找不到玩家，就看这里”或“向这个地方扔石头”。"
    [
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/info_intermission")
    color(0 180 0)
    line(255 255 0, targetname, target)
= info_intermission: "定义一个死亡玩家在复活前漂浮等待的中场休息点的实体。"
    [
    target(target_destination) : "看向的实体" : : "死亡玩家在此休息点中场休息时面向的实体名称。"
    ]

@PointClass base(BaseEntityPoint) 
    studioprop()
    iconsprite("editor/info_item_position")
= info_item_position: "代表地图上可能的物品位置的实体。脚本可以搜索这些实体并使用它们在不同游戏模式中生成对象。"
    [
    model(studio) : "辅助模型"
    group(integer) : "组" : 0 : "组号"
    rarity(choices) : "稀有度" : 0 : "此位置的物品稀有度" =
        [
        0: "常见"
        1: "偶尔"
        2: "稀有"
        ]

    replace01(string) : "替换" : : "这是一个替换参数。它的格式为 $variable value。所有在生成组内有 $variable 的实体都会被替换成 value 的内容。例如：$color 255 0 0"
    replace02(string) : "替换" : : "这是一个替换参数。它的格式为 $variable value。所有在生成组内有 $variable 的实体都会被替换成 value 的内容。例如：$color 255 0 0"
    replace03(string) : "替换" : : "这是一个替换参数。它的格式为 $variable value。所有在生成组内有 $variable 的实体都会被替换成 value 的内容。例如：$color 255 0 0"
    replace04(string) : "替换" : : "这是一个替换参数。它的格式为 $variable value。所有在生成组内有 $variable 的实体都会被替换成 value 的内容。例如：$color 255 0 0"
    replace05(string) : "替换" : : "这是一个替换参数。它的格式为 $variable value。所有在生成组内有 $variable 的实体都会被替换成 value 的内容。例如：$color 255 0 0"
    replace06(string) : "替换" : : "这是一个替换参数。它的格式为 $variable value。所有在生成组内有 $variable 的实体都会被替换成 value 的内容。例如：$color 255 0 0"
    replace07(string) : "替换" : : "这是一个替换参数。它的格式为 $variable value。所有在生成组内有 $variable 的实体都会被替换成 value 的内容。例如：$color 255 0 0"
    replace08(string) : "替换" : : "这是一个替换参数。它的格式为 $variable value。所有在生成组内有 $variable 的实体都会被替换成 value 的内容。例如：$color 255 0 0"
    replace09(string) : "替换" : : "这是一个替换参数。它的格式为 $variable value。所有在生成组内有 $variable 的实体都会被替换成 value 的内容。例如：$color 255 0 0"
    replace10(string) : "替换" : : "这是一个替换参数。它的格式为 $variable value。所有在生成组内有 $variable 的实体都会被替换成 value 的内容。例如：$color 255 0 0"

    // 输入
    input SetGroup(integer) : "设置组号。"
    input SetRarity(integer) : "设置稀有度。"
    ]

@PointClass base(BaseEntityPoint) 
    studio("models/survivors/survivor_biker.mdl")
= info_l4d1_survivor_spawn: "生成一个L4D1幸存者"
    [
    character(choices) : "角色" : 5 : "在这里生成哪个幸存者" =
        [
        4: "Bill"
        5: "Zoey"
        6: "Francis"
        7: "Louis"
        ]


    // 输入
    input SpawnSurvivor(void) : "生成幸存者"
    ]

@PointClass base(BaseEntityPoint) 
    size(-16 -16 0, 16 16 4)
    line(255 255 255, targetname, target)
    color(255 128 255)
= info_ladder_dismount: "用于处理彼此靠得太近的多个梯子的端点的实体。"
    [
    target(target_destination) : "梯子名称" : : "如果多个梯子靠近多个端点，请使用此功能以防止它们相互干扰。"
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/info_landmark")
    color(200 0 0)
= info_landmark: "作为过渡到另一个级别的地标的实体。下一个地图中应该有一个对应的info_landmark实体。实体将相对于info_landmark实体过渡到下一个级别。"
    [
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/info_map_parameters")
= info_map_parameters: "L4D或CS地图参数。用于设置哪些队伍可以购买物品，以及C4炸弹的爆炸半径。"
    [
    painpilldensity(float) : "止痛药密度" : "6.48" : "每平方100码的止痛药密度。"
    molotovdensity(float) : "燃烧瓶密度" : "6.48" : "每平方100码的燃烧瓶密度。"
    pipebombdensity(float) : "管状炸弹密度" : "6.48" : "每平方100码的管状炸弹密度。"
    pistoldensity(float) : "手枪密度" : "6.48" : "每平方100码的手枪密度。"
    gascandensity(float) : "汽油桶密度" : "6.48" : "每平方100码的汽油桶密度。"
    oxygentankdensity(float) : "氧气罐密度" : "6.48" : "每平方100码的氧气罐密度。"
    propanetankdensity(float) : "丙烷罐密度" : "6.48" : "每平方100码的丙烷罐密度。"
    itemclusterrange(float) : "物品聚集范围" : 50 : "彼此如此接近的同类清理物品被视为单个'聚集'以用于人口目的。"
    finaleitemclustercount(integer) : "终章物品聚集数量" : 3 : "在终章中将填充多少物品聚集。"
    ammodensity(float) : "弹药堆密度" : "6.48" : "每平方100码的弹药堆密度"
    meleeweapondensity(float) : "近战武器密度" : "6.48" : "每平方100码的近战武器密度"
    adrenalinedensity(float) : "肾上腺素密度" : "6.48" : "每平方100码的肾上腺素密度"
    defibrillatordensity(float) : "除颤器密度" : "3.0" : "每平方100码的除颤器密度"
    vomitjardensity(float) : "呕吐罐密度" : "6.48" : "每平方100码的呕吐罐密度"
    upgradepackdensity(float) : "弹药升级包密度" : "1.0" : "每平方100码的弹药升级包密度"
    chainsawdensity(float) : "超级武器密度" : "1.0" : "每平方100码的电锯和榴弹发射器密度"
    configurableweapondensity(float) : "可配置武器生成密度" : "-1.0" : "weapon_spawn实体的密度，-1表示生成所有"
    configurableweaponclusterrange(float) : "可配置武器聚集范围" : 100 : "彼此如此接近的weapon_spawn实体被视为单个'聚集'以用于人口目的"
    magnumdensity(float) : "马格南手枪生成密度" : "-1.0" : "weapon_magnum_spawn实体的密度，-1表示生成所有"
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/info_map_parameters_versus")
= info_map_parameters_versus: "专为L4D对抗模式设计的地图参数。"
    [
    painpilldensity(float) : "止痛药密度" : "6.48" : "每平方100码的止痛药密度"
    molotovdensity(float) : "燃烧瓶密度" : "6.48" : "每平方100码的燃烧瓶密度"
    pipebombdensity(float) : "管状炸弹密度" : "6.48" : "每平方100码的管状炸弹密度"
    pistoldensity(float) : "手枪密度" : "6.48" : "每平方100码的手枪密度"
    gascandensity(float) : "汽油桶密度" : "6.48" : "每平方100码的汽油桶密度"
    oxygentankdensity(float) : "氧气罐密度" : "6.48" : "每平方100码的氧气罐密度"
    propanetankdensity(float) : "丙烷罐密度" : "6.48" : "每平方100码的丙烷罐密度"
    itemclusterrangey(float) : "物品聚集范围" : 50 : "彼此如此接近的同类清理物品被视为单个'聚集'以用于人口目的。"
    finaleitemclustercount(integer) : "终章物品聚集数量" : 3 : "在终章中将填充多少物品聚集。"
    ammodensity(float) : "弹药堆密度" : "6.48" : "每平方100码的弹药堆密度"
    meleeweapondensityy(float) : "近战武器密度" : "6.48" : "每平方100码的近战武器密度"
    adrenalinedensityy(float) : "肾上腺素密度" : "6.48" : "每平方100码的肾上腺素密度"
    defibrillatordensityy(float) : "除颤器密度" : "2.50" : "每平方100码的除颤器密度"
    vomitjardensityy(float) : "呕吐罐密度" : "6.48" : "每平方100码的呕吐罐密度"
    upgradepackdensityy(float) : "弹药升级包密度" : "1.0" : "每平方100码的弹药升级包密度"
    chainsawdensityy(float) : "超级武器密度" : "1.0" : "每平方100码的电锯和榴弹发射器密度"
    configurableweapondensityy(float) : "可配置武器生成密度" : "-1.0" : "weapon_spawn实体的密度，-1表示生成所有"
    configurableweaponclusterrangey(float) : "可配置武器聚集范围" : 100 : "彼此如此接近的weapon_spawn实体被视为单个'聚集'以用于人口目的"
    magnumdensityy(float) : "马格南手枪生成密度" : "-1.0" : "weapon_spawn实体的密度，-1表示生成所有"

    // 输入
    input UpdateCvars(void) : "将此实体的值填充到cvars中进行调整"
    ]

@PointClass base(BaseEntityPoint, HintNode) 
    studio("models/editor/air_node_hint.mdl")
    color(232 171 8)
    line(255 255 255, nodeid, TargetNode)
    sphere(radius)
= info_node_air_hint: "一个为飞行NPC设计的导航节点，包含一些对感兴趣的NPC有用的上下文信息。提示可能指示可以被窥视的窗口，或者可以被评论的感兴趣物品。许多提示节点是特定于NPC的，因此在提示选择列表中使用诸如'乌鸦：飞向点'之类的命名约定是有帮助的。提示节点的角度指示NPC执行提示行为时应面向的方向。"
    [
    nodeheight(integer) : "节点高度" : 0
    ]

@PointClass base(BaseEntityPoint, HintNode) 
    studio("models/editor/climb_node.mdl")
    color(153 215 103)
    sphere(radius)
= info_node_climb: "一个供AI导航使用的爬行节点。只适用于可以爬行的NPC。"
    [
    ]

@PointClass base(BaseEntityPoint, HintNode) 
    studio("models/editor/ground_node_hint.mdl")
    color(232 219 8)
    sphere(radius)
= info_node_hint: "一个为地面移动NPC设计的导航节点，包含一些对感兴趣的NPC有用的上下文信息。提示可能指示可以从中向外看的窗口，或者可以被评论的感兴趣物品。许多提示节点是特定于NPC的，因此在提示选择列表中使用诸如'乌鸦：飞向点'之类的命名约定是有帮助的。提示节点的角度指示NPC执行提示行为时应面向的方向。\n\n重要的是要理解脚本（如scripted_sequence和scripted_schedule）和info_hint实体之间的区别。脚本召唤NPC到特定的提示点来表演它们的角色，而提示为AI提供它们用来执行行为的上下文信息。提示需要NPC中的代码支持，而脚本是通用的，可能只需要播放动画。如果行为由AI驱动，使用提示；如果行为由地图驱动，使用脚本。"
    [

    // 输出
    output OnNPCStartedUsing(string) : "当NPC到达此节点并开始使用时触发。传递NPC。"
    output OnNPCStoppedUsing(string) : "当NPC停止使用此节点时触发。传递NPC。"
    ]

@PointClass base(BaseEntityPoint) 
    color(220 180 0)
    line(255 255 255, nodeid, StartNode, nodeid, EndNode)
    iconsprite("editor/info_node_link.vmt")
= info_node_link: "两个导航节点之间的动态连接。您可以指定起始和结束节点的节点ID，然后可以使用实体I/O来打开和关闭连接。这可以用来因地图中的某些事件（如桥梁的创建/销毁等）在节点图中创建或销毁连接。"
    [
    startnode(node_dest) : "起始节点ID" : : "节点连接一端的节点ID。"
    endnode(node_dest) : "结束节点ID" : : "节点连接一端的节点ID。"
    initialstate(choices) : "初始状态" : 1 =
        [
        0: "关闭"
        1: "打开"
        ]

    linktype(choices) : "连接类型" : 1 =
        [
        1: "地面"
        2: "跳跃"
        4: "飞行"
        8: "攀爬"
        16: "爬行"
        ]

    allowuse(target_name_or_class) : "关闭时允许通过" : : "即使节点关闭也允许通过的实体或类别"
    spawnflags(flags)  =
        [
        1: "[1] 强制人类连接" : 0
        2: "[2] 强制小型居中连接" : 0
        4: "[4] 强制宽人类连接" : 0
        8: "[8] 强制微小连接" : 0
        16: "[16] 强制宽短连接" : 0
        32: "[32] 强制中等连接" : 0
        64: "[64] 强制微小居中连接" : 0
        128: "[128] 强制大型连接" : 0
        256: "[256] 强制大型居中连接" : 0
        512: "[512] 强制中等高连接" : 0
        ]


    // 输入
    input TurnOn(void) : "打开连接。"
    input TurnOff(void) : "关闭连接。"
    ]

@PointClass base(BaseEntityPoint) 
    wirebox(mins, maxs)
    color(220 180 0)
    iconsprite("editor/info_node_link_controller.vmt")
    line(255 255 255, targetname, allowuse)
= info_node_link_controller: "一个控制所有穿过控制器体积的节点之间连接的实体。这允许通过体积来批量启用/禁用所有节点连接。"
    [
    mins(vector) : "最小值" : "-8 -32 -36"
    maxs(vector) : "最大值" : "8 32 36"
    initialstate(choices) : "初始状态" : 1 =
        [
        0: "关闭"
        1: "打开"
        ]

    useairlinkradius(choices) : "使用更大半径（用于空中连接）" : 0 : "如果这个控制器旨在控制空中连接，请将其设置为'是'。空中连接使用更大的搜索半径，所以将其保留为'否'可能会错过一些空中连接。" =
        [
        0: "否"
        1: "是"
        ]

    allowuse(target_name_or_class) : "关闭时允许通过" : : "即使节点关闭也允许通过的实体或类别"
    invertallow(choices) : "反转排除规则" : 0 : "允许的实体是唯一在设置为'是'时不允许的实体" =
        [
        0: "否"
        1: "是"
        ]


    // 输入
    input TurnOn(void) : "打开连接。"
    input TurnOff(void) : "关闭连接。"
    input SetAllowed(string) : "更改关闭时允许的通行"
    input SetInvert(integer) : "更改反转排除规则"
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/info_npc_spawn_destination.vmt")
= info_npc_spawn_destination: "NPC生成目的地。（有关更多信息，请咨询npc_template_maker帮助）"
    [
    reusedelay(float) : "重用延迟" : 1 : "在此目的地生成NPC后，该目的地再次可供选择的延迟。"
    renamenpc(target_source) : "新NPC名称" : : "如果NPC在这个目的地生成，将该NPC的targetname更改为此。"

    // 输出
    output OnSpawnNPC(void) : "当NPC在这个目的地生成时触发。"
    ]

@PointClass base(BaseEntityPoint) 
    color(200 0 0)
    iconsprite("editor/ficool2/info_null.vmt")
= info_null: "一个在生成时立即移除的实体。用作聚光灯目标很有用。"
    [
    ]

@PointClass base(BaseEntityPoint) 
    size(-1 -1 0, 1 1 1)
    color(80 150 225)
    studio("models/editor/overlay_helper_box.mdl")
    sphere(fademindist)
    sphere(fademaxdist)
    overlay()
= info_overlay: "一个在世界上放置覆盖层的实体。"
    [
    material(material) : "材质" : : "用于覆盖层的材质。"
    sides(sidelist) : "刷子面" : : "这个覆盖层应用于的刷子面。"
    renderorder(choices) : "渲染顺序" : 0 : "较高的值在较低的值之后渲染。这个值可以是0-3。" =
        [
        0: "第一"
        1: "第二"
        2: "第三"
        3: "第四"
        ]

    startu(float) : "U起点" : "0.0" : "在覆盖材质中定义X轴起始位置的值，介于0-1之间。"
    endu(float) : "U终点" : "1.0" : "在覆盖材质中定义X轴结束位置的值，介于0-1之间。"
    startv(float) : "V起点" : "0.0" : "在覆盖材质中定义Y轴起始位置的值，介于0-1之间。"
    endv(float) : "V终点" : "1.0" : "在覆盖材质中定义Y轴结束位置的值，介于0-1之间。"
    basisorigin(vector) readonly : "覆盖基础原点（只读）" : : "覆盖层应用于的表面的中心。"
    basisu(vector) : "覆盖基础U" : : "材质的X轴指向的方向。"
    basisv(vector) : "覆盖基础V" : : "材质的Y轴指向的方向。"
    basisnormal(vector) readonly : "覆盖基础正常（只读）" : : "覆盖层应用于的表面的法线。"
    uv0(vector) : "覆盖点1" : : "覆盖层的角落1。"
    uv1(vector) : "覆盖点2" : : "覆盖层的角落2。"
    uv2(vector) : "覆盖点3" : : "覆盖层的角落3。"
    uv3(vector) : "覆盖点4" : : "覆盖层的角落4。"
    fademindist(float) : "开始淡出距离" : -1 : "覆盖层开始淡出的距离（<0 = 使用fademaxdist）。"
    fademaxdist(float) : "结束淡出距离" : 0 : "覆盖层可见的最大距离（0 = 不淡出）。"
    ]

@PointClass base(BaseEntityPoint, Reflection) 
    studio("models/editor/cone_helper.mdl")
    line(255 255 255, targetname, cpoint1)
    line(255 255 255, targetname, cpoint2)
    line(255 255 255, targetname, cpoint3)
    line(255 255 255, targetname, cpoint4)
    line(255 255 255, targetname, cpoint5)
    line(255 255 255, targetname, cpoint6)
    line(255 255 255, targetname, cpoint7)
    line(255 255 255, targetname, cpoint8)
    line(255 255 255, targetname, cpoint9)
    line(255 255 255, targetname, cpoint10)
    line(255 255 255, targetname, cpoint11)
    line(255 255 255, targetname, cpoint12)
    line(255 255 255, targetname, cpoint13)
    line(255 255 255, targetname, cpoint14)
    line(255 255 255, targetname, cpoint15)
    line(255 255 255, targetname, cpoint16)
    line(255 255 255, targetname, cpoint17)
    line(255 255 255, targetname, cpoint18)
    line(255 255 255, targetname, cpoint19)
    line(255 255 255, targetname, cpoint20)
    line(255 255 255, targetname, cpoint21)
    line(255 255 255, targetname, cpoint22)
    line(255 255 255, targetname, cpoint23)
    line(255 255 255, targetname, cpoint24)
    line(255 255 255, targetname, cpoint25)
    line(255 255 255, targetname, cpoint26)
    line(255 255 255, targetname, cpoint27)
    line(255 255 255, targetname, cpoint28)
    line(255 255 255, targetname, cpoint29)
    line(255 255 255, targetname, cpoint30)
    line(255 255 255, targetname, cpoint31)
    line(255 255 255, targetname, cpoint32)
    line(255 255 255, targetname, cpoint33)
    line(255 255 255, targetname, cpoint34)
    line(255 255 255, targetname, cpoint35)
    line(255 255 255, targetname, cpoint36)
    line(255 255 255, targetname, cpoint37)
    line(255 255 255, targetname, cpoint38)
    line(255 255 255, targetname, cpoint39)
    line(255 255 255, targetname, cpoint40)
    line(255 255 255, targetname, cpoint41)
    line(255 255 255, targetname, cpoint42)
    line(255 255 255, targetname, cpoint43)
    line(255 255 255, targetname, cpoint44)
    line(255 255 255, targetname, cpoint45)
    line(255 255 255, targetname, cpoint46)
    line(255 255 255, targetname, cpoint47)
    line(255 255 255, targetname, cpoint48)
    line(255 255 255, targetname, cpoint49)
    line(255 255 255, targetname, cpoint50)
    line(255 255 255, targetname, cpoint51)
    line(255 255 255, targetname, cpoint52)
    line(255 255 255, targetname, cpoint53)
    line(255 255 255, targetname, cpoint54)
    line(255 255 255, targetname, cpoint55)
    line(255 255 255, targetname, cpoint56)
    line(255 255 255, targetname, cpoint57)
    line(255 255 255, targetname, cpoint58)
    line(255 255 255, targetname, cpoint59)
    line(255 255 255, targetname, cpoint60)
    line(255 255 255, targetname, cpoint61)
    line(255 255 255, targetname, cpoint62)
    line(255 255 255, targetname, cpoint63)
    color(200 200 0)
= info_particle_system: "生成粒子系统的实体，粒子系统是使用粒子编辑器构建的。"
    [
    effect_name(string) : "粒子系统名称"
    start_active(choices) : "开始时激活？" : 0 =
        [
        0: "否"
        1: "是"
        ]

    render_in_front(choices) : "前置渲染" : 0 : "允许粒子在所有其他物体前渲染的技巧。" =
        [
        0: "否"
        1: "是"
        ]

    cpoint1(target_destination) : "控制点1" : : "如果设置，效果的控制点1将位于此实体的位置。"
    cpoint2(target_destination) : "控制点2" : : "如果设置，效果的控制点2将位于此实体的位置。如果控制点1未设置，将忽略此设置。"
    cpoint3(target_destination) : "控制点3" : : "如果设置，效果的控制点3将位于此实体的位置。如果控制点2未设置，将忽略此设置。"
    cpoint4(target_destination) : "控制点4" : : "如果设置，效果的控制点4将位于此实体的位置。如果控制点3未设置，将忽略此设置。"
    cpoint5(target_destination) : "控制点5" : : "如果设置，效果的控制点5将位于此实体的位置。如果控制点4未设置，将忽略此设置。"
    cpoint6(target_destination) : "控制点6" : : "如果设置，效果的控制点6将位于此实体的位置。如果控制点5未设置，将忽略此设置。"
    cpoint7(target_destination) : "控制点7" : : "如果设置，效果的控制点7将位于此实体的位置。如果控制点6未设置，将忽略此设置。"
    cpoint8(target_destination) : "控制点8" : : "如果设置，效果的控制点8将位于此实体的位置。如果控制点7未设置，将忽略此设置。"
    cpoint9(target_destination) : "控制点9" : : "如果设置，效果的控制点9将位于此实体的位置。如果控制点8未设置，将忽略此设置。"
    cpoint10(target_destination) : "控制点10" : : "如果设置，效果的控制点10将位于此实体的位置。如果控制点9未设置，将忽略此设置。"
    cpoint11(target_destination) : "控制点11" : : "如果设置，效果的控制点11将位于此实体的位置。如果控制点10未设置，将忽略此设置。"
    cpoint12(target_destination) : "控制点12" : : "如果设置，效果的控制点12将位于此实体的位置。如果控制点11未设置，将忽略此设置。"
    cpoint13(target_destination) : "控制点13" : : "如果设置，效果的控制点13将位于此实体的位置。如果控制点12未设置，将忽略此设置。"
    cpoint14(target_destination) : "控制点14" : : "如果设置，效果的控制点14将位于此实体的位置。如果控制点13未设置，将忽略此设置。"
    cpoint15(target_destination) : "控制点15" : : "如果设置，效果的控制点15将位于此实体的位置。如果控制点14未设置，将忽略此设置。"
    cpoint16(target_destination) : "控制点16" : : "如果设置，效果的控制点16将位于此实体的位置。如果控制点15未设置，将忽略此设置。"
    cpoint17(target_destination) : "控制点17" : : "如果设置，效果的控制点17将位于此实体的位置。如果控制点16未设置，将忽略此设置。"
    cpoint18(target_destination) : "控制点18" : : "如果设置，效果的控制点18将位于此实体的位置。如果控制点17未设置，将忽略此设置。"
    cpoint19(target_destination) : "控制点19" : : "如果设置，效果的控制点19将位于此实体的位置。如果控制点18未设置，将忽略此设置。"
    cpoint20(target_destination) : "控制点20" : : "如果设置，效果的控制点20将位于此实体的位置。如果控制点19未设置，将忽略此设置。"
    cpoint21(target_destination) : "控制点21" : : "如果设置，效果的控制点21将位于此实体的位置。如果控制点10未设置，将忽略此设置。"
    cpoint22(target_destination) : "控制点22" : : "如果设置，效果的控制点22将位于此实体的位置。如果控制点21未设置，将忽略此设置。"
    cpoint23(target_destination) : "控制点23" : : "如果设置，效果的控制点23将位于此实体的位置。如果控制点22未设置，将忽略此设置。"
    cpoint24(target_destination) : "控制点24" : : "如果设置，效果的控制点24将位于此实体的位置。如果控制点23未设置，将忽略此设置。"
    cpoint25(target_destination) : "控制点25" : : "如果设置，效果的控制点25将位于此实体的位置。如果控制点24未设置，将忽略此设置。"
    cpoint26(target_destination) : "控制点26" : : "如果设置，效果的控制点26将位于此实体的位置。如果控制点25未设置，将忽略此设置。"
    cpoint27(target_destination) : "控制点27" : : "如果设置，效果的控制点27将位于此实体的位置。如果控制点26未设置，将忽略此设置。"
    cpoint28(target_destination) : "控制点28" : : "如果设置，效果的控制点28将位于此实体的位置。如果控制点27未设置，将忽略此设置。"
    cpoint29(target_destination) : "控制点29" : : "如果设置，效果的控制点29将位于此实体的位置。如果控制点28未设置，将忽略此设置。"
    cpoint30(target_destination) : "控制点30" : : "如果设置，效果的控制点30将位于此实体的位置。如果控制点29未设置，将忽略此设置。"
    cpoint31(target_destination) : "控制点31" : : "如果设置，效果的控制点31将位于此实体的位置。如果控制点30未设置，将忽略此设置。"
    cpoint32(target_destination) : "控制点32" : : "如果设置，效果的控制点32将位于此实体的位置。如果控制点31未设置，将忽略此设置。"
    cpoint33(target_destination) : "控制点33" : : "如果设置，效果的控制点33将位于此实体的位置。如果控制点32未设置，将忽略此设置。"
    cpoint34(target_destination) : "控制点34" : : "如果设置，效果的控制点34将位于此实体的位置。如果控制点33未设置，将忽略此设置。"
    cpoint35(target_destination) : "控制点35" : : "如果设置，效果的控制点35将位于这个实体的位置。如果控制点34没有设置，这将被忽略。"
    cpoint36(target_destination) : "控制点36" : : "如果设置，效果的控制点36将位于这个实体的位置。如果控制点35没有设置，这将被忽略。"
    cpoint37(target_destination) : "控制点37" : : "如果设置，效果的控制点37将位于这个实体的位置。如果控制点36没有设置，这将被忽略。"
    cpoint38(target_destination) : "控制点38" : : "如果设置，效果的控制点38将位于这个实体的位置。如果控制点37没有设置，这将被忽略。"
    cpoint39(target_destination) : "控制点39" : : "如果设置，效果的控制点39将位于这个实体的位置。如果控制点38没有设置，这将被忽略。"
    cpoint40(target_destination) : "控制点40" : : "如果设置，效果的控制点40将位于这个实体的位置。如果控制点39没有设置，这将被忽略。"
    cpoint41(target_destination) : "控制点41" : : "如果设置，效果的控制点41将位于这个实体的位置。如果控制点40没有设置，这将被忽略。"
    cpoint42(target_destination) : "控制点42" : : "如果设置，效果的控制点42将位于这个实体的位置。如果控制点41没有设置，这将被忽略。"
    cpoint43(target_destination) : "控制点43" : : "如果设置，效果的控制点43将位于这个实体的位置。如果控制点42没有设置，这将被忽略。"
    cpoint44(target_destination) : "控制点44" : : "如果设置，效果的控制点44将位于这个实体的位置。如果控制点43没有设置，这将被忽略。"
    cpoint45(target_destination) : "控制点45" : : "如果设置，效果的控制点45将位于这个实体的位置。如果控制点44没有设置，这将被忽略。"
    cpoint46(target_destination) : "控制点46" : : "如果设置，效果的控制点46将位于这个实体的位置。如果控制点45没有设置，这将被忽略。"
    cpoint47(target_destination) : "控制点47" : : "如果设置，效果的控制点47将位于这个实体的位置。如果控制点46没有设置，这将被忽略。"
    cpoint48(target_destination) : "控制点48" : : "如果设置，效果的控制点48将位于这个实体的位置。如果控制点47没有设置，这将被忽略。"
    cpoint49(target_destination) : "控制点49" : : "如果设置，效果的控制点49将位于这个实体的位置。如果控制点48没有设置，这将被忽略。"
    cpoint50(target_destination) : "控制点50" : : "如果设置，效果的控制点50将位于这个实体的位置。如果控制点49没有设置，这将被忽略。"
    cpoint51(target_destination) : "控制点51" : : "如果设置，效果的控制点51将位于这个实体的位置。如果控制点50没有设置，这将被忽略。"
    cpoint52(target_destination) : "控制点52" : : "如果设置，效果的控制点52将位于这个实体的位置。如果控制点51没有设置，这将被忽略。"
    cpoint53(target_destination) : "控制点53" : : "如果设置，效果的控制点53将位于这个实体的位置。如果控制点52没有设置，这将被忽略。"
    cpoint54(target_destination) : "控制点54" : : "如果设置，效果的控制点54将位于这个实体的位置。如果控制点53没有设置，这将被忽略。"
    cpoint55(target_destination) : "控制点55" : : "如果设置，效果的控制点55将位于这个实体的位置。如果控制点54没有设置，这将被忽略。"
    cpoint56(target_destination) : "控制点56" : : "如果设置，效果的控制点56将位于这个实体的位置。如果控制点55没有设置，这将被忽略。"
cpoint57(target_destination) : "控制点57" : : "如果设置，效果的控制点57将位于这个实体的位置。如果没有设置控制点56，这将被忽略。"
cpoint58(target_destination) : "控制点58" : : "如果设置，效果的控制点58将位于这个实体的位置。如果没有设置控制点57，这将被忽略。"
cpoint59(target_destination) : "控制点59" : : "如果设置，效果的控制点59将位于这个实体的位置。如果没有设置控制点58，这将被忽略。"
cpoint60(target_destination) : "控制点60" : : "如果设置，效果的控制点60将位于这个实体的位置。如果没有设置控制点59，这将被忽略。"
cpoint61(target_destination) : "控制点61" : : "如果设置，效果的控制点61将位于这个实体的位置。如果没有设置控制点60，这将被忽略。"
cpoint62(target_destination) : "控制点62" : : "如果设置，效果的控制点62将位于这个实体的位置。如果没有设置控制点61，这将被忽略。"
cpoint63(target_destination) : "控制点63" : : "如果设置，效果的控制点63将位于这个实体的位置。如果没有设置控制点62，这将被忽略。"
cpoint1_parent(integer) : "控制点1的父级" : 0 : "如果设置且非零，效果的控制点1将使用这个控制点作为其父级。"
cpoint2_parent(integer) : "控制点2的父级" : 0 : "如果设置且非零，效果的控制点2将使用这个控制点作为其父级。"
cpoint3_parent(integer) : "控制点3的父级" : 0 : "如果设置且非零，效果的控制点3将使用这个控制点作为其父级。"
cpoint4_parent(integer) : "控制点4的父级" : 0 : "如果设置且非零，效果的控制点4将使用这个控制点作为其父级。"
cpoint5_parent(integer) : "控制点5的父级" : 0 : "如果设置且非零，效果的控制点5将使用这个控制点作为其父级。"
cpoint6_parent(integer) : "控制点6的父级" : 0 : "如果设置且非零，效果的控制点6将使用这个控制点作为其父级。"
cpoint7_parent(integer) : "控制点7的父级" : 0 : "如果设置且非零，效果的控制点7将使用这个控制点作为其父级。"

// 输入
input Start(void) : "告诉粒子系统开始发射。"
input Stop(void) : "告诉粒子系统停止发射。"
]

@PointClass base(BaseEntityPoint) 
studio("models/editor/cone_helper.mdl")
= info_particle_target: "一个作为粒子系统控制点目标的实体。"
[
]

@PointClass base(BaseEntityPoint) 
color(0 255 0)
studio("models/editor/playerstart.mdl")
= info_player_start: "此实体指明玩家将在哪个位置和面向哪个方向出生。在地图中可以放置任意数量的info_player_start实体，用于在地图的隔离部分中工作。当地图中存在多个info_player_start实体时，将一个设置为'Master'的出生标志，以指示在运行整个地图时应使用哪一个。"
[
spawnflags(flags)  =
[
1: "[1] Master（如果存在多个info_player_starts则具有优先权）" : 0
]

]

@PointClass base(BaseEntityPoint) 
decal()
studio("models/editor/decal_helper.mdl")
sphere(distance)
= info_projecteddecal: "一个投射世界（或道具）上贴花的实体。如果贴花没有目标名称，它将在关卡加载时立即应用。如果指定了名称，则在接收到'Activate'输入之前不会应用。"
[
texture(material) : "纹理" : : "用于贴花的纹理。"
distance(float) : "距离" : 64 : "从原点到投射贴花的距离。"

// 输入
input Activate(void) : "强制贴花立即应用到世界上。"
]

@PointClass base(BaseEntityPoint) 
sphere(radius)
color(220 180 0)
iconsprite("editor/info_radial_link_controller.vmt")
= info_radial_link_controller: "此实体自动切断通过其半径范围的节点连接。如果它移动，它将恢复这些连接。"
[
radius(float) : "半径" : 120
]

@PointClass base(BaseEntityPoint, Origin) 
iconsprite("editor/info_remarkable")
= info_remarkable: "世界中的一个对象，以至于看到它的角色会说一个TLK_REMARK概念"
[
contextsubject(string) : "主题上下文" : : "在看到这个对象时触发的TLK_REMARK中放入SUBJECT上下文的文本。"
]

@PointClass base(BaseEntityPoint) 
studio("models/survivors/survivor_coach.mdl")
color(255 100 100)
= info_survivor_position: "在逃离终场战时放置幸存者的点"
[
order(integer) : "顺序" : 1 : "根据人们登机的顺序确定位置的索引。（1-4）"
survivorname(string) : "幸存者名称" : : "强制这个幸存者使用这个位置（Zoey, Louis等等）。"
survivorintrosequence(string) : "幸存者介绍序列" : : "当介绍开始时播放的序列。"
gamemode(choices) : "游戏模式" : : "仅在特定游戏模式下使用这个位置（合作，对抗，生存，搜刮）。" =
[
"coop": "合作"
"versus": "对抗"
"survival": "生存"
"scavenge": "搜刮"
]

survivorconcept(string) : "幸存者概念" : : "当幸存者被移动到这里时播放的响应规则概念。"
hideweapons(choices) : "隐藏武器" : 0 : "当锁定到这个位置时隐藏幸存者的武器。" =
[
0: "否"
1: "是"
]


// 输入
input SetViewControl(string) : "如果一个幸存者被分配到这个位置，设置他们的视角到一个point_viewcontrol点。"
]

@PointClass base(BaseEntityPoint) 
color(0 255 0)
studio("models/survivors/survivor_coach.mdl")
= info_survivor_rescue: "幸存者救援点"
[
rescueeyepos(vecline) : "等待救援的幸存者的眼睛位置"
model(studio) : "模型" : "models/editor/playerstart.mdl"
]

@PointClass base(BaseEntityPoint) 
iconsprite("editor/info_target.vmt")
studio("models/editor/axis_helper.mdl")
halfgridsnap
= info_target: "一个什么也不做的实体。作为其他实体的定位实体非常有用（例如env_beam的终点）。"
[
spawnflags(flags)  =
[
1: "[1] 传输给客户端（遵守PVS）" : 0
2: "[2] 始终传输给客户端（忽略PVS）" : 0
]

]

@PointClass base(BaseEntityPoint) 
halfgridsnap
studio("models/editor/axis_helper.mdl")
iconsprite("editor/info_target_instructor_hint.vmt")
= info_target_instructor_hint: "一个通用目标，被复制到客户端用于hud提示目标。"
[
]

@PointClass base(BaseEntityPoint) 
studio("models/editor/playerstart.mdl")
= info_teleport_destination: "一个本身不做任何事情的实体，但可以用来指定trigger_teleport实体的目的地。也可以使用info_target代替。"
[
]

@PointClass base(BaseEntityPoint, EnableDisable) 
iconsprite("editor/info_zombie_border")
= info_zombie_border: "没有僵尸会在这个实体后面生成。"
[
]

@PointClass base(BaseEntityPoint) 
studio("models/infected/common_male01.mdl")
= info_zombie_spawn: "用于生成僵尸的实体。"
[
population(string) : "人口" : "默认" : "选择僵尸人口。"
offer_tank(choices) : "提供生成的坦克给PZs" : 0 =
[
0: "否"
1: "是"
]


// 输入
input SpawnZombie(void) : "现在生成一个僵尸。"
input StartleZombie(string) : "惊吓僵尸（仅限女巫）。可选地传递一个幸存者的名字来攻击。"

// 输出
output OnSpawnNormal(void) : "当生成器创建一个普通感染者时触发。"
output OnSpawnSmoker(void) : "当生成器创建一个Smoker时触发。"
output OnSpawnBoomer(void) : "当生成器创建一个Boomer时触发。"
output OnSpawnHunter(void) : "当生成器创建一个Hunter时触发。"
output OnSpawnWitch(void) : "当生成器创建一个Witch时触发。"
output OnSpawnTank(void) : "当生成器创建一个Tank时触发。"
output OnSpawnSpitter(void) : "当生成器创建一个Spitter时触发。"
output OnSpawnJockey(void) : "当生成器创建一个Jockey时触发。"
output OnSpawnCharger(void) : "当生成器创建一个Charger时触发。"
]

@PointClass base(BaseEntityPoint) 
decal()
line(128 128 128, targetname, applyentity)
studio("models/editor/decal_helper.mdl")
= infodecal: "一个在世界上放置贴花的实体。如果贴花没有目标名称，它将在关卡加载时立即应用。如果指定了名称，则在接收到'Activate'输入之前不会应用。"
[
texture(material) : "纹理" : : "用于贴花的纹理。"
lowpriority(choices) : "低优先级" : 0 : "允许贴花在需要时被其他贴花覆盖。这也使得贴花不会持续存在于保存游戏中。" =
[
0: "否"
1: "是"
]

applyentity(target_destination) : "影响的实体" : : "如果指定，贴花将只应用于这个实体。"

// 输入
input Activate(void) : "强制贴花立即应用到世界上。"
]

@MoveClass base(BaseEntityPoint, RopeKeyFrame) 
studio("models/editor/axis_helper_thick.mdl")
iconsprite("editor/keyframe_rope")
animator()
keyframe()
= keyframe_rope: "一个标记绳索中某个点的节点实体。传统上，一个move_rope用来开始链条，然后跟着一个或多个keyframe_rope实体。然而，它们是完全可以互换的。"
[
]

@KeyframeClass base(BaseEntityPoint, KeyFrame) 
line(255 255 255, targetname, nextkey)
size(-6 -6 -6, 6 6 6)
color(255 200 0)
iconsprite("editor/vizzys/keyframe_track")
keyframe()
= keyframe_track: "动画关键帧"
[
]

@PointClass base(BaseEntityPoint, BaseLight, LightPattern, LightShadows) 
sphere(_fifty_percent_distance)
sphere(_zero_percent_distance)
sphere(_distance)
color(255 255 0)
light()
iconsprite("editor/light.vmt")
= light: "一个不可见的全方向光源。"
[
spawnflags(flags)  =
[
1: "[1] 最初是暗的" : 0
]

	]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/ficool2/light_dynamic.vmt")
    sphere(distance)
    lightcone()
    line(255 255 255, targetname, target)
= light_dynamic: "一个随时间变化的不可见光源。"
    [
    target(target_destination) : "指向实体" : : "地图中动态光将指向的实体的名称。"
    _light(color255) : "光线颜色" : "255 255 255 200"
    brightness(integer) : "光亮度" : 0
    _inner_cone(integer) : "内（亮）角度" : 30
    _cone(integer) : "外（衰减）角度" : 45
    pitch(integer) : "俯仰角" : -90
    distance(float) : "最大距离" : 120 : "光线允许投射的距离，以单位为单位。"
    spotlight_radius(float) : "聚光灯端半径" : 80 : "这是光线在击中物体时的半径，以单位为单位。"
    style(choices) : "外观" : 0 =
        [
        0: "正常"
        10: "荧光闪烁"
        2: "慢速，强脉冲"
        11: "慢脉冲，无黑色"
        5: "温和脉冲"
        1: "闪烁 A"
        6: "闪烁 B"
        3: "蜡烛 A"
        7: "蜡烛 B"
        8: "蜡烛 C"
        4: "快速闪光"
        9: "慢速闪光"
        ]

    spawnflags(flags)  =
        [
        1: "[1] 不照亮世界（更好的性能）" : 0
        2: "[2] 不照亮模型" : 0
        4: "[4] 添加位移Alpha" : 0
        8: "[8] 减去位移Alpha" : 0
        ]


    // 输入
    input Color(color255) : "设置光源的渲染颜色（R G B）。"
    input brightness(integer) : "设置光亮度。"
    input distance(float) : "设置最大光距离。"
    input _inner_cone(integer) : "设置内（亮）角度。"
    input _cone(integer) : "设置外（衰减）角度。"
    input spotlight_radius(float) : "设置聚光灯端点的半径。"
    input style(integer) : "改变光源样式（参见外观字段中可能的值）。"
    input TurnOn(void) : "关闭光源。"
    input TurnOff(void) : "开启光源。"
    input Toggle(void) : "切换光源的开/关。"
    ]

@PointClass base(BaseEntityPoint, Angles, LightPattern, LightShadows) 
    iconsprite("editor/light_environment.vmt")
    color(255 255 0)
    lightprop("models/editor/spot.mdl")
= light_environment: "设置来自太阳和天空的光线的颜色和角度。"
    [
    pitch(angle_negative_pitch) : "俯仰角" : 0 : "来自太阳光线的向下俯仰角。0是水平的，-90是垂直向下。"
    _light(color255) : "亮度" : "255 255 255 200"
    _ambient(color255) : "环境光" : "255 255 255 20"
    _lighthdr(color255) : "亮度HDR" : "-1 -1 -1 1"
    _lightscalehdr(float) : "亮度缩放HDR" : 1 : "在为HDR编译时缩放光线的量。"
    _ambienthdr(color255) : "环境光HDR" : "-1 -1 -1 1"
    _ambientscalehdr(float) : "环境光缩放HDR" : 1 : "在为hdr编译时缩放环境光的量。"
    sunspreadangle(float) : "太阳扩散角" : 5 : "太阳用于投射柔和阴影的角度范围。数字越大越分散。5是一个很好的起始值。"
    ]

@PointClass base(BaseEntityPoint, BaseLight, LightPattern, LightShadows) 
    sphere(_fifty_percent_distance)
    sphere(_zero_percent_distance)
    sphere(_distance)
    color(255 255 0)
    lightprop("models/editor/spot.mdl")
    lightcone()
    line(255 255 255, targetname, target)
= light_spot: "一个不可见且方向性的聚光灯。"
    [
    target(target_destination) : "指向实体" : : "聚光灯将指向的地图中的实体的名称。这将覆盖聚光灯的角度。"
    _inner_cone(integer) : "内（亮）角度" : 30
    _cone(integer) : "外（衰减）角度" : 45
    _exponent(integer) : "焦点" : 1
    pitch(angle_negative_pitch) : "俯仰角" : -90
    spawnflags(flags)  =
        [
        1: "[1] 最初是暗的" : 0
        ]

    ]

@PointClass base(BaseEntityPoint) 
    color(200 0 0)
    iconsprite("editor/logic_active_autosave.vmt")
= logic_active_autosave: "用于寻找机会自动保存的实体。"
    [
    minimumhitpoints(integer) : "启动生命值" : 30 : "如果玩家的生命值下降到此水平以下，开始寻找保存机会。"
    triggerhitpoints(integer) : "触发生命值" : 75 : "如果开始寻找保存机会，当生命值达到此水平时保存。"
    timetotrigget(float) : "触发时间" : 0 : "如果大于0，尝试在放弃前进行保存的时间。"
    dangeroustime(float) : "危险时间" : 10 : "如果为0，就自动保存。否则，使用此时间阈值进行危险自动保存。"

    // 输入
    input Enable(void) : "启用实体"
    input Disable(void) : "启用实体"
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/logic_auto.vmt")
    color(0 100 250)
= logic_auto: "在地图生成时触发输出。如果设置了'触发后移除'标志，logic_auto在触发后会被删除。它可以设置在触发前检查全局状态。这允许您根据之前地图中发生的事件来触发事件。"
    [
    spawnflags(flags)  =
        [
        1: "[1] 触发后移除" : 1
        ]

    globalstate(choices) : "读取全局状态" : : "如果设置，这指定了一个全局状态在触发前检查。OnMapSpawn输出只有在全局状态被设置时才会触发。" =
        [
        "": "--- 无 ---"
        "is_console": "游戏正在游戏机上运行"
        "is_pc": "游戏正在PC上运行"
        ]


    // 输出
    output OnMapSpawn(void) : "由于任何原因加载地图时触发。"
    output OnNewGame(void) : "加载地图以开始新游戏时触发。"
    output OnLoadGame(void) : "从保存的游戏加载地图时触发。"
    output OnMapTransition(void) : "由于级别转换而加载地图时触发。"
    output OnBackgroundMap(void) : "加载地图作为主菜单的背景时触发。"
    output OnMultiNewMap(void) : "仅在多人游戏中，加载新地图时触发。"
    output OnMultiNewRound(void) : "仅在多人游戏中，开始新回合时触发。仅在使用基于回合的游戏玩法的多人游戏中触发。"
    output OnDemoMapSpawn(void) : "在演示模式下加载地图时触发。"
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/logic_autosave.vmt")
    color(200 0 0)
= logic_autosave: "用于强制自动保存的实体。"
    [
    newlevelunit(choices) : "强制新关卡单元" : 0 : "如果设置，保存将丢弃来自前几个关卡的任何保存数据，以减少保存文件的大小。如果玩家没有办法返回到前面的关卡，才能安全使用。" =
        [
        0: "否"
        1: "是"
        ]

    minimumhitpoints(integer) : "最小生命值" : 0 : "玩家的生命值少于此数值时，不进行危险保存。"
    minhitpointstocommit(integer) : "提交所需最小生命值" : 0 : "提交保存所需的最小生命值。如果您至少有最小生命值，那么将进行保存，但当自动保存计时器到期时，只有当您至少有最小提交生命值时，自动保存才会被保留。"

    // 输入
    input Save(void) : "强制自动保存。"
    input SaveDangerous(float) : "强制进行危险自动保存为autosavedangerous.sav。如果玩家在传递的秒数后仍然存活，它将替换标准自动保存。"
    input SetMinHitpointsThreshold(integer) : "将MinimumHitPoints设置为此。"
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/logic_branch.vmt")
    color(0 100 250)
= logic_branch: "测试一个布尔值并根据该值是真是假触发输出。使用此实体在两组潜在事件之间进行选择。"
    [
    initialvalue(choices) : "初始值" : 0 : "布尔值的初始值（0或1）。" =
        [
        0: "0（假）"
        1: "1（真）"
        ]


    // 输入
    input SetValue(bool) : "设置布尔值而不进行比较。使用此来为未来的测试保留一个值。"
    input SetValueTest(bool) : "设置布尔值并进行测试，根据新值触发OnTrue或OnFalse。"
    input Toggle(void) : "切换布尔值在真和假之间。"
    input ToggleTest(void) : "切换布尔值并进行测试，根据新值触发OnTrue或OnFalse。"
    input Test(void) : "测试输入值并根据值触发OnTrue或OnFalse。"

    // 输出
    output OnTrue(bool) : "当输入值为真（非零）时触发。"
    output OnFalse(bool) : "当输入值为假（零）时触发。"
    ]

@PointClass base(BaseEntityPoint) 
    color(0 100 250)
    iconsprite("editor/logic_branch_listener.vmt")
    line(255 255 0, targetname, branch01)
    line(255 255 0, targetname, branch02)
    line(255 255 0, targetname, branch03)
    line(255 255 0, targetname, branch04)
    line(255 255 0, targetname, branch05)
    line(255 255 0, targetname, branch06)
    line(255 255 0, targetname, branch07)
    line(255 255 0, targetname, branch08)
    line(255 255 0, targetname, branch09)
	line(255 255 0, targetname, branch10)
	line(255 255 0, targetname, branch11)
	line(255 255 0, targetname, branch12)
	line(255 255 0, targetname, branch13)
	line(255 255 0, targetname, branch14)
	line(255 255 0, targetname, branch15)
	line(255 255 0, targetname, branch16)
= logic_branch_listener: "包含一系列logic_branch实体，并在任何logic_branch的状态发生变化时触发输出。\n\n当一组条件都满足时，此实体用于触发事件。"
    [
    branch01(target_destination) : "逻辑分支 01" : : "一个或多个logic_branch的名称（允许使用通配符）。"
    branch02(target_destination) : "逻辑分支 02" : : "一个或多个logic_branch的名称（允许使用通配符）。"
    branch03(target_destination) : "逻辑分支 03" : : "一个或多个logic_branch的名称（允许使用通配符）。"
    branch04(target_destination) : "逻辑分支 04" : : "一个或多个logic_branch的名称（允许使用通配符）。"
    branch05(target_destination) : "逻辑分支 05" : : "一个或多个logic_branch的名称（允许使用通配符）。"
    branch06(target_destination) : "逻辑分支 06" : : "一个或多个logic_branch的名称（允许使用通配符）。"
    branch07(target_destination) : "逻辑分支 07" : : "一个或多个logic_branch的名称（允许使用通配符）。"
    branch08(target_destination) : "逻辑分支 08" : : "一个或多个logic_branch的名称（允许使用通配符）。"
    branch09(target_destination) : "逻辑分支 09" : : "一个或多个logic_branch的名称（允许使用通配符）。"
    branch10(target_destination) : "逻辑分支 10" : : "一个或多个logic_branch的名称（允许使用通配符）。"
    branch11(target_destination) : "逻辑分支 11" : : "一个或多个logic_branch的名称（允许使用通配符）。"
    branch12(target_destination) : "逻辑分支 12" : : "一个或多个logic_branch的名称（允许使用通配符）。"
    branch13(target_destination) : "逻辑分支 13" : : "一个或多个logic_branch的名称（允许使用通配符）。"
    branch14(target_destination) : "逻辑分支 14" : : "一个或多个logic_branch的名称（允许使用通配符）。"
    branch15(target_destination) : "逻辑分支 15" : : "一个或多个logic_branch的名称（允许使用通配符）。"
    branch16(target_destination) : "逻辑分支 16" : : "一个或多个logic_branch的名称（允许使用通配符）。"

    // 输入
    input Test(void) : "测试列表中所有logic_branch的状态，并触发相应的输出。"
    input UniqueStateOn(void) : "将此输入实体特有的logic_branch的状态设置为1。这将生成一个添加到监听器的分支。"
    input UniqueStateOff(void) : "将此输入实体特有的logic_branch的状态设置为0。这将生成一个添加到监听器的分支。"
    input UniqueStateSet(bool) : "将此输入实体特有的logic_branch的状态设置为提供的值。这将生成一个添加到监听器的分支。"
    input UniqueStateToggle(void) : "切换此输入实体特有的logic_branch的状态。这将生成一个添加到监听器的分支。"

    // 输出
    output OnAllTrue(void) : "当列表中所有的logic_branch都变为真时触发。"
    output OnAllFalse(void) : "当列表中所有的logic_branch都变为假时触发。"
    output OnMixed(void) : "当列表中的一个logic_branch状态改变，但有些是真有些是假时触发。"
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/logic_case.vmt")
    color(0 100 250)
= logic_case: "将输入值与多达16个预设值进行比较。如果输入值与任何预设值相同，则触发相应的输出。\n\n例如：如果Case01设置为2，Case02设置为5，输入值为5，则将触发OnCase02输出。\n\n此实体还可通过PickRandom输入用来从多个随机目标中选择。将随机触发至少连接了一个其他实体的OnCase输出。"
    [
    case01(string) : "情况 01" : : "如果输入值与此匹配，则触发相应的输出。对于PickRandom或PickRandomShuffle不是必需的。"
    case02(string) : "情况 02" : : "如果输入值与此匹配，则触发相应的输出。对于PickRandom或PickRandomShuffle不是必需的。"
    case03(string) : "情况 03" : : "如果输入值与此匹配，则触发相应的输出。对于PickRandom或PickRandomShuffle不是必需的。"
    case04(string) : "情况 04" : : "如果输入值与此匹配，则触发相应的输出。对于PickRandom或PickRandomShuffle不是必需的。"
    case05(string) : "情况 05" : : "如果输入值与此匹配，则触发相应的输出。对于PickRandom或PickRandomShuffle不是必需的。"
    case06(string) : "情况 06" : : "如果输入值与此匹配，则触发相应的输出。对于PickRandom或PickRandomShuffle不是必需的。"
    case07(string) : "情况 07" : : "如果输入值与此匹配，则触发相应的输出。对于PickRandom或PickRandomShuffle不是必需的。"
    case08(string) : "情况 08" : : "如果输入值与此匹配，则触发相应的输出。对于PickRandom或PickRandomShuffle不是必需的。"
    case09(string) : "情况 09" : : "如果输入值与此匹配，则触发相应的输出。对于PickRandom或PickRandomShuffle不是必需的。"
    case10(string) : "情况 10" : : "如果输入值与此匹配，则触发相应的输出。对于PickRandom或PickRandomShuffle不是必需的。"
    case11(string) : "情况 11" : : "如果输入值与此匹配，则触发相应的输出。对于PickRandom或PickRandomShuffle不是必需的。"
    case12(string) : "情况 12" : : "如果输入值与此匹配，则触发相应的输出。对于PickRandom或PickRandomShuffle不是必需的。"
    case13(string) : "情况 13" : : "如果输入值与此匹配，则触发相应的输出。对于PickRandom或PickRandomShuffle不是必需的。"
    case14(string) : "情况 14" : : "如果输入值与此匹配，则触发相应的输出。对于PickRandom或PickRandomShuffle不是必需的。"
    case15(string) : "情况 15" : : "如果输入值与此匹配，则触发相应的输出。对于PickRandom或PickRandomShuffle不是必需的。"
    case16(string) : "情况 16" : : "如果输入值与此匹配，则触发相应的输出。对于PickRandom或PickRandomShuffle不是必需的。"

    // 输入
    input InValue(string) : "将输入值与案例值进行比较，并在有匹配的情况下触发相应的输出，如果有的话。"
    input PickRandom(void) : "随机触发至少有一个连接的OnCase输出。"
    input PickRandomShuffle(void) : "随机触发至少有一个连接的OnCase输出，不会重复，直到所有案例都被选中，然后重新开始洗牌。"

    // 输出
    output OnCase01(void) : "当输入值等于Case01值时触发。"
    output OnCase02(void) : "当输入值等于Case02值时触发。"
    output OnCase03(void) : "当输入值等于Case03值时触发。"
    output OnCase04(void) : "当输入值等于Case04值时触发。"
    output OnCase05(void) : "当输入值等于Case05值时触发。"
    output OnCase06(void) : "当输入值等于Case06值时触发。"
    output OnCase07(void) : "当输入值等于Case07值时触发。"
    output OnCase08(void) : "当输入值等于Case08值时触发。"
    output OnCase09(void) : "当输入值等于Case09值时触发。"
    output OnCase10(void) : "当输入值等于Case10值时触发。"
    output OnCase11(void) : "当输入值等于Case11值时触发。"
    output OnCase12(void) : "当输入值等于Case12值时触发。"
    output OnCase13(void) : "当输入值等于Case13值时触发。"
    output OnCase14(void) : "输入值等于Case14值时触发。"
    output OnCase15(void) : "输入值等于Case15值时触发。"
    output OnCase16(void) : "输入值等于Case16值时触发。"
    output OnDefault(void) : "输入值不等于任何Case值时触发。"
    ]

@PointClass base(BaseEntityPoint) 
    color(0 0 255)
    iconsprite("editor/choreo_scene.vmt")
    color(240 180 250)
    line(240 180 250, targetname, target1)
    line(240 180 250, targetname, target2)
    line(240 180 250, targetname, target3)
    line(240 180 250, targetname, target4)
    line(240 180 250, targetname, target5)
    line(240 180 250, targetname, target6)
    line(240 180 250, targetname, target7)
    line(240 180 250, targetname, target8)
= logic_choreographed_scene: "管理一个或多个角色的编排场景。"
    [
    scenefile(scene) : "场景文件" : : "当此实体被触发时将播放的场景。"
    resumescenefile(scene) : "恢复场景/响应概念" : : "如果设置，当这个场景被中断时，将在恢复这个场景之前播放一个额外的场景。这可以是一个.vcd场景文件，或者是一个响应概念。（响应概念必须选择一个场景文件！）"
    target1(target_destination) : "目标 1"
    target2(target_destination) : "目标 2"
    target3(target_destination) : "目标 3"
    target4(target_destination) : "目标 4"
    target5(target_destination) : "目标 5"
    target6(target_destination) : "目标 6"
    target7(target_destination) : "目标 7"
    target8(target_destination) : "目标 8"
    busyactor(choices) : "如果一个角色正在说话..." : 1 : "如果一个角色在这个场景需要的时候已经在说话，这个场景应该怎么做。" =
        [
        0: "立即开始"
        1: "等待角色说完"
        2: "在下一个中断事件中打断"
        3: "在下一个中断事件中取消"
        ]

    onplayerdeath(choices) : "玩家死亡时" : 0 : "如果玩家死亡，这个实体应该做什么" =
        [
        0: "什么也不做"
        1: "取消剧本并返回到AI"
        ]


    // 输入
    input Start(void) : "开始播放场景文件"
    input Pause(void) : "暂停播放场景文件"
    input Resume(void) : "如果场景已经暂停，继续播放场景"
    input Cancel(void) : "取消播放场景"
    input CancelAtNextInterrupt(void) : "在场景中的下一个中断事件时取消播放场景。"
    input PitchShift(float) : "倍增音高"
    input InterjectResponse(string) : "在场景继续播放时，找到一个能够响应指定概念字符串的角色"
    input StopWaitingForActor(void) : "停止等待一个角色停止说话。"
    input Trigger(integer) : "触发指定编号的OnTrigger输出。"

    // 输出
    output OnStart(void) : "场景已开始"
    output OnCompletion(void) : "场景已完成"
    output OnCanceled(void) : "场景已被取消"
    output OnTrigger1(void) : "场景触发器 1"
    output OnTrigger2(void) : "场景触发器 2"
    output OnTrigger3(void) : "场景触发器 3"
    output OnTrigger4(void) : "场景触发器 4"
    output OnTrigger5(void) : "场景触发器 5"
    output OnTrigger6(void) : "场景触发器 6"
    output OnTrigger7(void) : "场景触发器 7"
    output OnTrigger8(void) : "场景触发器 8"
    output OnTrigger9(void) : "场景触发器 9"
    output OnTrigger10(void) : "场景触发器 10"
    output OnTrigger11(void) : "场景触发器 11"
    output OnTrigger12(void) : "场景触发器 12"
    output OnTrigger13(void) : "场景触发器 13"
    output OnTrigger14(void) : "场景触发器 14"
    output OnTrigger15(void) : "场景触发器 15"
    output OnTrigger16(void) : "场景触发器 16"
    ]

@PointClass base(BaseEntityPoint) 
    color(128 128 128)
    iconsprite("editor/ficool2/logic_collision_pair.vmt")
    line(128 128 128, attach1, attach2)
= logic_collision_pair: "一个用于启用/禁用两个目标实体之间的vphysics碰撞的实体。"
    [
    attach1(target_destination) : "附件 1" : : "第一个实体。"
    attach2(target_destination) : "附件 2" : : "第二个实体。"
    startdisabled(choices) : "开始时禁用碰撞" : 1 =
        [
        0: "否"
        1: "是"
        ]


    // 输入
    input EnableCollisions(void) : "启用第一个和第二个实体之间的碰撞。"
    input DisableCollisions(void) : "禁用第一个和第二个实体之间的碰撞。"
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/logic_compare.vmt")
    color(0 100 250)
= logic_compare: "比较输入值和另一个值。如果输入值小于比较值，将触发OnLessThan输出并发送输入值。如果输入值等于比较值，将触发OnEqualTo输出并发送输入值。如果输入值大于比较值，将触发OnGreaterThan输出并发送输入值。"
    [
    initialvalue(integer) : "初始值" : : "输入值的初始值。"
    comparevalue(integer) : "比较值" : : "要比较的值。"

    // 输入
    input SetValue(float) : "设置将与比较值比较的值。"
    input SetValueCompare(float) : "设置将与比较值比较的值并执行比较。"
    input SetCompareValue(float) : "设置比较值。"
    input Compare(void) : "强制比较输入值和比较值。"

    // 输出
    output OnLessThan(float) : "输入值小于比较值时触发。发送输入值作为数据。"
    output OnEqualTo(float) : "输入值等于比较值时触发。发送输入值作为数据。"
    output OnNotEqualTo(float) : "输入值与比较值不同时触发。发送输入值作为数据。"
    output OnGreaterThan(float) : "输入值大于比较值时触发。发送输入值作为数据。"
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/logic_director_query")
= logic_director_query: "允许根据导演的状态触发输出。"
	[
    minangerrange(integer) : "最小愤怒范围" : 1 : "愤怒值重映射的最小范围"
    maxangerrange(integer) : "最大愤怒范围" : 10 : "愤怒值重映射的最大范围"
    noise(choices) : "噪声" : 0 : "您希望愤怒结果有多少噪声？" =
        [
        0: "‘纯净’的愤怒值。没有噪声。"
        25: "一些噪声"
        50: "随机与绝对的平均混合"
        75: "很多噪声"
        100: "完全噪声"
        ]


    // 输入
    input HowAngry(void) : "询问导演这个查询有多愤怒"

    // 输出
    output OutAnger(integer) : "一个HowAngry输入将导致此输出触发，并重新映射愤怒值。"
    output On20SecondsToMob(void) : "在生成一群怪物前20秒触发。"
    output On60SecondsToMob(void) : "在生成一群怪物前60秒触发。"
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/logic_game_event")
= logic_game_event: "允许触发游戏事件。目前还没有可设置的参数。"
    [
    eventname(string) : "游戏事件名称" : : "要触发的事件名称（来自ModEvents.res）。目前没有参数"
    spawnflags(flags)  =
        [
        1: "[1] 激活者的userid字段" : 0
        ]


    // 输入
    input FireEvent(void) : "触发事件"
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/ficool2/logic_lineto")
    color(0 100 250)
    line(255 255 0, targetname, source, targetname, target)
= logic_lineto: "一个计算并输出从一个实体到另一个实体的向量的实体。"
    [
    source(target_destination) : "起始实体" : : "线条应该开始的实体的名称。"
    target(target_destination) : "结束实体" : : "线条应该结束的实体的名称。"

    // 输出
    output Line(vector) : "当从起始实体到结束实体的向量发生变化时触发。将向量作为参数传递。"
    ]

@PointClass base(BaseEntityPoint) 
    color(0 100 250)
    iconsprite("editor/logic_measure_movement.vmt")
    line(255 255 0, targetname, measureReference)
    line(255 0 255, targetname, measureTarget, targetname, measureReference)
    line(255 255 0, targetname, targetReference)
    line(255 0 255, targetname, target, targetname, TargetReference)
= logic_measure_movement: "一个可以测量一个实体相对于另一个实体的运动，并将该运动应用到第三个实体的实体。"
    [
    measuretarget(target_destination) : "要测量的实体" : : "您想要测量其运动的实体。"
    measurereference(target_destination) : "测量参考" : : "将相对于此实体测量“要测量的实体”的运动。"
    target(target_destination) : "要移动的实体" : : "此实体将被移动以模仿“要测量的实体”的运动。"
    targetreference(target_destination) : "移动参考" : : "“要移动的实体”将相对于此实体移动。"
    targetscale(float) : "移动比例" : 1 : "在将测量得到的运动应用于“要移动的实体”之前，用来除以测量运动的比例。1 = 目标实体移动的距离与测量实体一样多，2 = 目标实体移动的距离是测量实体的一半，0.5 = 目标实体移动的距离是测量实体的两倍。"
    measuretype(choices) : "测量类型" : 0 =
        [
        0: "位置"
        1: "眼睛位置"
        ]


    // 输入
    input SetMeasureTarget(target_destination) : "设置“要测量的实体”，其运动将被测量。"
    input SetMeasureReference(target_destination) : "设置“测量参考”实体。"
    input SetTarget(target_destination) : "设置“要移动的实体”，它将被移动以模仿被测量的实体。"
    input SetTargetReference(target_destination) : "设置“移动参考”实体。"
    input SetTargetScale(float) : "设置用来除以测量运动的比例。"
    input Enable(void) : "启用logic_measure_movement。"
    input Disable(void) : "禁用logic_measure_movement。"
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/logic_multicompare.vmt")
= logic_multicompare: "比较一组输入值。如果它们都相同，则触发OnEqual输出。如果有任何不同，则触发OnNotEqual输出。无法清除记忆，因此这只能使用一次。"
    [
    integervalue(integer) : "整数值（可选）" : : "如果启用了“应使用参考值”，则所有输入都将与此值进行比较。如果未启用，则它们相反会与添加的最后一个输入进行比较。"
    shouldcomparetovalue(choices) : "应使用整数值" : 0 : "如果启用，则所有输入都将与参考值进行比较。如果未启用，则它们将与添加的最后一个输入进行比较。" =
        [
        0: "否"
        1: "是"
        ]


    // 输入
    input InputValue(integer) : "向我们的输入集添加一个值，并自动触发CompareValues，如果设置为这样则将现有输入与此值进行比较。"
    input CompareValues(void) : "比较值并触发适当的输出。"

    // 输出
    output OnEqual(void) : "如果所有的值都相等，则触发。"
    output OnNotEqual(void) : "如果任何值不相等，则触发。"
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/ficool2/logic_navigation")
    line(128 128 128, targetname, target)
= logic_navigation: "用于设置其他实体的导航属性的实体。用于使NPC忽略它们可以轻松推动的途中的物理道具。"
    [
    target(target_destination) : "导航实体" : : "要设置导航属性的实体的名称。"
    spawnflags(flags)  =
        [
        1: "[1] 开始时启用" : 1
        ]

    navprop(string) : "导航属性" : "忽略" : "唯一有效的属性是忽略此实体，因此NPC会撞上它。"

    // 输入
    input TurnOn(void) : "打开。导航实体将设置其导航属性。"
    input TurnOff(void) : "关闭。导航实体将恢复其默认的导航属性设置。"
    input Toggle(void) : "切换开/关。"
    ]

@PointClass base(BaseEntityPoint, EnableDisable) 
    iconsprite("editor/logic_relay.vmt")
    color(0 100 250)
= logic_relay: "消息转发器。触发时触发OnTrigger输出，并且可以禁用以防止转发输出。\n\n作为一个实体与另一个实体之间的中介使用，用于打开或关闭I/O连接，或者作为一个容器，用于保持可以从多个地方触发的一组输出。"
    [
    spawnflags(flags)  =
        [
        1: "[1] 仅触发一次（在OnSpawn或OnTrigger输出触发后移除）" : 0
        2: "[2] 允许快速重新触发" : 0
        ]


    // 输入
    input Trigger(void) : "触发继电器，如果启用，其OnTrigger输出将触发。"
    input Toggle(void) : "切换继电器在启用和禁用之间。"
    input CancelPending(void) : "取消由此继电器触发且当前在I/O事件队列中等待的任何事件。"
    input EnableRefire(void) : "允许此继电器快速再次触发，如果禁用了快速重新触发。如果它处于此状态，此输入允许继电器提前再次触发。这将在最后一个OnTrigger输出后自动触发0.01秒。"

    // 输出
    output OnSpawn(void) : "在继电器生成时触发。如果继电器设置为仅触发一次，它将在触发此输出后删除自己。"
    output OnTrigger(void) : "在继电器被触发时触发。如果继电器设置为仅触发一次，它将在触发此输出后删除自己。"
    ]

@PointClass base(BaseEntityPoint) 
    color(0 0 255)
    iconsprite("editor/ficool2/logic_scene_list_manager.vmt")
    color(240 180 250)
    line(240 180 250, targetname, scene0)
    line(240 180 250, targetname, scene1)
    line(240 180 250, targetname, scene2)
    line(240 180 250, targetname, scene3)
    line(240 180 250, targetname, scene4)
    line(240 180 250, targetname, scene5)
    line(240 180 250, targetname, scene6)
    line(240 180 250, targetname, scene7)
    line(240 180 250, targetname, scene8)
    line(240 180 250, targetname, scene9)
    line(240 180 250, targetname, scene10)
    line(240 180 250, targetname, scene11)
    line(240 180 250, targetname, scene12)
    line(240 180 250, targetname, scene13)
    line(240 180 250, targetname, scene14)
    line(240 180 250, targetname, scene15)
= logic_scene_list_manager: "管理一系列logic_choreographed_scene实体的实体。按照它们将被其他输入播放的顺序在其中存储编排场景。每当一个场景播放时，管理器将移除列表中该场景之前的所有场景。可以在一个插槽中输入另一个logic_scene_list_manager的名称，而不是单个场景的名称，这将导致在此列表中后来播放的场景时，移除该管理器中的所有场景。"
    [
    scene0(target_destination) : "场景 1" : : "logic_choreographed_scene或logic_scene_list_manager的名称。"
    scene1(target_destination) : "场景 2" : : "logic_choreographed_scene或logic_scene_list_manager的名称。"
    scene2(target_destination) : "场景 3" : : "logic_choreographed_scene或logic_scene_list_manager的名称。"
    scene3(target_destination) : "场景 4" : : "logic_choreographed_scene或logic_scene_list_manager的名称。"
    scene4(target_destination) : "场景 5" : : "logic_choreographed_scene或logic_scene_list_manager的名称。"
    scene5(target_destination) : "场景 6" : : "logic_choreographed_scene或logic_scene_list_manager的名称。"
    scene6(target_destination) : "场景 7" : : "logic_choreographed_scene或logic_scene_list_manager的名称。"
    scene7(target_destination) : "场景 8" : : "logic_choreographed_scene或logic_scene_list_manager的名称。"
scene8(target_destination) : "场景 9" : : "logic_choreographed_scene或logic_scene_list_manager的名称。"
scene9(target_destination) : "场景 10" : : "logic_choreographed_scene或logic_scene_list_manager的名称。"
scene10(target_destination) : "场景 11" : : "logic_choreographed_scene或logic_scene_list_manager的名称。"
scene11(target_destination) : "场景 12" : : "logic_choreographed_scene或logic_scene_list_manager的名称。"
scene12(target_destination) : "场景 13" : : "logic_choreographed_scene或logic_scene_list_manager的名称。"
scene13(target_destination) : "场景 14" : : "logic_choreographed_scene或logic_scene_list_manager的名称。"
scene14(target_destination) : "场景 15" : : "logic_choreographed_scene或logic_scene_list_manager的名称。"
scene15(target_destination) : "场景 16" : : "logic_choreographed_scene或logic_scene_list_manager的名称。"

// 输入
input Shutdown(void) : "移除管理器及其引用的所有场景（以及嵌入在此管理器中的logic_scene_list_manager引用的所有场景）。"
	]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/logic_script.vmt")
    color(200 200 200)
    line(200 200 200, targetname, group00)
    line(200 200 200, targetname, group08)
    line(200 200 200, targetname, group01)
    line(200 200 200, targetname, group09)
    line(200 200 200, targetname, group02)
    line(200 200 200, targetname, group10)
    line(200 200 200, targetname, group03)
    line(200 200 200, targetname, group11)
    line(200 200 200, targetname, group04)
    line(200 200 200, targetname, group12)
    line(200 200 200, targetname, group05)
    line(200 200 200, targetname, group13)
    line(200 200 200, targetname, group06)
    line(200 200 200, targetname, group14)
    line(200 200 200, targetname, group07)
    line(200 200 200, targetname, group15)
    line(200 200 200, targetname, group16)
= logic_script: "脚本容器实体。"
    [
    group00(target_destination) : "EntityGroup[0]" : : "如果设置，指定的实体将被存储在EntityGroup数组中。最后一个使用的插槽之前的未使用插槽将变成null。"
    group01(target_destination) : "EntityGroup[1]" : : "如果设置，指定的实体将被存储在EntityGroup数组中。最后一个使用的插槽之前的未使用插槽将变成null。"
    group02(target_destination) : "EntityGroup[2]" : : "如果设置，指定的实体将被存储在EntityGroup数组中。最后一个使用的插槽之前的未使用插槽将变成null。"
    group03(target_destination) : "EntityGroup[3]" : : "如果设置，指定的实体将被存储在EntityGroup数组中。最后一个使用的插槽之前的未使用插槽将变成null。"
    group04(target_destination) : "EntityGroup[4]" : : "如果设置，指定的实体将被存储在EntityGroup数组中。最后一个使用的插槽之前的未使用插槽将变成null。"
    group05(target_destination) : "EntityGroup[5]" : : "如果设置，指定的实体将被存储在EntityGroup数组中。最后一个使用的插槽之前的未使用插槽将变成null。"
    group06(target_destination) : "EntityGroup[6]" : : "如果设置，指定的实体将被存储在EntityGroup数组中。最后一个使用的插槽之前的未使用插槽将变成null。"
    group07(target_destination) : "EntityGroup[7]" : : "如果设置，指定的实体将被存储在EntityGroup数组中。最后一个使用的插槽之前的未使用插槽将变成null。"
    group08(target_destination) : "EntityGroup[8]" : : "如果设置，指定的实体将被存储在EntityGroup数组中。最后一个使用的插槽之前的未使用插槽将变成null。"
    group09(target_destination) : "EntityGroup[9]" : : "如果设置，指定的实体将被存储在EntityGroup数组中。最后一个使用的插槽之前的未使用插槽将变成null。"
    group10(target_destination) : "EntityGroup[10]" : : "如果设置，指定的实体将被存储在EntityGroup数组中。最后一个使用的插槽之前的未使用插槽将变成null。"
    group11(target_destination) : "EntityGroup[11]" : : "如果设置，指定的实体将被存储在EntityGroup数组中。最后一个使用的插槽之前的未使用插槽将变成null。"
    group12(target_destination) : "EntityGroup[12]" : : "如果设置，指定的实体将被存储在EntityGroup数组中。最后一个使用的插槽之前的未使用插槽将变成null。"
    group13(target_destination) : "EntityGroup[13]" : : "如果设置，指定的实体将被存储在EntityGroup数组中。最后一个使用的插槽之前的未使用插槽将变成null。"
    group14(target_destination) : "EntityGroup[14]" : : "如果设置，指定的实体将被存储在EntityGroup数组中。最后一个使用的插槽之前的未使用插槽将变成null。"
    group15(target_destination) : "EntityGroup[15]" : : "如果设置，指定的实体将被存储在EntityGroup数组中。最后一个使用的插槽之前的未使用插槽将变成null。"
    ]

@PointClass base(BaseEntityPoint, EnableDisable) 
    iconsprite("editor/logic_timer.vmt")
    color(0 100 250)
= logic_timer: "一个定时器实体，可以按常规或随机间隔触发计时器事件。也可以设置为在高低端之间振荡，在这种情况下，每次触发时将交替触发OnTimerHigh和OnTimerLow输出。"
    [
    spawnflags(flags)  =
        [
        1: "[1] 振荡器（交替触发OnTimerHigh和OnTimerLow输出）" : 0
        ]

    userandomtime(choices) : "使用随机时间" : 0 =
        [
        0: "否"
        1: "是"
        ]

    lowerrandombound(float) : "最小随机间隔" : : "如果设置了'使用随机时间'，这是计时器触发之间的最小时间。时间将是这个值和'最大随机间隔'之间的一个随机数。"
    upperrandombound(float) : "最大随机间隔" : : "如果设置了'使用随机时间'，这是计时器触发之间的最大时间。时间将是'最小随机间隔'和这个值之间的一个随机数。"
    refiretime(string) : "重复触发间隔" : : "如果没有设置'使用随机时间'，这是计时器触发之间的时间，以秒为单位。"

    // 输入
    input RefireTime(integer) : "设置新的重复触发间隔。"
    input ResetTimer(void) : "重置计时器。它将在重复触发间隔过后触发。"
    input FireTimer(void) : "立即强制触发计时器。"
    input Enable(void) : "启用计时器。"
    input Disable(void) : "禁用计时器。"
    input Toggle(void) : "切换计时器的开/关状态。"
    input UseRandomTime(bool) : "设置此实体是否应使用随机间隔。"
    input LowerRandomBound(float) : "设置新的最小随机间隔。"
    input UpperRandomBound(float) : "设置新的最大随机间隔。"
    input AddToTimer(float) : "如果计时器当前已启用，添加时间到计时器。不会改变重复触发间隔。"
    input SubtractFromTimer(float) : "如果计时器当前已启用，从计时器减去时间。不会改变重复触发间隔。"

    // 输出
    output OnTimer(void) : "计时器到期时触发。"
    output OnTimerHigh(void) : "对于振荡计时器来说，每隔一次触发。"
    output OnTimerLow(void) : "对于振荡计时器来说，每隔一次触发。"
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/logic_auto.vmt")
= logic_versus_random: "在对抗模式的第一轮随机触发输出，然后在第二轮重复这些输出。"
    [

    // 输入
    input PickRandom(void) : "触发至少有一个连接的随机输出。"

    // 输出
    output OnRandom01(void) : "当输入值等于Random01值时触发。"
    output OnRandom02(void) : "当输入值等于Random02值时触发。"
    output OnRandom03(void) : "当输入值等于Random03值时触发。"
    output OnRandom04(void) : "当输入值等于Random04值时触发。"
    output OnRandom05(void) : "当输入值等于Random05值时触发。"
    output OnRandom06(void) : "当输入值等于Random06值时触发。"
    output OnRandom07(void) : "当输入值等于Random07值时触发。"
    output OnRandom08(void) : "当输入值等于Random08值时触发。"
    output OnRandom09(void) : "当输入值等于Random09值时触发。"
    output OnRandom10(void) : "当输入值等于Random10值时触发。"
    output OnRandom11(void) : "当输入值等于Random11值时触发。"
    output OnRandom12(void) : "当输入值等于Random12值时触发。"
    output OnRandom13(void) : "当输入值等于Random13值时触发。"
    output OnRandom14(void) : "当输入值等于Random14值时触发。"
    output OnRandom15(void) : "当输入值等于Random15值时触发。"
    output OnRandom16(void) : "当输入值等于Random16值时触发。"
    ]

@PointClass base(BaseEntityPoint) 
    color(0 100 250)
    line(255 255 0, targetname, parentname)
    iconsprite("editor/ficool2/material_modify_control.vmt")
= material_modify_control: "一个可以用来直接控制材质变量的实体。要使用它，你需要在你想要更改的材质中添加MaterialModify或MaterialModifyAnimated代理。将这个实体的父对象设置为那个你想要控制材质的实体。"
    [
    parentname(target_destination) : "父对象/目标" : : "只有在material_modify_control的父对象上的材质才会被修改。"
    srctools_search_parent(choices) : "[HA] 搜索父对象" : : "如果设置，编译器会为父对象上每一个有合适代理的材质复制这个实体。如果设置了材质名称，只有包含该值的材质才会被考虑。" =
        [
        0: "否"
        1: "是"
        ]

    materialname(material) : "材质名称" : : "要在父对象上修改的单个材质。不需要'materials/' 和 '.vmt'。允许的最大字符数为255。"
    materialvar(string) : "变量名称" : : "要修改的材质变量，例如'$frame'。允许的最大字符数为255。如果省略了$，编译器会添加它。这样可以防止实例检测到变量。"

    // 输入
    input SetMaterialVar(string) : "触发以修改材质变量。参数是要设置的变量值。"
    input SetMaterialVarToCurrentTime(void) : "这会将材质变量设置为服务器上的当前时间。"
    input StartAnimSequence(string) : "强制带有MaterialModifyAnimated代理的动画材质播放一组动画帧。格式为：<帧开始> <帧结束> <帧速率> <循环>。将<帧结束>设置为-1将使用纹理的最后一帧。<循环>应为1或0。"
    input StartFloatLerp(string) : "强制带有MaterialModify代理的材质在两个浮点值之间插值。格式为：<开始值> <结束值> <过渡时间> <循环>。<循环>应为1或0。"
    ]

@PointClass base(BaseEntityPoint) 
    color(0 100 250)
    iconsprite("editor/math_colorblend.vmt")
= math_colorblend: "用于在两种颜色之间创建混合，以控制另一个实体的颜色。"
    [
    spawnflags(flags)  =
        [
        1: "[1] 忽略超出范围的输入值" : 1
        ]

    inmin(integer) : "最小有效输入值" : 0 : "低于此值的输入值将被忽略。"
    inmax(integer) : "最大有效输入值" : 1 : "高于此值的输入值将被忽略。"
    colormin(color255) : "当输入为最小值时的输出RGB颜色。" : "0 0 0" : "当输入值等于'最小有效输入值'时，这是输出的RGB颜色。"
    colormax(color255) : "当输入为最大值时的输出RGB颜色。" : "255 255 255" : "当输入值等于'最大有效输入值'时，这是输出的RGB颜色。"

    // 输入
    input InValue(float) : "输入一个值并触发输出与重新映射的值。"

    // 输出
    output OutColor(color255) : "在收到InValue输入时触发，参数为重新映射的RGB颜色。"
    ]

@PointClass base(BaseEntityPoint, EnableDisable) 
    iconsprite("editor/math_counter.vmt")
    color(0 100 250)
= math_counter: "存储一个数字值并对其执行算术运算。如果最小或最大合法值非零，OutValue将被限制在合法范围内，并且在适当的时候触发OnHitMin/OnHitMax输出。如果最小值和最大值都设置为零，则不执行限制，只会触发OutValue输出。"
    [
    startvalue(float) : "初始值" : 0 : "计数器的起始值。"
    min(float) : "最小合法值" : 0 : "计数器的最小合法值。如果最小值=0且最大值=0，则不执行限制。"
    max(float) : "最大合法值" : 0 : "计数器的最大合法值。如果最小值=0且最大值=0，则不执行限制。"

    // 输入
    input Add(float) : "向计数器添加一个数值并触发OutValue输出结果。"
    input Divide(float) : "将计数器除以一个数值并触发OutValue输出结果。"
    input Multiply(float) : "将计数器乘以一个数值并触发OutValue输出结果。"
    input SetValue(float) : "将计数器设置为一个新值并触发OutValue输出结果。"
    input SetValueNoFire(float) : "将计数器设置为一个新值而不触发任何输出。"
    input Subtract(float) : "从计数器减去一个数值并触发OutValue输出结果。"
    input SetHitMax(float) : "设置计数器的上限并触发OutValue输出当前值。"
    input SetHitMin(float) : "设置计数器的下限并触发OutValue输出当前值。"
    input GetValue(void) : "使计数器触发其OnGetValue输出当前计数器的值。用于在你不希望从OutValue输出中获得持续更新时轮询计数器。"

    // 输出
    output OutValue(float) : "当计数器值改变时触发。"
    output OnHitMin(void) : "当计数器值达到或低于最小值时触发。计数器必须回到最小值以上，输出才会再次触发。"
    output OnHitMax(void) : "当计数器值达到或超过最大值时触发。计数器必须低于最大值，输出才会再次触发。"
    output OnGetValue(float) : "响应GetValue输入时触发。用于在你不希望从OutValue输出中获得持续更新时轮询计数器。"
    ]

@PointClass base(BaseEntityPoint, EnableDisable) 
    color(0 100 250)
    iconsprite("editor/math_remap.vmt")
= math_remap: "一个实体，将一系列输入值映射到给定的输出值范围。"
    [
    spawnflags(flags)  =
        [
        1: "[1] 忽略超出范围的输入值" : 1
        2: "[2] 将输出限制在输出范围内" : 0
        ]

    in1(integer) : "最小有效输入值" : 0 : "低于此值的输入值将被忽略。"
    in2(integer) : "最大有效输入值" : 1 : "高于此值的输入值将被忽略。"
    out1(integer) : "当输入为最小值时的输出值。" : : "当输入值等于'最小有效输入值'时，这是输出值。"
    out2(integer) : "当输入为最大值时的输出值。" : : "当输入值等于'最大有效输入值'时，这是输出值。"

    // 输入
    input InValue(float) : "输入一个值并触发输出与重新映射的值。"

    // 输出
    output OutValue(float) : "当收到InValue输入时触发，参数为重新映射的输入值。"
    ]

@MoveClass base(BaseEntityPoint, KeyFrame, Mover) 
    line(255 255 255, targetname, nextkey)
    size(-8 -8 -8, 8 8 8)
    color(255 170 0)
    iconsprite("editor/vizzys/move_keyframed")
    animator()
= move_keyframed: "关键帧移动行为"
    [
    ]

@MoveClass base(BaseEntityPoint, RopeKeyFrame) 
    studio("models/editor/axis_helper_thick.mdl")
    iconsprite("editor/move_rope")
    animator()
    keyframe()
= move_rope: "标记绳索中一点的节点实体。传统上，使用一个move_rope作为链的开始，然后跟随一个或多个keyframe_rope实体。然而，它们是可以互换的。"
    [
    ]

@PointClass base(BaseEntityPoint) 
    line(255 255 255, targetname, target)
    iconsprite("editor/ficool2/path_corner")
    studio("models/editor/angle_helper.mdl")
    color(247 181 82)
= path_corner: "通用路径点"
    [
    spawnflags(flags)  =
        [
        1: "[1] 等待重新触发" : 0
        2: "[2] 传送到此path_corner" : 0
        ]

    target(target_destination) : "下一个停靠目标"
    wait(integer) : "在此等待（秒）" : 0
    speed(integer) : "新火车速度" : 0
    yaw_speed(integer) : "新火车旋转速度" : 0

    // 输入
    input SetNextPathCorner(target_destination) : "设置下一个路径点"

    // 输出
    output OnPass(void) : "当路径跟随者通过这个点时触发"
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/ficool2/path_corner_crash")
    color(255 0 0)
= path_corner_crash: "直升机坠毁路径"
    [
    target(target_destination) : "下一个停靠目标"
    ]

@PointClass base(BaseEntityPoint) 
    cylinder(255 255 255, targetname, target, radius, targetname, targetname, radius)
    color(255 192 0)
    studio("models/editor/angle_helper.mdl")
    sphere(radius)
    iconsprite("editor/ficool2/path_track")
= path_track: "用于构建其他实体跟随的路径的实体。每个path_track是路径上的一个节点，每个节点持有下一个path_track的名称。"
    [
    spawnflags(flags)  =
        [
        1: "[1] 禁用" : 0
        2: "[2] 只触发一次" : 0
        4: "[4] 分支反向" : 0
        8: "[8] 禁用火车" : 0
        16: "[16] 传送到此path_track" : 0
        ]

    target(target_destination) : "下一个停靠目标" : : "路径中的下一个path_track。"
    altpath(target_destination) : "分支路径" : : "用作路径中下一个节点的替代path_track。用于制作分支路径。使用ToggleAlternatePath / EnableAlternatePath输入使替代路径生效。"
    speed(float) : "新火车速度" : 0 : "当火车到达这个path_track时，它将把速度设置为这个速度。这个速度必须是一个小于火车最大速度的正值。0值将不会改变火车的速度。"
    radius(float) : "路径半径" : 0 : "被NPC用于跟随轨道路径（攻击直升机/枪舰）。这告诉他们在这个节点允许的路径最大距离。"
    orientationtype(choices) : "定向类型" : 1 : "路径跟随者在通过这个路径轨迹时的面向方式。" =
        [
        0: "无变化"
        1: "面向运动方向"
        2: "面向这个path_track的角度"
        ]


    // 输入
    input ToggleAlternatePath(void) : "使轨迹切换到/从它的替代路径。"
    input EnableAlternatePath(void) : "启用轨迹的替代路径。"
    input DisableAlternatePath(void) : "禁用轨迹的替代路径。"
    input TogglePath(void) : "使轨迹切换开/关/"
    input EnablePath(void) : "启用轨迹。"
    input DisablePath(void) : "禁用轨迹。"

    // 输出
    output OnPass(void) : "当任何实体跟随此路径通过这个path_track节点时触发。"
    output OnTeleport(void) : "当任何实体跟随此路径直接传送到这个path_track节点时触发。"
    ]

@PointClass base(BaseEntityPoint) 
    color(128 128 128)
    iconsprite("editor/phys_constraintsystem.vmt")
= phys_constraintsystem: "用于管理一组相互作用的约束并保持它们稳定的实体。一组实体上的所有约束应该放在同一个系统中，否则它们在模拟过程中会相互冲突。"
    [
    additionaliterations(integer) : "额外的系统迭代" : 0 : "增加迭代次数会使系统中约束之间的相互作用更紧密。它不会补偿由于碰撞造成的错误，但会帮助解决由于质量悬殊的物体被约束在一起的情况。"
    ]

@PointClass base(BaseEntityPoint) 
    color(128 128 128)
    line(255 255 0, targetname, target)
    iconsprite("editor/phys_convert.vmt")
= phys_convert: "将任意实体转换为物理模拟实体。即，刷子实体将表现得像func_physbox，模型实体表现得像prop_physics。"
    [
    spawnflags(flags)  =
        [
        1: "[1] 转换为休眠状态" : 0
        2: "[2] 转换为碎片" : 0
        ]

    target(target_destination) : "要转换的实体" : : "当ConvertTarget输入被触发时，将被转换为物理对象的实体或实体的名称。最多512个实体。"
    swapmodel(target_destination) : "模型交换实体" : : "如果指定，实体将切换到使用这个实体的模型而不是它自己的。只会转换一个实体。"
    massoverride(float) : "质量覆盖" : 0 : "在对象转换时设置质量（0表示自动计算）"

    // 输入
    input ConvertTarget(void) : "将这个实体的目标转换为物理模拟对象。"

    // 输出
    output OnConvert(void) : "转换完成后触发。"
    ]

@PointClass base(BaseEntityPoint) 
    color(128 128 128)
    iconsprite("editor/ficool2/phys_keepupright.vmt")
    line(128 128 128, targetname, attach1)
= phys_keepupright: "一个控制器，试图保持一个实体面向特定方向。"
    [
    spawnflags(flags)  =
        [
        1: "[1] 开始时不活动" : 0
        ]

    attach1(target_destination) : "目标实体" : : "要对齐到期望角度的实体。"
    angularlimit(float) : "角速度限制" : 15 : "这个控制器可以补偿的最大角速度，以度/秒为单位。"

    // 输入
    input TurnOn(void) : "启用控制器。"
    input TurnOff(void) : "禁用控制器。"
    input SetAngularLimit(float) : "更改角速度限制。"
    ]

@PointClass base(BaseEntityPoint) 
    halfgridsnap
    color(128 128 128)
    line(128 128 128, targetname, attach1)
    iconsprite("editor/ficool2/phys_motor")
= phys_motor: "一个试图以特定速度旋转目标实体的实体。"
    [
    speed(float) : "旋转速度" : 0 : "角速度（单位是度/秒）"
    spinup(float) : "启动时间" : 1 : "启动时间，以秒为单位（也影响速度变化的速率）"
    inertiafactor(float) : "系统惯性缩放" : "1.0" : "如果被驱动的对象被约束在一组更重的物体上，使这个值变大。"
    addangaccel(float) : "额外的角加速度" : "0.0" : "如果你希望对象有更多的加速度，增加这个值。"
    axis(vecline) : "旋转轴"
    spawnflags(flags)  =
        [
        1: "[1] 开始时打开" : 1
        2: "[2] 无世界碰撞" : 0
        4: "[4] 铰链对象" : 1
        ]

    attach1(target_destination) : "附着对象" : : "要施加力的对象"

    // 输入
    input SetSpeed(float) : "设置目标速度"
    input TurnOn(void) : "打开电机"
    input TurnOff(void) : "关闭电机"
    ]

@PointClass base(BaseEntityPoint, EnableDisable) 
    iconsprite("editor/ficool2/phys_ragdollmagnet")
    sphere(radius)
    line(255 255 0, targetname, target)
    color(128 128 128)
= phys_ragdollmagnet: "一个对布娃娃物体起磁铁作用的实体。适用于制作夸张的布娃娃行为（例如，人物死亡时从栏杆上摔下）。如果设置了Bar Magnet生成标记，磁铁会像圆柱形磁铁一样工作，即它会吸引布娃娃到线上最近的点。"
    [
    axis(vecline) : "Bar Magnet Axis" : : "如果设置了Bar Magnet生成标记，布娃娃会被吸引到这条线上的任何点。"
    radius(float) : "有效半径" : 512 : "在这个实体原点周围影响布娃娃的半径。"
    force(float) : "力量" : 5000 : "在半径范围内对布娃娃施加的磁力。表示为每秒每单位的公斤数。所以1000的力量会给一个100公斤的人增加10单位/秒的速度。它会给一个10公斤的头蟹增加100单位/秒的速度。"
    target(target_destination) : "要影响的实体" : : "如果指定，phys_ragdollmagnet将只影响目标实体。"
    spawnflags(flags)  =
        [
        2: "[2] Bar Magnet (使用轴助手)" : 0
        ]

    ]

@PointClass base(BaseEntityPoint) 
    halfgridsnap
    color(128 128 128)
    iconsprite("editor/ficool2/phys_spring")
    line(128 128 128, targetname, attach1)
    line(128 128 128, targetname, attach2)
    line(128 128 128, targetname, attach1, targetname, attach2)
    sphere(length)
    sphere(breaklength)
= phys_spring: "一个物理模拟的弹簧。'Length'是所谓的'自然弹簧长度'。如果弹簧静止不动（没有挂东西或附着物），它就会是这个长度。当你附着某物到弹簧上时，它会伸展得比'自然长度'更长。伸展的量由'弹簧常数'决定。弹簧常数越大，弹簧伸展得越少。"
    [
    spawnflags(flags)  =
        [
        1: "[1] 只在伸展时施力" : 0
        ]

    attach1(target_destination) : "实体 1"
    attach2(target_destination) : "实体 2"
    springaxis(vecline) : "弹簧轴" : : "使用助手。拖动它以匹配虚拟弹簧。"
    length(string) : "弹簧长度" : 0 : "如果弹簧静止不动（没有挂东西或附着物），它就会是这个长度。0表示刷子的长度。"
    constant(string) : "弹簧常数" : 50 : "弹簧的硬度。数字越大，弹簧伸展得越少。"
    damping(string) : "阻尼常数" : "2.0" : "弹簧失去能量的多少。数字越大，弹簧越不弹跳。"
    relativedamping(string) : "相对阻尼常数" : "0.1" : "弹簧根据两个附着物体的相对速度失去能量的量。"
    breaklength(string) : "断裂长度" : 0 : "如果弹簧的长度超过了这个长度，弹簧就会断裂。"

    // 输入
    input SetSpringConstant(float) : "设置弹簧常数。"
    input SetSpringLength(float) : "设置弹簧长度。"
    input SetSpringDamping(float) : "设置弹簧阻尼。"
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/ficool2/player_loadsaved")
= player_loadsaved: "加载自动保存的游戏"
    [
    duration(string) : "淡出持续时间（秒）" : 2
    holdtime(string) : "保持淡出（秒）" : 0
    renderamt(integer) : "淡出透明度" : 255
    rendercolor(color255) : "淡出颜色（R G B）" : "0 0 0"
    loadtime(string) : "重载延迟" : 0

    // 输入
    input Reload(void) : "结束本局游戏并重新加载"
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/player_speedmod.vmt")
= player_speedmod: "随着时间的推移加快或减慢玩家速度（慢动作/快进）"
    [
    spawnflags(flags)  =
        [
        1: "[1] 抑制武器" : 0
        2: "[2] 抑制HUD" : 0
        4: "[4] 抑制跳跃" : 0
        8: "[8] 抑制蹲伏" : 0
        16: "[16] 抑制使用" : 0
        32: "[32] 抑制冲刺" : 0
        64: "[64] 抑制攻击" : 0
        128: "[128] 抑制放大" : 0
        ]


    // 输入
    input ModifySpeed(float) : "修改玩家速度X量。"
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/player_weaponstrip.vmt")
= player_weaponstrip: "从玩家那里移除武器。"
    [

    // 输入
    input Strip(void) : "移除所有武器。"
    input StripActiveWeapon(void) : "移除当前使用的武器。"
    input StripWeaponByClassname(string) : "根据类名移除武器，例如'weapon_dieselcan'"
    ]

@PointClass base(BaseEntityPoint, EnableDisable) 
    iconsprite("editor/ficool2/point_anglesensor")
    color(0 100 250)
    line(0 100 250, targetname, target)
    line(0 100 250, targetname, target, targetname, lookatname)
= point_anglesensor: "一个实体，用于检测另一个实体是否在一定时间内指向给定方向。"
    [
    target(target_destination) : "目标实体名称" : : "将被感应角度的实体名称。"
    lookatname(target_destination) : "看向实体" : : "我们想要检查目标实体是否正在看向的实体。"
    duration(float) : "持续时间" : : "目标实体必须看向'看向实体'的时间才能触发此实体，以秒为单位。"
    tolerance(integer) : "容忍度" : : "检查中用来确定目标实体是否在看向看向实体时的容忍度，以度为单位。"
    spawnflags(flags)  =
        [
        1: "[1] 使用目标实体的角度（非位置）" : 0
        ]


    // 输入
    input Toggle(void) : "在启用和禁用之间切换传感器。"
    input Test(void) : "检查目标实体是否在指定容忍度内面向看向实体，根据结果触发OnFacingLookat或OnNotFacingLookat输出。"

    // 输出
    output TargetDir(vector) : "当目标实体的前方方向改变时触发。作为参数传递新的前方方向。"
    output OnFacingLookat(void) : "当目标实体指向看向实体超过指定持续时间，或响应Test输入时触发。"
    output OnNotFacingLookat(void) : "在响应Test输入时，如果目标实体没有指向看向实体，则触发。"
    output FacingPercentage(float) : "归一化值（0..1），其中1是直接面向目标，0是在容忍度角度之外。"
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/ficool2/point_angularvelocitysensor")
    color(0 100 250)
    line(0 100 250, targetname, target)
= point_angularvelocitysensor: "一个实体，用于检测另一个实体的角速度是否达到或超过阈值。"
    [
    target(target_destination) : "目标实体名称" : : "将被感应角速度的实体名称。"
    threshold(float) : "阈值速度" : 0 : "用来比较的阈值角速度，以每秒度数计。"
    fireinterval(float) : "触发间隔" : "0.2" : "角速度必须超过阈值至少这么长时间才能触发。"
    axis(vecline) : "轴"
    usehelper(choices) : "使用轴助手" : 0 : "使用轴助手来确定旋转值（顺时针/逆时针）。" =
        [
        0: "否"
        1: "是"
        ]


    // 输入
    input Test(void) : "检查目标实体的角速度是否达到或超过阈值速度，根据结果触发OnGreaterThanOrEqualTo或OnLessThan输出。"
    input TestWithInterval(void) : "检查目标实体的角速度是否达到或超过阈值速度。一旦触发间隔过去，如果结果在整个触发间隔内稳定，则触发相应的测试结果输出。"

    // 输出
    output AngularVelocity(float) : "当目标的角速度改变时触发，传递新的角速度大小。"
    output OnGreaterThan(void) : "当目标实体从低于阈值角速度变为高于阈值角速度时触发。"
    output OnGreaterThanOrEqualTo(void) : "当目标实体从低于阈值角速度变为高于阈值角速度时触发。"
    output OnLessThan(void) : "当目标实体从高于阈值角速度变为低于阈值角速度时触发。"
    output OnLessThanOrEqualTo(void) : "当目标实体从高于阈值角速度变为低于阈值角速度时触发。"
    output OnEqualTo(void) : "当目标实体达到阈值角速度从不同的速度时触发。"
    ]

@PointClass base(BaseEntityPoint) 
    color(200 0 0)
    iconsprite("editor/point_broadcastclientcommand.vmt")
= point_broadcastclientcommand: "一个实体，可以向每个有效客户端的控制台发出命令，就像是由该玩家在本地输入的一样。"
    [

    // 输入
    input Command(string) : "执行所有玩家的命令。"
    ]

@PointClass base(BaseEntityPoint) 
    studioprop("models/editor/camera.mdl")
    frustum(FOV, fogstart, fogend, _frustum_color, -1)
= point_camera: "摄像机"
    [
    spawnflags(flags)  =
        [
        1: "[1] Start Off" : 0
        ]

    fov(float) : "FOV" : 90 : "视野角度"
    usescreenaspectratio(choices) : "屏幕宽高比" : 0 =
        [
        0: "否"
        1: "是"
        ]

    fogenable(choices) : "雾效开启" : 0 =
        [
        0: "否"
        1: "是"
        ]

    fogcolor(color255) : "雾色" : "0 0 0"
    fogstart(float) : "雾起始" : 2048 : "近雾平面。"
    fogend(float) : "雾终止" : 4096 : "远雾/剪裁平面。"
    fogmaxdensity(float) : "最大雾密度 [0..1]" : 1 : "雾的最大密度。0=无雾，1=全雾。"

    // Inputs
    input ChangeFOV(string) : "随时间改变摄像机的FOV"
    input SetOnAndTurnOthersOff(void) : "开启摄像机，并关闭所有其他摄像机。"
    input SetOn(void) : "开启摄像机。"
    input SetOff(void) : "关闭摄像机。"
    ]

@PointClass base(BaseEntityPoint) 
    color(200 0 0)
    iconsprite("editor/point_clientcommand.vmt")
= point_clientcommand: "一个向客户端控制台发出命令的实体，就像是由玩家在本地输入的一样（如果激活者是玩家，或者在单人游戏中的本地玩家）。"
    [

    // Inputs
    input Command(string) : "执行的命令。"
    ]

@PointClass base(BaseEntityPoint) 
    studioprop("models/editor/camera.mdl")
= point_deathfall_camera: "一个在玩家坠落死亡时通过其视角查看的摄像机实体。"
    [
    fov(float) : "视野角度" : 90 : "玩家FOV"
    fov_rate(float) : "达到FOV目标的秒数" : "1.0" : "达到指定FOV所需的时间量"
    ]

@PointClass base(BaseEntityPoint) 
    studioprop("models/editor/camera.mdl")
    iconsprite("editor/point_devshot_camera.vmt")
    frustum(fov, _frustum_near, _frustum_far, _frustum_color, -1)
= point_devshot_camera: "由-makedevshots系统使用的实体，它会自动在每个devshot摄像机位置的关卡中拍摄屏幕截图。"
    [
    cameraname(string) : "摄像机名称" : : "用作存储此摄像机屏幕截图的目录名称。在关卡中必须是唯一的。"
    fov(integer) : "摄像机FOV" : 75 : "此摄像机的FOV。"
    _frustum_far(integer) readonly : "<远平面>" : 1024 : "忽略，需要显示视锥预览。"
    ]

@PointClass base(BaseEntityPoint) 
    line(255 255 255, targetname, parentname)
    iconsprite("editor/ficool2/point_enable_motion_fixup")
= point_enable_motion_fixup: "一个用于在启用运动时移动无运动的道具的实体。将此实体父级到道具，当道具启用其运动时，它将立即传送到此实体的原点。"
    [
    ]

@PointClass base(BaseEntityPoint) 
    line(255 255 0, targetname, referencename)
    line(255 255 0, targetname, filtername)
    color(0 100 250)
    iconsprite("editor/point_entity_finder")
= point_entity_finder: "一个将找到实体并将其作为!caller通过OutEntity输出传递的实体。需要使用!caller作为输入参数。"
    [
    filtername(filterclass) : "过滤器名称" : : "用于缩小可找到实体集的过滤器。有关更多说明，请参见filter_activator_name。"
    referencename(target_destination) : "参考实体" : : "用于评估标准时使用的实体的名称。例如，使用'最近'时，这是将测量距离的实体。如果留空将使用point_entity_finder。"
    method(choices) : "搜索方法" : 0 =
        [
        0: "最近"
        1: "最远"
        2: "随机"
        ]


    // Inputs
    input FindEntity(void) : "找到符合指定标准的实体。如果找到将触发OutEntity并将实体作为!Caller传递。"

    // Outputs
    output OnFoundEntity(void) : "当输入FindEntity并找到实体时触发。将找到的实体作为!Caller传递。"
    ]

@PointClass base(BaseEntityPoint, EnableDisable) 
    iconsprite("editor/ficool2/point_gamestats_counter")
    color(0 255 0)
= point_gamestats_counter: "通用游戏统计计数器。"
    [
    name(string) : "统计计数器名称"

    // Inputs
    input SetName(string) : "更改统计计数器名称"
    input Increment(float) : "按指定值增加命名统计计数器"
    ]

@PointClass base(BaseEntityPoint, DamageType) 
    sphere(DamageRadius)
    line(255 0 0, targetname, damagetarget)
    iconsprite("editor/ts2do/point_hurt")
= point_hurt: "一个实体，会对它周围的所有实体造成伤害，有特定的延迟。如果指定了‘目标实体’，伤害只会对该实体造成。"
    [
    damagetarget(target_destination) : "目标实体" : : "如果指定，只有这个实体会受到伤害。否则，半径范围内的所有实体都会受到伤害。"
    damageradius(float) : "半径" : 256 : "这个实体周围这个半径范围内的所有实体都会受到伤害。如果指定了‘目标实体’，只有那个实体会受到伤害。"
    damage(integer) : "伤害" : 5 : "每次这个实体触发时，所有受影响的实体受到的伤害。"
    damagedelay(float) : "延迟" : 1 : "再次触发之间的延迟时间，以秒为单位。"
    spawnflags(flags)  =
        [
        1: "[1] 开始时激活" : 0
        ]


    // 输入
    input Hurt(void) : "强制单次触发，对‘目标实体’或半径范围内的所有实体造成伤害。"
    input TurnOn(void) : "启用这个实体。它将开始在每次触发时对实体造成伤害，并根据指定的延迟重新触发。"
    input TurnOff(void) : "禁用这个实体。它将停止对实体造成伤害。"
    input Toggle(void) : "切换这个实体的开/关状态。"
    ]

@PointClass base(BaseEntityPoint) 
    studio("models/editor/axis_helper.mdl")
    color(200 200 0)
    iconsprite("editor/ficool2/point_message.vmt")
    sphere(radius)
= point_message: "一个实体，在它的原点位置显示文本消息。"
    [
    spawnflags(flags)  =
        [
        1: "[1] 开始时禁用" : 0
        ]

    message(string) : "实体消息"
    radius(integer) : "显示消息半径" : 128 : "玩家必须在此距离内才能看到此消息。"
    developeronly(choices) : "仅开发者模式可见？" : 0 : "如果设置，此消息只有在开发者模式下才可见。" =
        [
        0: "否"
        1: "是"
        ]


    // 输入
    input Enable(void) : "开始显示消息文本，如果玩家在消息半径内。"
    input Disable(void) : "停止显示消息文本。"
    ]

@PointClass base(BaseEntityPoint, NavAttributeRegion) 
    iconsprite("editor/point_nav_attribute_region")
    wirebox(mins, maxs)
= point_nav_attribute_region: "一个点实体，用于在导航区域生成期间应用于区域的属性。"
    [
    mins(vector) : "最小值" : "-4 -128 -80"
    maxs(vector) : "最大值" : "4 128 80"
    ]

@PointClass base(BaseEntityPoint, NavBlocker) 
    obb(boxmins, boxmaxs)
= point_nav_blocker: "一个点实体，可以阻止接触其轴对齐边界盒(AABB)的导航区域。"
    [
    boxmins(vector) : "最小值" : "-8 -8 -8"
    boxmaxs(vector) : "最大值" : "8 8 8"
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/ficool2/point_playermoveconstraint.vmt")
    sphere(radius)
= point_playermoveconstraint: "一个实体，将玩家限制在其周围的半径内，当他们接近半径边缘时减慢他们的速度。"
    [
    radius(float) : "半径" : 256 : "限制玩家的半径。"
    width(float) : "约束宽度" : "75.0" : "约束边缘的宽度。这是当玩家接近半径边缘时开始减慢速度的距离。"
    speedfactor(float) : "速度因子" : "0.15" : "接近半径边缘时应用于玩家最大速度的因子。"

    // 输入
    input TurnOn(void) : "开始限制半径内的任何玩家。"
    input TurnOff(void) : "停止限制之前受到限制的任何玩家。"

    // 输出
    output OnConstraintBroken(void) : "当玩家突破限制时触发。"
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/ficool2/point_posecontroller")
    line(255 255 0, targetname, propname)
= point_posecontroller: "一个控制道具姿态参数并在客户端周期性调整姿态的实体。"
    [
    propname(target_destination) : "目标" : : "要控制的道具的名称。可以是任何动画实体。"
    poseparametername(string) : "姿态参数名称" : : "要控制的姿态参数的名称。设置为无效值将会导致游戏崩溃！"
    posevalue(float) : "姿态参数值" : 0 : "姿态参数的标准化值，从 0.0 到 1.0（映射到最小和最大范围）。"
    interpolationtime(float) : "插值时间" : 0 : "客户端匹配绝对姿态值的时间（秒），从 0.0 到 10.0。"
    interpolationwrap(choices) : "插值包裹" : 0 : "是否在插值时从 0.0 包裹到 1.0。" =
        [
        0: "否"
        1: "是"
        ]

    cyclefrequency(float) : "周期频率" : 0 : "基础周期每秒，从 -10.0 到 10.0。"
    fmodtype(choices) : "频率调制类型" : 0 =
        [
        0: "无"
        1: "正弦波"
        2: "方波"
        3: "三角波"
        4: "锯齿波"
        5: "噪声"
        ]

    fmodtimeoffset(float) : "频率调制时间偏移" : 0 : "调制时间偏移，从 -1.0f 到 1.0。"
    fmodrate(float) : "频率调制速率" : 0 : "调制周期每秒，从 -10.0f 到 10.0。"
    fmodamplitude(float) : "频率调制幅度" : 0 : "调制范围，从 0.0f 到 10.0。"

    // 输入
    input SetPoseParameterName(string) : "设置要控制的姿态参数。"
    input SetPoseValue(float) : "将姿态参数设置为一个标准化值，介于 0.0 和 1.0 之间（映射到最小和最大范围）。"
    input SetInterpolationTime(float) : "将插值时间设置为介于 0.0 和 10.0 秒之间的时间。"
    input SetCycleFrequency(float) : "设置姿态参数的基础周期每秒，从 -10.0f 到 10.0。"
    input SetFModType(integer) : "设置频率调制的类型。"
    input SetFModTimeOffset(float) : "设置调制时间偏移，从 -1.0f 到 1.0。"
    input SetFModRate(float) : "设置调制周期每秒，从 -10.0f 到 10.0。"
    input SetFModAmplitude(float) : "设置调制范围，从 0.0f 到 10.0。"
    input RandomizeFMod(float) : "通过 0.0 到 1.0 的极限度随机化频率调制。"
    ]

@PointClass base(BaseEntityPoint) 
    line(255 255 0, targetname, nozzle)
= point_prop_use_target: "携带道具的使用目标。触发道具的使用行为。"
    [
    spawnflags(flags)  =
        [
        1: "[1] 可以由燃油罐使用" : 1
        2: "[2] 可以由可乐瓶使用" : 0
        ]

    nozzle(target_destination) : "燃油喷嘴" : : "该使用目标的 prop_dynamic 燃油喷嘴的名称（搜寻模式）。"

    // 输入
    input Activate(void) : "激活使用目标。"
    input Deactivate(void) : "停用使用目标。"

    // 输出
    output OnUseStarted(void) : "当玩家开始使用这个目标时触发。"
    output OnUseCancelled(void) : "当玩家使用被取消时触发。"
    output OnUseFinished(void) : "当玩家使用完成时触发。"
    ]

@PointClass base(BaseEntityPoint, EnableDisable) 
    color(0 100 250)
    line(0 100 250, targetname, target)
    iconsprite("editor/point_proximity_sensor.vmt")
= point_proximity_sensor: "一个检测其他实体接近目标位置的实体。"
    [
    target(target_destination) : "目标实体名称" : : "将被感应位置的实体的名称。"
    spawnflags(flags)  =
        [
        1: "[1] 沿着我们指定方向的轴测量距离。" : 0
        ]


    // 输入
    input Toggle(void) : "在启用和禁用之间切换传感器。"

    // 输出
    output Distance(float) : "目标实体离开此实体的距离。"
    ]

@PointClass base(BaseEntityPoint) 
    sphere(radius)
    sphere(inner_radius)
    studio("models/editor/cone_helper.mdl")
    iconsprite("editor/ficool2/point_push")
    frustum(influence_cone, inner_radius, radius, _frustum_color, -1)
= point_push: "将物体拉向或推离一个点。在 Portal 2 中，如果附近放置了一个传送门，它会转移吸力并产生多样化通风口的 'broken_tube_suck' 效果。"
    [
    spawnflags(flags)  =
        [
        1: "[1] 推动前测试视线" : 0
        2: "[2] 使用角度作为推动方向" : 0
        4: "[4] 无衰减（任何距离下恒定推动）" : 0
        8: "[8] 推动玩家" : 1
        16: "[16] 推动物理物体" : 1
        ]

    enabled(choices) : "开始启用" : 1 =
        [
        0: "否"
        1: "是"
        ]

    magnitude(float) : "强度" : 100 : "从中心推开的力度。"
    radius(float) : "半径" : 128 : "影响物品的半径。"
    inner_radius(float) : "视线半径" : 0 : "如果启用了 '测试视线'，碰撞检查将从中心检查到这个距离。这允许在中间放置模型。"
    influence_cone(float) : "影响锥" : 0 : "如果大于零，物体必须位于该角度的锥体内才会受到影响。"

    // 输入
    input Enable(void) : "启用推动。"
    input Disable(void) : "禁用推动。"
    ]

@PointClass base(BaseEntityPoint) 
    line(255 255 0, targetname, model)
= point_script_use_target: "使实体可被玩家 '使用'。附加的脚本决定显示文本和使用时间。"
    [
    model(target_destination) : "使用模型" : : "玩家将使用的实体的名称。"

    // 输出
    output OnUseStarted(void) : "当玩家开始使用这个目标时触发。"
    output OnUseCanceled(void) : "当玩家使用被取消时触发。"
    output OnUseFinished(void) : "当玩家使用完成时触发。"
    ]

@PointClass base(BaseEntityPoint) 
    color(200 0 0)
    iconsprite("editor/point_servercommand.vmt")
= point_servercommand: "一个向服务器控制台发出命令的实体。"
    [

    // 输入
    input Command(string) : "执行的命令。"
    ]

@PointClass base(BaseEntityPoint, RenderFields) 
    studio("models/editor/cone_helper.mdl")
    sphere(spotlightlength)
    sphere(spotlightwidth)
= point_spotlight: "一个绘制聚光灯的实体。当玩家侧视时会绘制一束光线，面向玩家时会绘制一个光晕。除非勾选了 '无动态光' 的生成标志，否则它还会在聚光灯末端所在的位置创建一个动态光源。"
    [
    spawnflags(flags)  =
        [
        1: "[1] 开始时打开" : 1
        2: "[2] 无动态光" : 1
        ]

    spotlightlength(integer) : "聚光灯长度" : 500 : "聚光灯光束的长度。"
    spotlightwidth(integer) : "聚光灯宽度" : 50 : "聚光灯光束的宽度。"
    rendercolor(color255) : "颜色 (R G B)" : "255 255 255"
    renderamt(integer) : "透明度" : 255 : "聚光灯使用的透明度。"
    hdrcolorscale(float) : "HDR 颜色比例。" : "0.7" : "在 HDR 模式下运行时乘以精灵颜色的浮点值。"
    haloscale(float) : "光晕大小比例。" : 60 : "确定光晕大小的浮点值。"

    // 输入
    input LightOn(void) : "打开聚光灯。"
    input LightOff(void) : "关闭聚光灯"

    // 输出
    output OnLightOn(void) : "当光线打开时触发。"
    output OnLightOff(void) : "当光线关闭时触发。"
    ]

@PointClass base(BaseEntityPoint) 
    studioprop()
    iconsprite("editor/point_teleport.vmt")
    line(255 255 255, targetname, target)
= point_teleport: "将目标实体传送至此位置和角度的实体。如果设置了'传送回原位'的生成标志，则会将目标实体传送回其出生位置。如果物体是物理模拟的，传送时会关闭模拟。"
    [
    target(target_destination) : "要传送的实体" : : "将被传送的实体的名称。"
    model(studio) : "[H] 模型" : "models/editor/angle_helper.mdl" : "在Hammer中显示的模型，用于定位。"
    spawnflags(flags)  =
        [
        1: "[1] 传送回原位" : 0
        2: "[2] 进入蹲伏状态（情节性）" : 0
        ]


    // 输入
    input Teleport(void) : "传送目标实体。"
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/point_template.vmt")
    line(255 255 0, targetname, Template01)
    line(255 255 0, targetname, Template09)
    line(255 255 0, targetname, Template02)
    line(255 255 0, targetname, Template10)
    line(255 255 0, targetname, Template03)
    line(255 255 0, targetname, Template11)
    line(255 255 0, targetname, Template04)
    line(255 255 0, targetname, Template12)
    line(255 255 0, targetname, Template05)
    line(255 255 0, targetname, Template13)
    line(255 255 0, targetname, Template06)
    line(255 255 0, targetname, Template14)
    line(255 255 0, targetname, Template07)
    line(255 255 0, targetname, Template15)
    line(255 255 0, targetname, Template08)
    line(255 255 0, targetname, Template16)
= point_template: "将一个实体或一组实体转换成一个单独的模板，可以在任何地方和多次实例化。如果模板中的实体之间存在相互依赖关系（实体I/O、层级或其他名称引用），模板中的实体将改变它们的名称，并重新连接到更改后的名称。名称更改格式如下：'<original name>&0000'，其中0000将被替换为当前的全局模板实例，因此使用'<original name>*'的通配符搜索仍然可以找到它们。\n如果你不希望发生名称修复，因为你只实例化模板一次，或者你希望输入触发模板的所有实例，请检查'保留实体名称'的生成标志。\n要在其他地方实例化模板，请使用env_entity_maker。"
    [
    spawnflags(flags)  =
        [
        1: "[1] 不移除模板实体" : 0
        2: "[2] 保留实体名称（不进行名称修复）" : 1
        ]

    template01(target_destination) : "模板 1"
    template02(target_destination) : "模板 2"
    template03(target_destination) : "模板 3"
    template04(target_destination) : "模板 4"
    template05(target_destination) : "模板 5"
    template06(target_destination) : "模板 6"
    template07(target_destination) : "模板 7"
    template08(target_destination) : "模板 8"
    template09(target_destination) : "模板 9"
    template10(target_destination) : "模板 10"
    template11(target_destination) : "模板 11"
    template12(target_destination) : "模板 12"
    template13(target_destination) : "模板 13"
    template14(target_destination) : "模板 14"
    template15(target_destination) : "模板 15"
    template16(target_destination) : "模板 16"

    // 输入
    input ForceSpawn(void) : "在原位置实例化模板。"

    // 输出
    output OnEntitySpawned(void) : "实例化模板后触发。"
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/ficool2/point_tesla")
    color(200 200 0)
    line(255 255 0, targetname, m_SourceEntityName)
    sphere(m_flRadius)
= point_tesla: "在其原点周围产生特斯拉电弧的实体。"
    [
    m_bon(choices) : "开始启用" : 0 : "特斯拉是否开始活跃？" =
        [
        0: "否"
        1: "是"
        ]

    m_sourceentityname(target_destination) : "源实体" : : "如果指定，特斯拉电弧将从指定的实体起始。否则，它们将从此实体起始。"
    m_soundname(sound) : "声音名称" : "DoSpark" : "每当产生电弧时播放的声音。"
    texture(sprite) : "精灵名称" : "sprites/physbeam.vmt" : "用于特斯拉电弧光束的材质。"
    m_color(color255) : "颜色" : "255 255 255"
    m_flradius(float) : "半径" : 200 : "在原点周围找到一个点以产生特斯拉电弧光束的半径。"
    beamcount_min(integer) : "最小光束数" : 6 : "创建电弧时产生的最小特斯拉电弧光束数量。"
    beamcount_max(integer) : "最大光束数" : 8 : "创建电弧时产生的最大特斯拉电弧光束数量。"
    thick_min(float) : "最小光束宽度" : 4 : "特斯拉电弧光束的最小宽度。"
    thick_max(float) : "最大光束宽度" : 5 : "特斯拉电弧光束的最大宽度。"
    lifetime_min(float) : "最小可见时间" : "0.3" : "特斯拉电弧光束的最小生命周期。"
    lifetime_max(float) : "最大可见时间" : "0.3" : "特斯拉电弧光束的最大生命周期。"
    interval_min(float) : "最小电弧间隔时间" : "0.5" : "随机电弧之间的最小时间延迟。"
    interval_max(float) : "最大电弧间隔时间" : 2 : "随机电弧之间的最大时间延迟。"

    // 输入
    input TurnOn(void) : "开启发射器。"
    input TurnOff(void) : "关闭发射器。"
    input DoSpark(void) : "强制产生单个电弧。"
    ]

@PointClass base(BaseEntityPoint) 
    color(0 100 250)
    line(0 100 250, targetname, target)
    iconsprite("editor/ficool2/point_velocitysensor")
= point_velocitysensor: "检测并输出实体速度的实体。"
    [
    target(target_destination) : "目标实体名称" : : "将被检测速度的实体的名称。"
    axis(vecline) : "测量轴"
    enabled(choices) : "开始启用" : 1 : "是否开始启用并活跃。" =
        [
        0: "否"
        1: "是"
        ]


    // 输入
    input Enable(void) : "启用传感器。"
    input Disable(void) : "禁用传感器。"

    // 输出
    output Velocity(float) : "目标速度变化时触发，传递速度的新大小。"
    ]

@PointClass base(BaseEntityPoint) 
    studioprop("models/editor/camera.mdl")
    color(200 0 0)
    frustum(fov, 4, _frustum_far, _frustum_color, -1)
    line(255 255 0, targetname, target)
    line(255 255 0, targetname, moveto)
= point_viewcontrol: "控制玩家视角的摄像机实体。当它活跃时，玩家将通过摄像机的视角看到外界。"
    [
    target(target_destination) : "要注视的实体" : : "摄像机在活跃时应指向并跟踪的实体的名称。"
    targetattachment(string) : "目标附件名称" : : "如果设置，摄像机将专注于'要注视的实体'上指定的附件。"
    wait(integer) : "保持时间" : 10 : "摄像机应控制玩家视角的时间长度，之后它将自行停用。如果摄像机应保持活跃直到被告知停用，请设置'无限保持时间'的生成标志。"
    moveto(target_destination) : "路径角" : : "摄像机激活后应沿其移动的第一个路径角。如果未指定，摄像机将不会移动。"
    spawnflags(flags)  =
        [
        1: "[1] 从玩家开始" : 0
        2: "[2] 跟随玩家" : 0
        4: "[4] 冻结玩家" : 1
        8: "[8] 无限保持时间" : 1
        16: "[16] 立即跳转到目标角度" : 0
        32: "[32] 使玩家非实体" : 1
        64: "[64] 可被玩家打断" : 0
        ]

speed(float) : "初始速度" : 0 : "如果摄像机在路径轨迹上移动，这是摄像机的起始速度。"
acceleration(float) : "加速度单位/秒^2" : 500 : "摄像机加速到路径拐角处期望速度的速度。"
deceleration(float) : "停止减速度单位/秒^2" : 500 : "摄像机减速到路径拐角处期望速度的速度。"
dontsetplayerview(choices) : "不设置玩家视角" : 0 : "阻止这个point_viewcontrol实际控制玩家的视角。FOV、影响玩家的spawnflags等可能仍然会发生。" =
    [
    0: "否"
    1: "是"
    ]

_frustum_far(integer) readonly : "<远平面>" : 1024 : "忽略，需要显示视锥预览。"

// 输入
input Enable(void) : "启用point_viewcontrol，并开始控制玩家的视角。"
input Disable(void) : "禁用point_viewcontrol，并停止控制玩家的视角。"

// 输出
output OnEndFollow(void) : "在point_viewcontrol停用时触发，由于接收到Disable输入、要观看的实体被销毁，或保持时间到期。"
]

@PointClass base(BaseEntityPoint) 
    color(200 0 0)
    studioprop("models/editor/camera.mdl")
    frustum(fov, _frustum_near, _frustum_far, _frustum_color, -1)
    line(255 255 0, targetname, target_entity)
= point_viewcontrol_multiplayer: "point_viewcontrol的多人版本，可以同时影响多个玩家。在它激活时，玩家将从摄像机的视角看出去。"
    [
    fov(float) : "视场" : 90 : "玩家FOV"
fov_rate(float) : "达到目标视野的秒数" : 1 : "达到指定视野应该需要的时间"
target_entity(target_destination) : "目标实体" : : "移动到的实体。（移动结束时会匹配原点和角度）。"
interp_time(float) : "达到目标实体的秒数" : 1 : "达到目标实体的原点和角度应该需要的时间。"
spawnflags(flags)  =
    [
    1: "[1] 移动结束时禁用" : 1
    2: "[2] 设置视野" : 0
    ]

_frustum_far(integer) readonly : "<远平面>" : 1024 : "忽略，用于显示视锥预览。"

// 输入
input Enable(void) : "启用 point_viewcontrol_multiplayer，并开始控制玩家的视角。"
input Disable(void) : "禁用 point_viewcontrol_multiplayer，并停止控制玩家的视角。"
input AddPlayer(target_destination) : "强制由此控制！激活者玩家。"
input RemovePlayer(target_destination) : "移除正在被此控制的！激活者玩家。"
input StartMovement(void) : "开始向目标实体移动。"
]

@PointClass base(BaseEntityPoint) 
    studioprop("models/editor/camera.mdl")
= point_viewcontrol_survivor: "一个控制玩家视角的摄像机实体。在输入时从摄像机位置移动到第一人称视角。"
    [
    fov(float) : "视野" : 90 : "玩家视野（如果设置了视野的 spawnflag）"
    fov_rate(float) : "达到目标视野的秒数" : "1.0" : "达到指定视野应该需要的时间"
    spawnflags(flags)  =
        [
        1: "[1] 移动结束时禁用" : 1
        2: "[2] 设置视野" : 0
        ]


    // 输入
    input Enable(string) : "启用 point_viewcontrol，并开始控制玩家的视角。传递一个幸存者名称来控制该幸存者的视角。（例如 '!zoey'）"
    input Disable(void) : "禁用 point_viewcontrol，并停止控制玩家的视角。"
    input StartMovement(void) : "开始移动到第一人称视角。"
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/postprocess_controller.vmt")
    color(255 255 255)
= postprocess_controller: "一个在地图中控制后处理设置的实体。"
    [
    fadetime(float) : "淡入时间" : 2
    localcontraststrength(float) : "局部对比度强度 [-1..x]" : 0
    localcontrastedgestrength(float) : "局部对比度边缘强度 [0..1]" : 0
    vignettestart(float) : "晕影开始距离 [0..1]" : "0.8"
    vignetteend(float) : "晕影结束距离 [0..x]" : "1.1"
    vignetteblurstrength(float) : "晕影模糊强度 [0..1]" : 0
    fadetoblackstrength(float) : "淡入黑色强度 [0..1]" : 0
    grainstrength(float) : "胶片颗粒强度 [0..x]" : 0
    spawnflags(flags)  =
        [
        1: "[1] 主控（如果存在多个 postprocess_controllers，则具有优先权）" : 0
        ]


    // 输入
    input SetLocalContrastStrength(float) : "设置局部对比度强度。"
    input SetLocalContrastEdgeStrength(float) : "设置屏幕边缘的局部对比度强度（由晕影控制）。"
    input SetVignetteStart(float) : "设置晕影开始距离（从屏幕中心开始）。"
    input SetVignetteEnd(float) : "设置晕影结束距离。"
    input SetVignetteBlurStrength(float) : "设置晕影上去饱和模糊的强度。"
    input SetFadeToBlackStrength(float) : "设置淡出强度。"
    ]

@PointClass base(BaseEntityPoint) 
    studio("models/editor/scriptedsequence.mdl")
    color(255 0 255)
    sphere(m_flRadius)
= scripted_sequence: "抓住一个 NPC 并让他们播放指定的一组动画。可以告诉 NPC 移动到编排序列的位置，或者可以告诉他们在当前位置播放脚本。同名的多个编排序列将在所有演员移动到位置后，在动作动画中同步。这允许演员之间紧密的互动（一个演员抓住另一个演员，击打他们等）。流程如下：\n\n1) 使用指定的移动动画移动到位置。如果 '移动到位置' 设置为 NONE，则跳到步骤 2。\n2) 如果被迫等待另一个演员移动到位置，播放前动作空闲动画，否则跳到步骤 3。如果没有指定前动作空闲，则使用 ACT_IDLE。\n3) 触发 OnBeginSequence 输出。\n4) 播放动作动画。如果没有指定动作动画，则跳到步骤 5。\n" +
        "5) 播放后动作空闲动画。如果没有指定，则跳到步骤 6。如果设置了 ''循环后动作空闲'' 的 spawnflag，则在脚本被取消前一直播放后动作空闲。如果没有指定后动作空闲动画，则使用 ACT_IDLE。\n6) 触发 OnEndSequence 输出。\n7) 如果指定了下一个要播放的脚本，则将 NPC 交给下一个脚本并重复该脚本的这个过程。\n\nMoveToPosition 输入运行步骤 1 和 2，然后在播放前动作空闲动画时等待，直到接收到 BeginSequence 输入。\n\n如果序列中有动作提取，则设置 '结束时不传送 NPC' 的 spawnflag。"
    [
    m_iszentity(target_destination) : "目标 NPC" : : "用于此脚本的 NPC 的名称或类名称（如 'npc_zombie'）"
    m_iszidle(string) : "前动作空闲动画" : : "在动作动画之前如果 NPC 必须等待脚本被触发，则播放的序列（如 'idle01'）或活动（如 'ACT_IDLE'）的名称。使用 '开始时启动' 标志或 MoveToPosition 输入来播放此空闲动画。"
    m_iszentry(string) : "入场动画" : : "序列开始时播放的序列（如 'reload02'）或活动（如 'ACT_RELOAD'）的名称，在过渡到播放主动作序列之前。"
    m_iszplay(string) : "动作动画" : : "要播放的主要序列（如 'reload02'）或活动（如 'ACT_RELOAD'）的名称。"
    m_iszpostidle(string) : "后动作空闲动画" : : "在动作动画之后播放的序列（如 'idle01'）或活动（如 'ACT_IDLE'）的名称。如果没有勾选 ''循环后动作空闲'' 的 spawnflag，则这将作为退出动画，类似于入场动画。"
    m_iszcustommove(string) : "自定义移动动画" : : "与'移动到位置'属性的'自定义移动'设置结合使用时，指定移动到脚本位置时使用的序列（例如'crouch_run01'）或活动（例如'ACT_RUN'）。"
    m_bloopactionsequence(choices) : "循环动作动画？" : 0 : "循环播放动作动画，直到序列被取消或中断。" =
        [
        0: "否"
        1: "是"
        ]

    m_bsynchpostidles(choices) : "同步空闲后动作？" : 0 =
        [
        0: "否"
        1: "是"
        ]

    m_flradius(integer) : "搜索半径（0=任何地方）" : 0 : "用于搜索NPC的半径范围。0代表搜索任何地方。"
    m_flrepeat(integer) : "重复率 毫秒" : 0
    m_fmoveto(choices) : "移动到位置" : 1 =
        [
        0: "否"
        1: "步行"
        2: "跑步"
        3: "自定义移动"
        4: "瞬间"
        5: "否 - 转向面对"
        ]

    onplayerdeath(choices) : "玩家死亡时" : 0 : "如果玩家死亡，该实体应该做什么" =
        [
        0: "无动作"
        1: "取消脚本并返回AI"
        ]

    m_isznextscript(target_destination) : "下一个脚本" : : "该脚本完成后立即运行的脚本名称。NPC在两个脚本之间不会返回AI。"
    m_bignoregravity(choices) : "脚本期间忽略NPC的重力" : 0 : "如果设置为'是'，NPC在播放此脚本时将不受重力影响。" =
        [
        0: "否"
        1: "是"
        ]

    m_bdisablenpccollisions(choices) : "脚本期间禁用NPC碰撞" : 0 : "当NPC在火车、电梯等上演播放脚本时必须相互穿透时使用。这仅禁用脚本中的NPC之间的碰撞，并且必须在两个scripted_sequences上启用。" =
        [
        0: "否"
        1: "是"
        ]

    spawnflags(flags)  =
        [
        4: "[4] 可重复" : 0
        8: "[8] 留下尸体" : 0
        16: "[16] 生成时启动" : 0
        32: "[32] 无中断" : 0
        64: "[64] 覆盖AI" : 0
        128: "[128] 结束时不传送NPC" : 0
        256: "[256] 在空闲后循环" : 0
        512: "[512] 优先级脚本" : 0
        1024: "[1024] 循环搜索" : 0
        2048: "[2048] 不抱怨" : 0
        4096: "[4096] 允许演员死亡不停止场景" : 0
        ]


    // 输入
    input BeginSequence(void) : "召唤NPC执行预定的脚本序列。"
    input MoveToPosition(void) : "召唤NPC到脚本位置。他们将播放他们的脚本空闲动作（如果没有指定，则为ACT_IDLE），直到触发BeginSequence。"
    input CancelSequence(void) : "停止脚本序列。如果在序列开始后触发此输入，直到NPC完成播放脚本动作动画，此输入才会生效。"

    // 输出
    output OnBeginSequence(void) : "当动作动画开始播放时触发。"
    output OnEndSequence(void) : "当动作动画完成时触发。"
    output OnCancelSequence(void) : "当序列被取消时触发。"
    output OnCancelFailedSequence(void) : "当序列在从未播放的情况下被取消时触发（OnCancelSequence也会触发）。"
    output OnScriptEvent01(void) : "在播放脚本时发生'触发'动画事件时触发。在QC中使用{ event 1003 framenum 1 }。"
    output OnScriptEvent02(void) : "在播放脚本时发生'触发'动画事件时触发。在QC中使用{ event 1003 framenum 2 }。"
    output OnScriptEvent03(void) : "在播放脚本时发生'触发'动画事件时触发。在QC中使用{ event 1003 framenum 3 }。"
    output OnScriptEvent04(void) : "在播放脚本时发生'触发'动画事件时触发。在QC中使用{ event 1003 framenum 4 }。"
    output OnScriptEvent05(void) : "在播放脚本时发生'触发'动画事件时触发。在QC中使用{ event 1003 framenum 5 }。"
    output OnScriptEvent06(void) : "在播放脚本时发生'触发'动画事件时触发。在QC中使用{ event 1003 framenum 6 }。"
    output OnScriptEvent07(void) : "在播放脚本时发生'触发'动画事件时触发。在QC中使用{ event 1003 framenum 7 }。"
    output OnScriptEvent08(void) : "在播放脚本时发生'触发'动画事件时触发。在QC中使用{ event 1003 framenum 8 }。"
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/shadow_control.vmt")
    color(200 0 0)
    sphere(distance)
= shadow_control: "用于控制地图中的阴影的实体。"
    [
    angles(angle) : "俯仰偏航翻滚 (Y Z X)" : "80 30 0" : "这是阴影方向。俯仰是绕Y轴旋转，偏航是绕Z轴旋转，翻滚是绕X轴旋转。"
    color(color255) : "阴影颜色" : "128 128 128" : "这是阴影的颜色。"
    distance(float) : "最大距离" : 75 : "阴影允许投射的最大距离，以Source单位计。"
    disableallshadows(choices) : "禁用所有阴影" : 0 =
        [
        0: "否"
        1: "是"
        ]

    enableshadowsfromlocallights(choices) : "启用来自局部光源的阴影" : 1 =
        [
        0: "否"
        1: "是"
        ]


    // 输入
    input color(color255) : "设置阴影颜色。"
    input direction(vector) : "设置阴影方向。"
    input SetDistance(float) : "设置最大阴影投射距离。"
    input SetAngles(string) : "设置阴影方向。"
    input SetShadowsDisabled(integer) : "设置阴影禁用状态。"
    input SetShadowsFromLocalLightsEnabled(integer) : "设置局部光源阴影启用状态。"
    ]

@PointClass base(BaseEntityPoint) 
    color(0 0 255)
    color(173 223 245)
    studioprop("models/editor/sky_camera.mdl")
    sphere(fogstart)
    sphere(fogend)
= sky_camera: "用于控制3D天空盒的实体。它的原点用于确定3D天空盒相对于地图的位置。将此实体放置在3D天空盒中，以映射原点应该在的点。"
    [
    parentname(target_destination) : "父级" : : "要随之移动的实体的名称。注意：sky_camera的位置通常只在生成时更新，因此这可能不会起作用。"
    scale(integer) : "3D天空盒比例" : 16 : "天空盒的比例。"
    fogenable(choices) : "启用雾效" : 0 =
        [
        0: "否"
        1: "是"
        ]

    fogblend(choices) : "雾效混合" : 0 =
        [
        0: "否"
        1: "是"
        ]

    use_angles(choices) : "使用角度作为雾效方向" : 0 =
        [
        0: "否"
        1: "是"
        ]

    use_angles_for_sky(choices) : "使用角度作为天空盒方向" : 0 : "使用这个实体的轴旋转实际的天空盒，就好像世界在这个实体的轴上倾斜。" =
        [
        0: "否"
        1: "是"
        ]

    clip_3d_skybox_near_to_world_far(choices) : "将3D天空近平面剪辑到世界远平面" : 0 =
        [
        0: "否"
        1: "是"
        ]

    clip_3d_skybox_near_to_world_far_offset(integer) : "3D天空近平面偏移" : 0 : "3D天空中近剪辑平面的偏移量，以世界单位计。只有在上述字段为真时才使用。负值表示拉近等。"
    fogcolor(color255) : "主要雾效颜色" : "255 255 255"
    fogcolor2(color255) : "次要雾效颜色" : "255 255 255"
    fogdir(string) : "主要雾效方向" : "1 0 0"
    fogstart(float) : "雾效开始" : 500 : "天空盒雾效开始的距离。"
    fogend(float) : "雾效结束" : 2000 : "天空盒雾效完全不透明的距离。"
    fogmaxdensity(float) : "雾效最大密度 [0..1]" : 1
    hdrcolorscale(float) : "HDR颜色比例。" : 1 : "在HDR模式下运行时乘以雾效颜色的浮点值。"

    // 输入
    input DeactivateSkybox(void) : "如果当前这个sky_camera是活动天空盒，则停止使其成为活动天空盒，这会导致天空变清晰。"
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/sound_mix_layer")
= sound_mix_layer: "将混音层设置为特定值的实体。"
    [
    mixlayername(string) : "混音层名称" : : "要设置层级的混音层的名称。"
    level(float) : "层级" : "0.0" : "设置混音层层级"

    // 输入
    input Level(float) : "设置混音层层级"
    ]

@PointClass base(BaseEntityPoint, Angles) 
    size(-2 -2 -2, 2 2 2)
    color(200 0 0)
= spark_shower: "由env_explosions创建的临时火花淋浴效果。生成时沿前方方向移动，同时产生火花，直到消失。"
    [
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/tanktrain_ai.vmt")
    line(255 255 255, targetname, target)
= tanktrain_ai: "坦克移动AI。这控制func_tracktrain，使其跟随目标移动。"
    [
    target(target_destination) : "火车名称" : : "要控制的func_tracktrain。"
    startsound(sound) : "开始移动声音" : "vehicles/diesel_start1.wav"
    enginesound(sound) : "引擎循环声音" : "vehicles/diesel_turbo_loop1.wav"
    movementsound(sound) : "车辆移动声音" : "vehicles/tank_treads_loop1.wav"

    // 输入
    input TargetEntity(string) : "改变坦克以瞄准指定的实体。"
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/tanktrain_aitarget.vmt")
    line(255 255 255, targetname, target)
    line(255 255 255, targetname, newtarget)
= tanktrain_aitarget: "改变func_tank或tanktrain_ai实体目标的实体。这只是在使用此实体时触发坦克的TargetEntity。"
    [
    target(target_destination) : "坦克AI实体" : : "要改变目标的tanktrain_ai实体。"
    newtarget(target_destination) : "新目标实体" : : "告诉tanktrain_ai瞄准的实体。"
    ]

@SolidClass base(BaseEntityBrush, EnableDisable) = trigger_brush: "可以使用的触发体积，并且可以将触摸事件传递给其父实体。"
    [
    spawnflags(flags)  =
        [
        1: "[1] 忽略玩家" : 1
        2: "[2] 忽略NPC" : 1
        4: "[4] 忽略func_pushable" : 1
        8: "[8] 忽略触摸" : 1
        16: "[16] 忽略+USE" : 1
        ]

    inputfilter(integer) : "输入标志" : 0 : "过滤哪些类型的实体可以与之交互。请在spawnflags中设置此项。"
    dontmessageparent(choices) : "代理到父级" : 0 : "将触摸或使用此实体的动作传递给父实体。输入过滤器仍然适用。" =
        [
        1: "否"
        0: "是"
        ]


    // 输出
    output OnStartTouch(void) : "当有东西触摸我们时触发。"
    output OnEndTouch(void) : "当有东西停止触摸我们时触发。"
    output OnUse(void) : "当玩家（或I/O）使用我们时触发。"
    ]

@SolidClass base(BaseEntityBrush, Origin) = trigger_transition: "用于控制哪些实体通过关卡转换的区域。创建一个或多个trigger_transitions并给它们命名为与changelevel地标相同的名称。任何在trigger_transition(s)内的实体都会到下一个地图。有关更多信息，请参见trigger_changelevel。"
    [
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/upgrade_spawn")
= upgrade_spawn
    [
    laser_sight(integer) : "激光瞄准器" : 1
    upgradepack_incendiary(integer) : "升级包 - 燃烧弹" : 1
    upgradepack_explosive(integer) : "升级包 - 爆炸弹" : 1
    spawnflags(flags)  =
        [
        1: "[1] 在生成物品上启用物理" : 0
        2: "[2] 生成的物品必须存在" : 0
        ]

    ]

@PointClass base(BaseEntityPoint) 
    size(-4 -4 -4, 4 4 4)
    color(200 200 0)
    studioprop("models/editor/vgui_arrows.mdl")
    iconsprite("editor/vizzys/vgui_screen")
    sphere(width)
    sphere(height)
= vgui_screen: "VGUI屏幕。用于世界中的监视器。"
    [
    panelname(string) : "面板名称" : : "要显示的显示类型。"
    overlaymaterial(material) : "覆盖材质" : : "用于覆盖在VGUI屏幕顶部的材质名称。注意：此材质必须写入Z才能使VGUI屏幕工作。"
    width(integer) : "世界中的面板宽度（绿色）" : 256 : "面板的单位宽度。"
    height(integer) : "世界中的面板高度（蓝色）" : 128 : "面板的单位高度。"
    istransparent(choices) : "是否透明？" : 0 : "如果你希望你的背景是透明的而不是黑色填充，请将此设置为真。" =
        [
        0: "否"
        1: "是"
        ]


    // 输入
    input SetActive(void) : "使vgui屏幕可见。"
    input SetInactive(void) : "使vgui屏幕不可见。"
    ]

@PointClass base(BaseEntityPoint) 
    color(200 200 0)
    studioprop("models/editor/vgui_arrows.mdl")
    sphere(width)
    sphere(height)
= vgui_slideshow_display: "幻灯片显示"
    [
    displaytext(string) : "显示文本"
    directory(string) : "图片目录（materials/vgui/...）" : "slideshow"
    minslidetime(float) : "最小幻灯片时间" : "0.5" : "幻灯片显示的最小随机时间。"
    maxslidetime(float) : "最大幻灯片时间" : "0.5" : "幻灯片显示的最大随机时间。"
    cycletype(choices) : "循环类型" : 0 =
        [
        0: "随机"
        1: "向前"
        2: "向后"
        ]

    nolistrepeat(choices) : "无列表重复" : 0 =
        [
        0: "允许列表重复"
        1: "无列表重复"
        ]

    width(integer) : "面板宽度" : 256 : "面板的单位宽度。"
    height(integer) : "面板高度" : 128 : "面板的单位高度。"

    // 输入
    input Enable(void) : "使幻灯片可见。"
    input Disable(void) : "使幻灯片不可见。"
    input SetDisplayText(string) : "设置显示文本。"
    input RemoveAllSlides(void) : "从幻灯片中移除所有幻灯片。"
    input AddSlides(string) : "通过关键词添加幻灯片。"
    input SetMinSlideTime(float) : "设置幻灯片之间的最小随机时间。"
    input SetMaxSlideTime(float) : "设置幻灯片之间的最大随机时间。"
    input SetCycleType(integer) : "0 - 随机，1 - 向前，2 - 向后"
    input SetNoListRepeat(bool) : "设置列表是否可以连续随机选取两次。"
    ]

@PointClass base(BaseEntityPoint) 
    iconsprite("editor/waterlodcontrol.vmt")
    sphere(cheapwaterstartdistance)
    sphere(cheapwaterenddistance)
    color(64 64 200)
= water_lod_control: "用于控制地图中任何水体的LOD行为的实体。如果您的地图中有水体，需要此实体。"
    [
    cheapwaterstartdistance(float) : "开始过渡到低质量水" : 1000 : "水体开始过渡到低质量水的相机距离，以单位计。"
    cheapwaterenddistance(float) : "结束过渡到低质量水" : 2000 : "水体完成过渡到低质量水的相机距离，以单位计。"

    // 输入
    input SetCheapWaterStartDistance(float) : "设置水体开始过渡到低质量水的距离。"
    input SetCheapWaterEndDistance(float) : "设置水体完成过渡到低质量水的距离。"
    ]

@SolidClass base(BaseEntity, ResponseContext) = worldspawn: "这是世界实体。每张地图只能包含一个，它会自动为您创建。"
    [
    skyname(string) : "天空盒材质名称" : "sky_l4d_rural02_hdr" : "用于2D天空盒的材质。"
    chaptertitle(string) : "章节标题" : : "当这个关卡开始时屏幕上出现的章节标题。"
    startdark(choices) : "关卡淡入" : 0 : "在开始关卡或加载存档后从黑色淡入。如果你需要更可配置的东西，请使用logic_auto和env_fade代替。" =
        [
        0: "否"
        1: "是"
        ]

    newunit(choices) : "新关卡单位" : 0 : "用于清除以前关卡的存档数据，以保持存档大小尽可能小。只有在玩家不能返回任何之前的关卡时才将其设置为是。" =
        [
        0: "否，保持当前"
        1: "是，清除之前关卡"
        ]

    timeofday(choices) : "一天中的时间" : 0 =
        [
        0: "午夜"
        1: "黎明"
        2: "早晨"
        3: "下午"
        4: "黄昏"
        5: "晚上"
        ]

    startmusictype(choices) : "开始音乐类型" : 0 =
        [
        0: "任务开始"
        1: "检查点"
        ]

    musicpostfix(string) : "音乐后缀字符串" : "Waterfront"
    maxoccludeearea(float) : "最大遮挡区域" : 0 : "防止对占屏幕超过X%的实体进行遮挡测试。"
    minoccluderarea(float) : "最小遮挡区域" : 0 : "如果遮挡物占屏幕不足X%则不使用。"
    maxpropscreenwidth(float) : "开始淡出像素" : -1 : "所有道具在关卡中开始淡出的像素宽度（<0 = 使用fademaxdist）。如果道具有特定的淡出距离，则忽略此数字。"
    minpropscreenwidth(float) : "结束淡出像素" : 0 : "道具可见的最小像素宽度（0 = 不淡出）。如果道具有特定的淡出距离，则忽略此数字。"
    detailvbsp(string) : "Detail.vbsp文件" : "detail.vbsp" : "用于发射细节道具的Detail .vbsp文件（在目录<root>/modname中找到）"
    detailmaterial(material) : "细节材质文件" : "detail/detailsprites" : "用于绘制细节道具的细节精灵材质"
    ]

@BaseClass base(BaseEntityAnimating, DamageFilter) = BaseLogicalNPC: "NPC行为，分离出来，以便npc_bullseye不包含与模型相关的内容。"
    [
    health(integer) : "生命值" : : "覆盖NPC的默认生命值。不能高于最大生命值。"
    max_health(integer) : "最大生命值" : : "覆盖NPC的最大生命值。生命值不能超过此数额。"
    squadname(string) : "小队名称" : : "在同一个小队中的NPC（即有匹配的小队名称）会共享关于敌人的信息，并且会轮流攻击和掩护彼此。"
    hintgroup(string) : "提示组" : : "提示组被NPC用来限制它们在地图的提示节点搜索到子集。只有具有匹配提示组名称的提示节点才会被此NPC考虑。"
    hintlimiting(choices) : "限制提示导航" : 0 : "限制NPC使用指定的提示组进行导航请求，但不限制局部导航。" =
        [
        0: "否"
        1: "是"
        ]

    additionalequipment(choices) : "持有武器" : 0 : "给NPC一把武器。如果NPC不知道如何使用特定武器，它们可能攻击奇怪或不攻击。" =
        [
        0: "无"
        ]

    relationship(string) : "关系" : : "改变这个NPC喜欢或不喜欢某些其他NPC。格式为：<string|targetname或classname> <string|disposition> <integer|rank>。disposition的值有：D_HT（憎恨），D_FR（恐惧），D_LI（喜欢），D_NU（中立）。"
    spawnflags(flags)  =
        [
        1: "[1] 等到被看见" : 0
        2: "[2] 封口（在愤怒之前没有IDLE声音）" : 0
        4: "[4] 坠落到地面（未选中意味着*传送*到地面）" : 1
        8: "[8] 掉落急救包" : 0
        16: "[16] 高效 - 不获取敌人或避障" : 0
        128: "[128] 等待脚本" : 0
        256: "[256] 长距离可见/射击" : 0
        512: "[512] 淡出尸体" : 1
        1024: "[1024] 在PVS外思考" : 0
        2048: "[2048] 模板NPC（被npc_maker使用，不会生成；不被point_template使用）" : 0
        4096: "[4096] 对此NPC执行替代碰撞/玩家避让（大体上已过时，使用Start/StopScripting）" : 0
        8192: "[8192] 不掉落武器" : 0
        16384: "[16384] 忽略玩家推动（不给玩家让路）" : 0
        ]

    sleepstate(choices) : "睡眠状态" : 0 : "将NPC保持在静止状态，直到指定条件。另见'唤醒半径'和'唤醒小队'。" =
        [
        0: "无"
        1: "等待威胁"
        2: "等待PVS"
        3: "等待输入，忽略PVS"
        4: "自动PVS"
        5: "PVS后自动PVS"
        ]

    wakeradius(float) : "唤醒半径" : 0 : "如果玩家在此距离内，自动唤醒"
    wakesquad(choices) : "唤醒小队" : 0 : "如果NPC被唤醒，唤醒所有NPC的小队伙伴" =
        [
        0: "否"
        1: "是"
        ]

    enemyfilter(filterclass) : "敌人过滤器" : : "用于过滤潜在敌人的过滤器"
    ignoreunseenenemies(choices) : "忽略未见敌人" : 0 : "优先可见的敌人，无论距离或关系优先级如何" =
        [
        0: "否"
        1: "是"
        ]

    avelocity(vector) : "角速度" : : "生成时开始的角速度。可以通过AddOutput更改，其中它将立即添加。"

    // 输入
    input SetRelationship(string) : "更改此实体与另一个实体或类的关系。格式：<entityname/classname> <D_HT/D_FR/D_LI/D_NU> <priority>"
    input SetEnemyFilter(target_destination) : "更改此NPC的敌人过滤器为命名的过滤器。"
    input SetHealth(integer) : "设置此NPC的生命值。"
    input PhysDamageScale(float) : "设置当这个角色被物理对象击中时伤害能量的缩放值。注意：0表示此功能因向后兼容而被禁用。"
    input Break(void) : "使NPC死亡并消失。"
    input StartScripting(void) : "进入脚本状态。在这个状态下，NPC会忽略各种刺激，使他们脱离脚本：他们会忽略危险声音，忽略+USE，不会闲聊或响应其他NPC的闲聊等。"
    input StopScripting(void) : "退出脚本状态。"
    input SetSquad(string) : "设置这个NPC的小队名字。它会自动从任何现有的小队中移除。参数留空会将NPC从任何现有的小队中移除。"
    input Wake(void) : "如果NPC正在睡觉，则唤醒它。"
    input ForgetEntity(target_destination) : "清除NPC对一个命名实体的记忆。"
    input GagEnable(void) : "打开NPC哑巴标志。NPC不会在编排场景之外说话。"
    input GagDisable(void) : "关闭NPC哑巴标志。"
    input IgnoreDangerSounds(float) : "忽略指定秒数的危险声音。"
    input HolsterWeapon(void) : "强制NPC收起武器。如果NPC正在脚本中，如果NPC的武器已经收起，或者如果NPC不使用武器，则忽略。"
    input HolsterAndDestroyWeapon(void) : "与HolsterWeapon相同，除了武器在被收起并隐藏后会被销毁。"
    input UnholsterWeapon(void) : "强制NPC拔出武器。如果NPC正在脚本中，如果NPC的武器已经拔出，或者如果NPC不使用武器，则忽略。"
    input ForceInteractionWithNPC(string) : "强制NPC与另一个NPC进行动态互动。参数格式：<目标NPC名称> <动态互动名称>"
    input UpdateEnemyMemory(string) : "更新（或创建）这个NPC对敌人及其位置的记忆"
    input BecomeRagdoll(void) : "这个NPC会立即变成没有任何力量的布娃娃（只是松弛下来）。OnDeath、OnHalfHealth等输出将**不会**触发。"

    // Outputs
    output OnDamaged(void) : "当这个NPC受到伤害时触发。"
    output OnDeath(void) : "当这个NPC被杀死时触发。"
    output OnHalfHealth(void) : "当这个NPC的最大健康值减半时触发。"
    output OnHearWorld(void) : "当这个NPC听到声音（战斗或玩家之外的声音）时触发。"
    output OnHearPlayer(void) : "当这个NPC听到玩家时触发。"
    output OnHearCombat(void) : "当这个NPC听到战斗声时触发。"
    output OnFoundEnemy(string) : "当这个NPC与敌人建立视线时触发（输出实体）。"
    output OnLostEnemyLOS(void) : "当这个NPC失去对敌人的视线时触发。"
    output OnLostEnemy(void) : "当这个NPC失去敌人时触发。通常是因为敌人被杀死/移除，或者因为这个NPC选择了一个更新、更危险的敌人。"
    output OnFoundPlayer(string) : "当这个NPC与敌人建立视线，且该敌人是玩家时触发（输出玩家实体）。"
    output OnLostPlayerLOS(void) : "当这个NPC失去对敌人的视线，且该敌人是玩家时触发。"
    output OnLostPlayer(void) : "当这个NPC失去敌人，且该敌人是玩家时触发。通常是因为敌人被杀死/移除，或者因为这个NPC选择了一个更新、更危险的敌人。"
    output OnDamagedByPlayer(void) : "当这个NPC被玩家伤害时触发。"
    output OnDamagedByPlayerSquad(void) : "当这个NPC被玩家或玩家的小队成员伤害时触发。"
    output OnDenyCommanderUse(void) : "当这个NPC拒绝加入玩家的小队时触发。"
    output OnSleep(void) : "当这个NPC进入睡眠状态时触发。"
    output OnWake(void) : "当这个NPC从睡眠状态中醒来时触发。"
    output OnForcedInteractionStarted(void) : "当NPC开始强制互动时触发。"
    output OnForcedInteractionAborted(void) : "当NPC因某种原因中止强制互动时触发（目标NPC死亡，无法到达路径等）。"
    output OnForcedInteractionFinished(void) : "处于actbusies状态的NPC不能再执行动态互动。"
    ]

@BaseClass base(BaseEntityPhysics, BreakableProp, BaseFadeProp, Glow) = BasePropPhysics: "适用于prop_physics类实体。"
    [
    spawnflags(flags)  =
        [
        1: "[1] 起始时休眠" : 0
        2: "[2] 不受物理伤害" : 0
        4: "[4] 碎片 - 不与玩家或其他碎片碰撞" : 0
        8: "[8] 禁止运动" : 0
        64: "[64] 在Physcannon抓取时启用运动" : 0
        128: "[128] 不受旋翼洗刷影响" : 0
        256: "[256] 在+USE时产生输出" : 1
        512: "[512] 防止拾取" : 0
        1024: "[1024] 防止玩家碰撞时启用运动" : 0
        4096: "[4096] 带触发互动的碎片" : 0
        8192: "[8192] 强制服务器端（仅限多人游戏）" : 0
        32768: "[32768] 启用+use发光效果" : 0
        ]

    minhealthdmg(integer) : "最小伤害以致伤" : 0 : "如果伤害小于此数值，该道具将忽略任何伤害事件。"
    shadowcastdist(integer) : "影子投射距离" : 0 : "使用此项来覆盖该物体投射影子的距离。0 = 默认距离。"
    physdamagescale(float) : "物理冲击伤害比例" : "0.1" : "当该物体被物理物体击中时，伤害能量的比例。注意：0意味着为了向后兼容而禁用此功能。\n设置为1.0表示材质强度与肉体相当，更小的数值表示更坚固的材质。"
    damagetype(choices) : "冲击伤害类型" : 0 =
        [
        0: "钝器"
        1: "锐器"
        ]

    nodamageforces(choices) : "受伤害不会推动它" : 0 : "用于确定伤害是否应该导致固体移动。" =
        [
        0: "否"
        1: "是"
        ]

    massscale(float) : "质量比例" : 0 : "物体质量的比例乘数。"
    overridescript(string) : "覆盖参数" : : "通常在物理道具.qc文件中的物理键/值对列表。格式为'key,value,key,value,etc'。"
    damagetoenablemotion(integer) : "健康水平以覆盖运动" : 0 : "如果指定，该物体将起始时禁止运动。一旦其健康值下降到指定数额以下，它将启用运动。"
    forcetoenablemotion(float) : "物理冲击力以覆盖运动" : 0 : "如果指定，该物体将起始时禁止运动。任何对physbox施加的力大于此值的冲击将启用运动。"
    puntsound(sound) : "踢击时的声音。"

    // Inputs
    input Wake(void) : "如果处于休眠状态，唤醒这个物理物体。"
    input Sleep(void) : "使这个物理物体进入休眠状态。如果给出Wake输入，或者对其施加力，它将醒来。注意，物理物体在静止一段时间后会自动进入休眠状态，所以你并不真的需要使用这个。"
    input EnableMotion(void) : "启用物理运动/碰撞响应。"
    input DisableMotion(void) : "禁用物理运动/碰撞响应。"
    input DisableFloating(void) : "禁用流体/浮动模拟以降低成本。"
    input SetBodyGroup(integer) : "设置这个道具的身体组（从0 - n）。"
    input physdamagescale(float) : "为这个角色设置物理冲击伤害比例。注意：0意味着为了向后兼容而禁用此功能。"
    input EnableDamageForces(void) : "对实体造成伤害会施加物理力。"
    input DisableDamageForces(void) : "对实体造成伤害不会施加物理力。"
    input EnablePuntSound(void) : "允许这个道具在被踢击时播放自己的声音。"
    input DisablePuntSound(void) : "阻止这个道具在被踢击时播放自己的声音。"

    // Outputs
    output OnMotionEnabled(void) : "当这个道具的运动被启用时触发，无论是通过'健康水平以覆盖运动'还是从EnableMotion输入。"
    output OnAwakened(void) : "当这个实体醒来时触发（在它休眠时施加碰撞/力）。"
    output OnPhysGunPickup(void) : "当玩家用physcannon或+USE捡起道具时触发。"
    output OnPhysGunPunt(void) : "当玩家用physgun踢击这个物体时触发。"
    output OnPhysGunOnlyPickup(void) : "当玩家仅用PHYSGUN捡起这个物体时触发。+USE捡起不会触发此输出。"
    output OnPhysGunDrop(void) : "当玩家用physcannon或USE放下道具时触发。"
    output OnPlayerUse(void) : "当玩家尝试+USE道具时触发。只有设置了在+USE时产生输出的spawnflag，此输出才会触发。"
    output OnPlayerPickup(void) : "每当玩家捡起这个道具时触发（用physcannon或+USE）。"
    output OnOutOfWorld(void) : "每当道具超出允许的世界范围时触发。"
    ]

@BaseClass base(BaseEntityVisBrush) = BaseTrain
    [
    spawnflags(flags)  =
        [
        1: "[1] 无俯仰（X-rot）" : 0
        2: "[2] 无用户控制" : 0
        8: "[8] 可穿过" : 0
        16: "[16] 固定方向" : 0
        128: "[128] 可骑乘的列车（HL1列车）" : 0
        256: "[256] 使用最大速度变化移动声音的音调" : 0
        512: "[512] 玩家无法阻挡" : 0
        ]

    target(target_destination) : "生成路径轨迹" : : "列车路径中第一个path_track的名称。列车将在这个path_track处生成。它还将转向由'方向类型'设置指示的方向。"
    startspeed(integer) : "最大速度（单位/秒）" : 100 : "这列火车能移动的最大速度。应用于这列火车的任何速度，如path_tracks或SetSpeed输入，都将被削减到这个最大值。"
    speed(integer) : "初始速度（单位/秒）" : 0 : "列车生成后将以此速度移动，0 = 停止。"
    velocitytype(choices) : "变化速度" : 0 : "这列火车在路径上移动时改变速度的方法。" =
        [
        0: "瞬间"
        1: "线性混合"
        2: "渐入/渐出"
        ]

    orientationtype(choices) : "变化方向" : 1 : "这列火车在路径上移动时改变方向的方法。" =
        [
        0: "从不（固定方向）"
        1: "靠近路径轨迹"
        2: "线性混合"
        3: "渐入/渐出"
        ]

    wheels(integer) : "车轮间距" : 50 : "用于转弯和停车。"
    height(integer) : "轨道上方高度" : 4 : "这列火车在轨道上方移动的高度。"
    bank(string) : "转弯时的倾斜角" : 0
    dmg(integer) : "碾压伤害" : 0 : "这列火车对阻挡它的实体造成的伤害量。"
    line_basetrain(string) readonly : "=========================================================================================================="
    movesound(sound) : "移动声音" : : "列车移动时播放（并循环）的声音。"
    movepingsound(sound) : "移动提示声" : : "列车加速时更频繁播放的声音。"
    startsound(sound) : "启动声音" : : "列车开始移动时播放的声音。"
    stopsound(sound) : "停止声音" : : "列车停止移动时播放的声音。"
    volume(integer) : "音量（10 = 最大）" : 10
    movesoundminpitch(integer) : "最小音调（1-255，> 100 = 更高）" : 60 : "列车接近停止时将接近的声音音调值。"
    movesoundmaxpitch(integer) : "最大音调（1-255，> 100 = 更高）" : 200 : "列车接近最大速度或1000单位/秒时将接近的声音音调值，如果没有设置'使用最大速度变化移动声音的音调'标志。"
    movesoundmintime(float) : "最小移动声音间隔" : 0 : "播放移动提示声的最小间隔。"
    movesoundmaxtime(float) : "最大移动声音间隔" : 0 : "播放移动提示声的最大间隔。"
    manualspeedchanges(choices) : "手动列车速度" : 0 : "通过IO控制列车速度，处理加速、减速时间。" =
        [
        0: "否"
        1: "是"
        ]

    manualaccelspeed(float) : "手动加速度" : 0 : "每秒加速到目标速度的单位。"
    manualdecelspeed(float) : "手动减速度" : 0 : "每秒减速到目标速度的单位。"

    // Inputs
    input SetSpeed(float) : "设置列车的速度，作为最大速度的比例[0, 1]"
    input SetSpeedDir(float) : "设置列车的速度，作为最大速度的比例。负值反向[-1, 1]"
    input SetSpeedReal(float) : "设置列车的速度。必须是从0到最大速度的正值。"
    input Stop(void) : "停止列车。"
    input StartForward(void) : "列车开始向前移动。"
    input StartBackward(void) : "列车开始向后移动。"
    input Resume(void) : "列车通过'Stop'或'Toggle'输入停止后，继续当前方向的移动。"
    input Reverse(void) : "反转列车的方向。"
    input Toggle(void) : "切换列车的启动和停止。"
    input SetSpeedDirAccel(float) : "加速/减速到指定速度，作为最大速度的比例。负值反向[-1, 1]"

    // Outputs
    output OnStart(void) : "列车开始向任一方向移动时触发。"
    output OnNextPoint(string) : "当列车移动到下一个目的地时，连续每帧触发。"
    ]

@BaseClass base(BaseEntityVisBrush, _Breakable, DamageFilter) = BreakableBrush
    [
    spawnflags(flags)  =
        [
        1: "[1] 仅在触发时破碎" : 0
        2: "[2] 触碰时破碎" : 0
        4: "[4] 承压时破碎" : 0
        512: "[512] 物理接触立即破碎" : 0
        1024: "[1024] 不受物理伤害" : 0
        2048: "[2048] 不允许子弹穿透" : 0
        ]

    propdata(choices) : "道具数据" : 0 : "根据这个实体的固体大小和材质的最佳近似值设置。如果设置，它将覆盖这个实体的健康值和从各种武器受到的伤害。请参阅MOD的scripts目录中的propdata.txt文件，以获取每个条目指定的详细列表。" =
        [
        0: "无"
        1: "木制.微小"
        2: "木制.小"
        3: "木制.中"
        4: "木制.大"
        5: "木制.巨大"
        6: "金属.小"
        7: "金属.中"
        8: "金属.大"
        9: "纸板.小"
        10: "纸板.中"
        11: "纸板.大"
        12: "石头.小"
        13: "石头.中"
        14: "石头.大"
        15: "石头.巨大"
        16: "玻璃.小"
        17: "塑料.小"
        18: "塑料.中"
        19: "塑料.大"
        20: "陶瓷.小"
        21: "陶瓷.中"
        22: "陶瓷.大"
        23: "陶瓷.巨大"
        24: "玻璃.窗户"
        25: "木制.中.无立足"
        ]

    health(integer) : "强度" : 1 : "在破碎之前需要承受多少点伤害。0表示不破碎。"
    material(choices) : "材质类型" : 0 : "设置固体的材质类型。用于决定受损时发出什么声音，以及破碎时产生什么碎片。" =
        [
        0: "玻璃"
        1: "木头"
        2: "金属"
        3: "肉体"
        4: "混凝土砌块"
        5: "天花板瓦片"
        6: "电脑"
        7: "坚不可摧的玻璃"
        8: "岩石"
        10: "无"
        ]

    explosion(choices) : "碎片方向" : 0 : "用于决定破碎时向哪个方向扔碎片。" =
        [
        0: "随机"
        1: "相对于攻击"
        2: "使用精确碎片方向"
        ]

    gibdir(angle) : "精确碎片方向" : "0 0 0" : "指定破碎时扔碎片的方向。确保在碎片方向字段中选择使用精确碎片方向！"
    nodamageforces(choices) : "受伤害不会推动它" : 0 : "用于确定伤害是否应该导致固体移动。" =
        [
        0: "否"
        1: "是"
        ]

    gibmodel(string) : "碎片组" : : "指定一个自定义的碎片组来破碎，覆盖'材质类型'。这些是propdata.txt中的名称，如MetalChunks。"
    breakabletype(choices) : "可破碎者" : 0 : "谁可以破碎这个？" =
        [
        0: "所有人"
        1: "所有感染者"
        2: "仅坦克"
        ]


    // Inputs
    input EnableDamageForces(void) : "对实体造成伤害会施加物理力。"
    input DisableDamageForces(void) : "对实体造成伤害不会施加物理力。"
    ]

@BaseClass base(BaseEntityVisBrush) = Door
    [
    speed(float) : "速度" : 100 : "门移动的速度。"
    noise1(sound) : "启动声音" : : "门开始移动时播放的声音。"
    noise2(sound) : "停止声音" : : "门停止移动时播放的声音。"
    startclosesound(sound) : "开始关闭声音" : : "（可选）门开始关闭时播放的声音。如果未设置，将使用启动声音代替。"
    closesound(sound) : "停止关闭声音" : : "（可选）门停止关闭时播放的声音。如果未设置，将使用停止声音代替。"
    loopmovesound(choices) : "循环移动声音？" : 0 : "如果设置为真，门的'启动声音'将持续循环，直到门完成移动。" =
        [
        0: "否"
        1: "是"
        ]

    wait(integer) : "重置前延迟（-1保持）" : -1 : "门打开后关闭前的时间，以秒为单位。一旦关闭，它可以再次使用。如果值设置为-1，门永远不会自行关闭。"
    lip(integer) : "凸缘" : 0 : "门将与原始位置保持重叠的量。移动距离 = 在移动轴上的固体大小 - 凸缘。负值会导致门移动得更远。"
    dmg(integer) : "阻挡伤害" : 0 : "阻挡这扇门移动的实体每帧造成的伤害量。"
    chainstodoor(target_destination) : "链接门" : : "传递门的+use输入和触摸事件到另一扇门，以便它也被激活。"
    forceclosed(choices) : "强制关闭" : 0 : "如果设置，这扇门将无论如何都会关闭。适用于即使玩家试图用物体阻挡也必须关闭的门。" =
        [
        0: "否"
        1: "是"
        ]

    ignoredebris(choices) : "忽略碎片" : 0 : "如果设置，这将改变门的碰撞组到一个忽略与碎片物体碰撞的组（注意这与玩家非实体spawnflag不兼容）。" =
        [
        0: "否"
        1: "是"
        ]

    health(integer) : "门健康值" : : "门的健康值（允许某人射击打开）。0表示无敌。"
    locked_sound(sound) : "锁定声音" : : "玩家尝试使用门但失败因为它被锁定时播放的声音。"
    unlocked_sound(sound) : "解锁声音" : : "按钮门。"
    spawnpos(choices) : "生成位置" : 0 =
        [
        0: "关闭"
        1: "打开"
        ]

    spawnflags(flags)  =
        [
        1: "[1] 起始时打开 - 已过时，请改用'Spawn Position'键" : 0
        4: "[4] 对玩家非实体" : 0
        8: "[8] 可穿过" : 0
        32: "[32] 切换" : 0
        256: "[256] 使用打开" : 0
        512: "[512] NPC不能" : 0
        1024: "[1024] 触摸打开" : 0
        2048: "[2048] 起始时锁定" : 0
        4096: "[4096] 门静音" : 0
        131072: "[131072] 关闭时阻挡感染者导航" : 0
        262144: "[262144] 关闭时阻挡幸存者导航" : 0
        65536: "[65536] 新+USE规则 - 仅当门关闭/正在关闭或打开/正在打开并且可以手动关闭时允许+USE" : 0
        ]


    // Inputs
    input Open(void) : "如果门不是完全打开的，打开门。"
    input Close(void) : "如果门不是完全关闭的，关闭门。"
    input Toggle(void) : "切换门的打开和关闭。"
    input Lock(void) : "锁定门。"
    input Unlock(void) : "解锁门。"
    input SetSpeed(float) : "设置门速度。"
    input SetToggleState(bool) : "立即强制门到当前打开或关闭状态。"

    // Outputs
    output OnClose(void) : "门开始关闭时触发。"
    output OnOpen(void) : "门开始打开时触发。"
    output OnFullyOpen(void) : "门到达完全打开位置时触发。如果设置了'Start Open'标志，则反转。"
    output OnFullyClosed(void) : "门到达完全关闭位置时触发。如果设置了'Start Open'标志，则反转。"
    output OnBlockedClosing(void) : "门在关闭时被阻挡时触发。"
    output OnBlockedOpening(void) : "门在打开时被阻挡时触发。"
    output OnUnblockedClosing(void) : "门在关闭时解除阻挡时触发。"
    output OnUnblockedOpening(void) : "门在打开时解除阻挡时触发。"
    output OnLockedUse(void) : "玩家使用门但它被锁定时触发。"
    ]

@BaseClass base(TriggerOnce) = Trigger
    [

    // Inputs
    input EndTouch(void) : "触发OnEndTouch输出。如果由触发器内部的实体调用，OnEndTouch也会将他们作为激活者触发。注意，即使玩家在外部被视为'不'触碰触发器时，也会传递这个输入。"

    // Outputs
    output OnStartTouchAll(void) : "当一个实体开始触碰这个触发器，并且没有其他实体触碰它时触发。只有通过这个触发器的过滤器的实体才会被考虑。"
    output OnEndTouch(void) : "当一个实体停止触碰这个触发器时触发。只有通过这个触发器的过滤器的实体才会触发这个输出。"
    output OnEndTouchAll(void) : "当一个实体停止触碰这个触发器，并且没有其他实体触碰它时触发。只有通过这个触发器的过滤器的实体才会被考虑。"
    ]

@BaseClass base(BaseEntityPhysics) = WeaponSpawnSingle
    [
    weaponskin(integer) : "武器皮肤" : -1 : "有些武器有多个版本的纹理，称为皮肤。将此设置为-1以外的数字，使给定的武器使用该皮肤而不是默认皮肤。"
    glowrange(float) : "发光范围" : 0 : "为这个生成器设置自定义的发光范围。0表示使用默认范围。"
    spawnflags(flags)  =
        [
        1: "[1] 启用物理" : 0
        2: "[2] 必须存在" : 0
        8: "[8] 无限物品（覆盖数量）" : 0
        ]

    ]

@NpcClass base(BaseEntityAnimating) 
    sphere(fademindist)
    sphere(fademaxdist)
    studio()
= commentary_dummy: "解说虚拟对象"
    [
    model(studio) : "虚拟模型" : "models/survivors/survivor_coach.mdl"
    eyeheight(integer) : "眼睛高度" : 64 : "相对于原点的眼睛高度。只有在盯着玩家时才需要"
    startinganim(string) : "起始动画" : "Idle_Calm_Pistol" : "这个虚拟对象生成时播放的起始动画名称。"
    startingweapons(string) : "起始武器" : "weapon_pistol" : "虚拟对象生成时应该拥有的武器名称。用空格、逗号或分号分隔。最后指定的武器将被装备"
    lookatplayers(choices) : "盯着玩家" : 0 : "如果您希望虚拟对象一直尝试盯着玩家，请设置为真。" =
        [
        0: "否"
        1: "是"
        ]

    headyawposeparam(string) : "头部偏航姿势参数" : "Head_Yaw" : "头部偏航姿势参数的名称。只有在盯着玩家时才需要"
    headpitchposeparam(string) : "头部俯仰姿势参数" : "Head_Pitch" : "头部俯仰姿势参数的名称。只有在盯着玩家时才需要"

    // Inputs
    input SetAnimation(string) : "强制虚拟对象播放动画。参数应为动画名称。"
    ]

@PointClass base(logic_relay) 
    color(0 100 250)
    line(255 255 255, targetname, target)
    iconsprite("editor/comp_numeric_transition")
= comp_numeric_transition: "触发时，根据各种选项随时间动态地改变键值/输入。"
    [
    target(target_destination) : "控制实体" : : "输出将指向的实体。"
    opt_name(string) : "键值/输入名称" : "SetSpeed" : "要更改的键值或输入的名称。如果目标实体不是由后编译器找到的实体，则必须设置IO类型。"
    io_type(choices) : "I/O 类型" : "auto" : "用于控制实体的方法。如果是输入，使用提供的输入名称。如果是键值，使用AddOutput更改键值。如果是自动，检查被控制的实体类别以确定合适的模式。" =
        [
        "auto": "自动"
        "io": "输入"
        "kv": "键值 (AddOutput)"
        ]

    transform(choices) : "值类型" : "speed" : "输入的行为，用于控制发送的实际值。无论这个值是什么，其他选项都是'位置'类型的值！" =
        [
        "set": "立即设置"
        "moveto": "移动到值"
        "speed": "调整速度"
        "light": "灯光模式"
        ]

    line_trans2(string) readonly : "==========================================="
    beat_interval(float) : "节拍间隔" : "0.1" : "每个输出之间的时间。更小的值更准确，但会增加生成的输出。"
    delay(float) : "开始延迟" : "0.0" : "触发后等待这段时间再开始动画。"
    duration(float) : "持续时间" : 5 : "变化将持续的时间。"
    startval(float) : "起始值" : 0 : "起始值。如果值类型是灯光模式，这些可能是a-z字母。"
    endval(float) : "结束值" : 100 : "结束值。如果值类型是灯光模式，这些可能是a-z字母。"
    line_trans3(string) readonly : "==========================================="
    easing_start(choices) : "缓动开始" : "linear" : "控制动画的开始方式。" =
        [
        "linear": "无"
        "quad": "二次方 (x?"
        "cubic": "三次方 (x?"
        "quartic": "四次方 (x^4)"
        "sine": "正弦"
        ]

    easing_end(choices) : "缓动结束" : "linear" : "控制动画的结束方式。" =
        [
        "linear": "无"
        "quad": "二次方 (x?"
        "cubic": "三次方 (x?"
        "quartic": "四次方 (x^4)"
        "sine": "正弦"
        ]


    // Outputs
    output OnFinished(void) : "一旦转换完成就触发。"
    ]

@PointClass base(BaseEntityAnimating, BreakableProp, Glow) 
    sphere(exploderadius)
    sphere(fademindist)
    sphere(fademaxdist)
    studio("models/editor/comp_prop_cable_dynamic.mdl")
= comp_prop_cable_dynamic: "允许使用comp_prop_rope/comp_prop_cable作为动态道具。"
    [
    spawnflags(flags)  =
        [
        256: "[256] 启动时禁用碰撞" : 0
        ]

    angles(angle) readonly : "方向" : "0 0 0" : "起始方向不能更改，简单地移动节点即可。"
    group(target_source) : "电缆组" : : "指定将编译成此实体的组的名称。"
    skin1(material) : "备选皮肤1" : : "如果设置，用于备选皮肤1的另一种材质。必须是模型材质，并且整个道具的绳索必须使用相同的材质。"
    skin2(material) : "备选皮肤2" : : "如果设置，用于备选皮肤2的另一种材质。"
    skin3(material) : "备选皮肤3" : : "如果设置，用于备选皮肤3的另一种材质。"
    skin4(material) : "备选皮肤4" : : "如果设置，用于备选皮肤4的另一种材质。"
    skin5(material) : "备选皮肤5" : : "如果设置，用于备选皮肤5的另一种材质。如果你需要更多，请在关闭SmartEdit时添加键值。"
    glowbackfacemult(float) : "背面发光乘数" : "1.0" : "背面发光的乘数。"

    // Inputs
    input TurnOn(void) : "使电缆组可见。"
    input TurnOff(void) : "使电缆组不可见。"
    input Skin(integer) : "更改电缆组的备选皮肤。"
    input EnableCollision(void) : "启用电缆组的碰撞。"
    input DisableCollision(void) : "禁用电缆组的碰撞。"
    ]

@PointClass base(BaseEntityAnimating, BreakableProp, Glow) 
    sphere(exploderadius)
    sphere(fademindist)
    sphere(fademaxdist)
    studio("models/editor/comp_prop_rope_dynamic.mdl")
= comp_prop_rope_dynamic: "允许使用comp_prop_rope/comp_prop_cable作为prop_dynamic。"
    [
    spawnflags(flags)  =
        [
        256: "[256] 起始时禁用碰撞" : 0
        ]

    angles(angle) readonly : "方向" : "0 0 0" : "起始方向不能更改，只需移动节点即可。"
    group(target_source) : "绳索组" : : "指定与comp_prop_rope/comp_prop_cable相同的组名。绳索将以此实体为原点进行编译。"
    glowbackfacemult(float) : "背面发光倍数" : "1.0" : "背面发光的倍数。"

    // Inputs
    input TurnOn(void) : "使绳索组可见。"
    input TurnOff(void) : "使绳索组不可见。"
    input EnableCollision(void) : "启用绳索组的碰撞。"
    input DisableCollision(void) : "禁用绳索组的碰撞。"
    ]

@PointClass base(logic_relay) 
    color(0 100 250)
    line(255 255 255, targetname, target)
    iconsprite("editor/comp_sequential_call")
= comp_sequential_call: "找到一系列实体（按距离或数字后缀），然后依次延迟触发输入。使用时，定义OnSeq输出，在'!seq'处触发输入。"
    [
    target(target_destination) : "要排序的实体" : : "将被排序并触发输入的实体。这应该指多个实体，可能带有*-通配符。"
    order_mode(choices) : "排序模式" : "dist" : "选择实体的排序方式。数字后缀在实体名称的末尾找到数字，并按该顺序排序。" =
        [
        "dist": "距离此处的距离"
        "dist_inv": "距离此处的距离倒序"
        "suffix": "数字后缀，升序"
        "suffix_inv": "数字后缀，降序"
        ]

    uniquify(choices) : "使实体唯一化？" : 0 : "添加后缀以确保所有实体都是唯一的。如果不使用*-通配符，则应启用。" =
        [
        0: "否"
        1: "是"
        ]

    time_mode(choices) : "时间模式" : "total" : "时间值的解释方式。如果这是设置为总时间并且排序模式是距离，延迟将基于距离。否则，它将是等间隔的。" =
        [
        "total": "总时间"
        "interval": "每个实体之间的时间"
        ]

    time_val(float) : "时间值" : "5.0" : "总时间或每个实体之间的时间。"
    time_variance(float) : "时间变化" : "0.0" : "计算延迟后，从延迟中随机添加/减去这么多以增加噪声。"

    // Outputs
    output OnSeqStart(void) : "序列开始时触发。"
    output OnSeq(void) : "为每个实体触发一次 - 使用!seq来指代目标。"
    output OnSeqEnd(void) : "所有延迟输出完成后触发。"
    ]

@PointClass base(BaseBeam) 
    line(255 255 255, targetname, LightningStart, targetname, LightningEnd)
    cylinder(255 255 255, targetname, LightningStart, Radius, targetname, LightningEnd, Radius)
    line(64 64 64, targetname, lightningStart)
    line(64 64 64, targetname, lightningEnd)
    line(10 10 10, targetname, filtername)
    iconsprite("editor/env_beam.vmt")
    sphere(radius)
    color(200 200 0)
= env_beam: "一个在两点之间创建可见光束的实体。这些点可以附着在实体上，使光束移动。"
    [
    radius(integer) : "半径" : 16 : "如果设置了'随机打击'生成标志，此半径决定了端点随机打击的区域。"
    life(float) : "生命周期（秒 0 = 无限）" : 0 : "光束消失前的时间。设置为零将使光束永远存在。"
    boltwidth(float) : "光束宽度" : 2 : "光束的像素宽度。"
    striketime(float) : "再次打击时间（秒）" : 1 : "光束随机打击的再发射时间。仅当设置了'随机打击'生成标志时使用。"
    lightningstart(target_destination) : "起始实体" : : "光束开始的实体。"
    lightningend(target_destination) : "结束实体" : : "光束结束的实体。如果没有设置，将使用结束位置代替。"
    decalname(string) : "贴花名称" : "Bigshot" : "在光束末端应用的贴花"
    spawnflags(flags)  =
        [
        1: "[1] 开始时打开" : 0
        2: "[2] 切换" : 0
        4: "[4] 随机打击" : 0
        8: "[8] 环形" : 0
        16: "[16] 开始时火花" : 0
        32: "[32] 结束时火花" : 0
        64: "[64] 贴花结束" : 0
        128: "[128] 阴影开始" : 0
        256: "[256] 阴影结束" : 0
        512: "[512] 逐渐变细" : 0
        ]

    touchtype(choices) : "触摸类型（绊线）" : 0 : "如果你想要光束在被实体触摸时触发输出，请在这里选择实体类型。" =
        [
        0: "不是绊线"
        1: "仅玩家"
        2: "仅NPC"
        3: "玩家或NPC"
        4: "玩家或NPC或Physprop"
        ]

    filtername(filterclass) : "过滤器名称" : : "用于确定触发输出的触发器的过滤器。"
    targetpoint(vecline) : "结束位置" : "0 0 0" : "如果没有指定结束实体，使用这个点作为目的地。它相对于光束起点。"
    clipstyle(choices) : "光束剪辑" : 0 : "选择你是否希望光束剪辑几何体或角色，使其提前停止。" =
        [
        0: "不剪辑（默认）"
        1: "剪辑到几何体"
        2: "剪辑到所有实体"
        ]


    // 输入
    input StrikeOnce(void) : "使光束打击一次。它将保持开启状态，直到其设置的生命周期结束然后关闭（如果生命周期设置为零，则永不关闭）。"
    input Amplitude(float) : "设置光束噪声的幅度（0 - 255）。"

    // 输出
    output OnTouchedByEntity(void) : "当实体触摸光束时触发。仅当实体通过了'触摸类型'选择时触发。"
    ]

@PointClass base(BaseEntityAnimating, Angles) 
    sphere(fademindist)
    sphere(fademaxdist)
    iconsprite("editor/ficool2/env_effectscript")
    studioprop()
= env_effectscript: "一个允许你通过脚本文件编写特殊视觉效果的实体。"
    [
    model(studio) : "脚本模型" : : "用于动画序列的模型。"
    scriptfile(string) : "脚本文件" : "scripts/effects/testeffect.txt" : "用于此模型的脚本的名称。"

    // 输入
    input SetSequence(string) : "设置脚本模型的序列。"
    ]

@PointClass base(env_sprite) 
    studio("models/editor/axis_helper_white.mdl")
    sprite()
    color(20 140 20)
    sphere(GlowProxySize)
= env_glow: "env_sprite的过时旧名称。"
    [
    ]

@PointClass base(BaseBeam) 
    iconsprite("editor/ficool2/env_laser.vmt")
    line(255 255 255, targetname, LaserTarget)
    color(200 200 0)
= env_laser: "一个在自身和给定目标之间创建激光束的实体。"
    [
    lasertarget(target_destination) : "激光目标" : : "要打击的实体或实体的名称。如果有多个匹配给定名称的实体，则随机选择目标。"
    width(float) : "光束宽度" : 2 : "激光束的宽度，以像素为单位。"
    endsprite(sprite) : "结束精灵" : : "如果指定，这个精灵将在激光束的末端绘制。"
    spawnflags(flags)  =
        [
        1: "[1] 开始时打开" : 0
        16: "[16] 开始时火花" : 0
        32: "[32] 结束时火花" : 0
        64: "[64] 贴花结束" : 0
        ]

    ]

@PointClass base(gibshooterbase) 
    iconsprite("editor/env_shooter.vmt")
    color(200 200 0)
    line(255 255 255, targetname, lightingorigin)
= env_shooter: "一个从其起点射出模型或精灵的实体。"
    [
    shootmodel(studio) : "模型" : : "射出的物体。可以是.mdl或.vmt。"
    shootsounds(choices) : "材质声音" : -1 =
        [
        -1: "无"
        0: "玻璃"
        1: "木头"
        2: "金属"
        3: "肉体"
        4: "混凝土"
        ]

    skin(integer) : "碎片皮肤" : 0 : "一些模型有多个版本的纹理，称为皮肤。将此设置为其他数字以在此射击器产生的所有碎片上使用该皮肤。"
    spawnflags(flags)  =
        [
        2: "[2] 着火" : 0
        ]

    nogibshadows(choices) : "禁用碎片阴影" : 0 =
        [
        0: "否"
        1: "是"
        ]

    gibgravityscale(float) : "碎片重力缩放" : 1 : "仅适用于点碎片。此字段允许您缩放重力，使碎片下落更快、更慢或根本不下落。"
    ]

@PointClass base(env_soundscape) 
    sphere(radius)
    line(255 255 255, targetname, position0)
    line(255 255 255, targetname, position1)
    line(255 255 255, targetname, position2)
    line(255 255 255, targetname, position3)
    line(255 255 255, targetname, position4)
    line(255 255 255, targetname, position5)
    line(255 255 255, targetname, position6)
    line(255 255 255, targetname, position7)
    iconsprite("editor/env_soundscape_triggerable.vmt")
= env_soundscape_triggerable: "一个像env_soundscape一样工作的实体，除了它与trigger_soundscape一起工作来确定玩家何时听到它。"
    [
    ]

@PointClass base(env_sprite) 
    studio("models/editor/axis_helper_white.mdl")
    sprite()
    color(20 140 20)
    sphere(GlowProxySize)
= env_sprite_oriented: "一个允许定向的env_sprite。"
    [
    ]

@PointClass base(env_tonemap_controller) 
    color(200 0 0)
    iconsprite("editor/env_tonemap_controller.vmt")
= env_tonemap_controller_ghost: "一个控制幽灵玩家HDR色调映射的实体。"
    [
    ]

@PointClass base(env_tonemap_controller) 
    color(200 0 0)
    iconsprite("editor/env_tonemap_controller.vmt")
= env_tonemap_controller_infected: "一个控制感染玩家HDR色调映射的实体。"
    [
    ]

@FilterClass base(filter_base) 
    color(0 255 0)
    iconsprite("editor/filter_class.vmt")
= filter_activator_class: "一个通过激活者的类名过滤的过滤器。"
    [
    filterclass(string) : "过滤类名" : : "要过滤的类名。如果过滤模式是允许，只有类名匹配给定字符串的实体才能通过过滤器。如果过滤模式是不允许，除了类名匹配给定字符串的实体外，所有实体都能通过过滤器。"
    ]

@FilterClass base(filter_base) 
    color(0 255 0)
    iconsprite("editor/filter_context.vmt")
= filter_activator_context: "一个通过激活者的上下文过滤的过滤器。"
    [
    responsecontext(string) : "过滤上下文" : : "要过滤的上下文。如果过滤模式是允许，只有拥有匹配给定字符串的任何值的上下文的实体才能通过过滤器。如果过滤模式是不允许，除了上下文匹配字符串的实体外，所有实体都能通过过滤器。"
    ]

@FilterClass base(filter_base) 
    color(0 255 0)
    iconsprite("editor/filter_team.vmt")
= filter_activator_infected_class: "一个通过激活者的感染类过滤的过滤器。"
    [
    filterinfectedclass(choices) : "过滤感染类" : 2 : "要过滤的感染类。如果过滤模式是允许，只有类匹配给定团队的实体才能通过过滤器。如果过滤模式是不允许，除了类匹配给定团队的实体外，所有实体都能通过过滤器。" =
        [
        1: "Smoker"
        2: "Boomer"
        3: "Hunter"
        4: "Spitter"
        5: "Jockey"
        6: "Charger"
        8: "Tank"
        ]

    ]

@FilterClass base(filter_base) 
    color(0 255 0)
    iconsprite("editor/filter_mass.vmt")
= filter_activator_mass_greater: "一个通过激活者的质量过滤的过滤器。"
    [
    filtermass(float) : "过滤质量" : : "要过滤的质量。如果过滤模式是允许，只有质量大于给定浮点数的实体才能通过过滤器。如果过滤模式是不允许，除了质量大于给定浮点数的实体外，所有实体都能通过过滤器。"
    ]

@FilterClass base(filter_base) 
    color(0 255 0)
    iconsprite("editor/filter_model.vmt")
= filter_activator_model: "一个通过激活者的模型过滤的过滤器。"
    [
    model(studio) : "过滤模型" : : "要过滤的模型。如果过滤模式是允许，只有模型匹配给定字符串的实体才能通过过滤器。如果过滤模式是不允许，除了模型匹配字符串的实体外，所有实体都能通过过滤器。"
    ]

@FilterClass base(filter_base) 
    color(0 255 0)
    iconsprite("editor/filter_name.vmt")
    line(0 255 0, targetname, filtername)
= filter_activator_name: "一个通过激活者的名称过滤的过滤器。"
    [
    filtername(target_destination) : "过滤名称" : : "要过滤的名称。如果过滤模式是允许，只有名称匹配给定字符串的实体才能通过过滤器。如果过滤模式是不允许，除了名称匹配字符串的实体外，所有实体都能通过过滤器。"
    ]

@FilterClass base(filter_base) 
    color(0 255 0)
    iconsprite("editor/filter_team.vmt")
= filter_activator_team: "一个通过激活者的团队过滤的过滤器。"
    [
    filterteam(choices) : "过滤团队编号" : 2 : "要过滤的团队编号。如果过滤模式是允许，只有团队编号匹配给定团队的实体才能通过过滤器。如果过滤模式是不允许，除了团队编号匹配给定团队的实体外，所有实体都能通过过滤器。" =
        [
        2: "幸存者"
        3: "感染者"
        ]

    ]

@FilterClass base(filter_base) 
    color(0 255 0)
    iconsprite("editor/vizzys/filter_damage_type.vmt")
= filter_damage_type: "一个伤害过滤器，通过造成的伤害类型来过滤。这只能用作伤害过滤器，而不是激活器过滤器。"
    [
    damagetype(choices) : "伤害类型" : 64 : "要过滤的伤害类型。如果过滤模式是允许，只有匹配的伤害类型才能通过过滤器。如果过滤模式是不允许，除了匹配的伤害类型外，所有伤害类型都能通过过滤器。" =
        [
        0: "通用"
        1: "压碎"
        2: "子弹"
        4: "切割"
        8: "烧伤"
        16: "冻结"
        32: "跌落"
        64: "爆炸"
        128: "棍棒"
        256: "电击"
        512: "声波"
        1024: "能量束"
        16384: "淹死"
        32768: "麻痹"
        65536: "神经毒气"
        131072: "毒药"
        262144: "辐射"
        524288: "淹死恢复"
        1048576: "化学"
        2097152: "慢烧"
        4194304: "移除无布娃娃"
        16777216: "完全碎尸"
        33554432: "气艇（枪）"
        67108864: "溶解"
        134217728: "爆炸表面"
        268435456: "直接"
        536870912: "猎鹰弹"
        ]

    ]

@FilterClass base(filter_base) 
    color(0 255 0)
    iconsprite("editor/vizzys/filter_enemy.vmt")
    sphere(filter_radius)
    sphere(filter_outer_radius)
    line(0 255 0, targetname, filtername)
= filter_enemy: "一个通过一系列标准过滤潜在敌人实体的过滤器。"
    [
    filtername(string) : "名称/类名" : : "要过滤的类名或实体名称。如果过滤模式是允许，只有类名匹配给定字符串的实体才能通过过滤器。如果过滤模式是不允许，除了类名匹配给定字符串的实体外，所有实体都能通过过滤器。"
    filter_radius(float) : "半径" : 0 : "测试敌人接近程度的半径。如果过滤模式是允许，只有距离等于或更近于半径的实体才能通过过滤器。如果过滤模式是不允许，所有在半径外的实体都能通过过滤器。"
    filter_outer_radius(float) : "外半径" : 0 : "如果设置为允许，外半径之外的敌人被认为是无效的；如果设置为不允许，外半径之外的敌人被认为是有效的。"
    filter_max_per_enemy(integer) : "每个敌人的最大队友数" : 0 : "允许针对任何给定实体的最大队友数。"
    spawnflags(flags)  =
        [
        1: "[1] 如果已经获取但过滤器失败，则不失去目标。" : 0
        ]

    ]

@FilterClass base(filter_base) 
    color(0 255 0)
    iconsprite("editor/ficool2/filter_base.vmt")
= filter_health: "一个基于造成伤害的实体是否激活肾上腺素的伤害过滤器。"
    [
    adrenalinepresence(choices) : "肾上腺素状态" : 1 : "允许攻击者的这种肾上腺素状态通过过滤器。" =
        [
        0: "仅非活跃"
        1: "仅活跃"
        ]

    healthmin(integer) : "最小生命值" : 0 : "将通过此过滤器的玩家健康的下限（包含）。"
    healthmax(integer) : "最大生命值" : 100 : "将通过此过滤器的玩家健康的上限（包含）。"
    ]

@FilterClass base(filter_base, DamageType) 
    color(0 255 0)
    iconsprite("editor/ficool2/filter_base.vmt")
= filter_melee_damage: "一个伤害过滤器，仅允许近战伤害。伤害类型指定允许的近战伤害类型。"
    [
    ]

@FilterClass base(filter_base) 
    color(0 255 0)
    iconsprite("editor/filter_multiple.vmt")
    line(0 255 0, targetname, filter01)
    line(0 255 0, targetname, filter02)
    line(0 255 0, targetname, filter03)
    line(0 255 0, targetname, filter04)
    line(0 255 0, targetname, filter05)
    line(0 255 0, targetname, filter06)
    line(0 255 0, targetname, filter07)
	line(0 255 0, targetname, filter08)
	line(0 255 0, targetname, filter09)
	line(0 255 0, targetname, filter10)
	line(0 255 0, targetname, filter11)
	line(0 255 0, targetname, filter12)
	line(0 255 0, targetname, filter13)
	line(0 255 0, targetname, filter14)
	line(0 255 0, targetname, filter15)
	line(0 255 0, targetname, filter16)
	line(0 255 0, targetname, filter17)
	line(0 255 0, targetname, filter18)
	line(0 255 0, targetname, filter19)
	line(0 255 0, targetname, filter20)
= filter_multi: "一个测试激活器是否符合多个过滤器的过滤器。这允许你构建更复杂的过滤器，例如'允许任何在团队1中的工程师'，或者'除了npc_zombie和npc_headcrab的所有类别以外的所有人。'"
    [
    filtertype(choices) : "逻辑类型" : 0 =
        [
        0: "AND（所有过滤器必须通过）"
        1: "OR（任何过滤器必须通过）"
        ]

    negated(choices) : "否定结果" : 0 : "在使用所选逻辑类型组合子过滤器后是否否定结果。\n使用AND逻辑类型否定结果意味着任何子过滤器必须失败，此过滤器才能通过。\n使用OR逻辑类型否定结果意味着所有子过滤器必须失败，此过滤器才能通过。" =
        [
        0: "否"
        1: "是"
        ]

    filter01(filterclass) : "过滤器1" : : "要测试的激活器过滤器。"
    filter02(filterclass) : "过滤器2" : : "要测试的激活器过滤器。"
    filter03(filterclass) : "过滤器3" : : "要测试的激活器过滤器。"
    filter04(filterclass) : "过滤器4" : : "要测试的激活器过滤器。"
    filter05(filterclass) : "过滤器5" : : "要测试的激活器过滤器。"
    filter06(filterclass) : "过滤器6" : : "要测试的激活器过滤器。"
    filter07(filterclass) : "过滤器7" : : "要测试的激活器过滤器。"
    filter08(filterclass) : "过滤器8" : : "要测试的激活器过滤器。"
    filter09(filterclass) : "过滤器9" : : "要测试的激活器过滤器。"
    filter10(filterclass) : "过滤器10" : : "要测试的激活器过滤器。"
    ]

@SolidClass base(BaseEntityVisBrush, EnableDisable, Toggle) 
    sphere(fademindist)
    sphere(fademaxdist)
= func_brush: "一个具有多种功能的刷子实体。"
    [
    spawnflags(flags)  =
        [
        2: "[2] 忽略玩家+USE" : 1
        ]

    solidity(choices) : "固体性质" : 0 : "固体性质的变化方式。" =
        [
        0: "通过启用/禁用来切换"
        1: "从不固体化"
        2: "始终固体化"
        ]

    excludednpc(string) : "排除碰撞的NPC类" : : "如果这里指定了一个NPC类名，则该类的NPC将不会与这些刷子碰撞。在Episodic中，你也可以指定一个单独实体的名称。"
    invert_exclusion(choices) : "反转NPC类排除" : 0 : "如果设置，则排除的NPC类将认为这个刷子是实体的，而所有其他NPC类将认为它是非实体的。" =
        [
        0: "否"
        1: "是"
        ]

    solidbsp(choices) : "实体BSP" : 0 : "如果这个刷子与某种移动物体有层级关系，并且玩家可以站在这个刷子上，则设置此项。" =
        [
        0: "否"
        1: "是"
        ]


    // 输入
    input SetExcluded(string) : "改变排除碰撞的NPC类。"
    input SetInvert(bool) : "设置NPC类排除的反转状态（0或1）。"
    input Toggle(void) : "切换这个刷子的可见性/实体性。"
    ]

@SolidClass base(BaseEntityVisBrush, Origin) 
    sphere(fademindist)
    sphere(fademaxdist)
= func_buildable_button: "一个定时按钮，它在按钮按下相关事件期间调用其脚本范围。"
    [
    spawnflags(flags)  =
        [
        2048: "[2048] 开始时锁定" : 0
        ]

    is_cumulative_use(choices) : "累积使用" : 0 =
        [
        0: "否"
        1: "是"
        ]


    // 输入
    input Enable(void) : "启用按钮，使其发光并可以使用。"
    input Disable(void) : "禁用按钮，使其无法使用且不发光。"

    // 输出
    output OnPressed(void) : "当按钮被按下时触发。"
    output OnUnPressed(void) : "当按钮被松开时触发。"
    output OnTimeUp(void) : "当按钮被按住的时间超过所需时间时触发。"
    output OnUseLocked(void) : "当按钮在锁定状态下被使用时触发。"
    ]

@SolidClass base(BaseEntityVisBrush, Button) 
    sphere(fademindist)
    sphere(fademaxdist)
= func_button: "一个设计用于玩家可使用按钮的刷子实体。当玩家使用时，它移动到一个按下的位置。不要在按下时锁定；解锁时它不会返回。"
    [
    movedir(angle) : "移动方向（俯仰偏航翻滚）" : "0 0 0" : "指定按钮使用时的移动方向。"
    speed(float) : "速度" : 5 : "按钮移动的速度，单位为每秒多少单位。"
    health(integer) : "健康值（已过时）" : 0 : "传统方法，指定按钮是否可以通过射击来激活。使用'伤害激活'生成标志代替。"
    lip(float) : "凸缘" : 0 : "按钮将与原始位置重叠保留的量。移动的距离=移动轴上的刷子大小 - 凸缘。"
    wait(float) : "重置前延迟（-1保持）" : 3 : "按钮被按下后返回起始位置前的时间量，单位为秒。一旦返回，它可以再次使用。如果值设置为-1，则按钮永远不会返回。"
    spawnflags(flags)  =
        [
        1: "[1] 不移动" : 0
        32: "[32] 切换" : 0
        256: "[256] 触摸激活" : 0
        512: "[512] 伤害激活" : 0
        1024: "[1024] 使用激活" : 1
        2048: "[2048] 开始时锁定" : 0
        4096: "[4096] 火花" : 0
        ]

    ]

@SolidClass base(BaseEntityVisBrush) 
    sphere(fademindist)
    sphere(fademaxdist)
    line(0 255 0, targetname, glow)
= func_button_timed: "一个需要时间来使用的实体。"
    [
    use_time(integer) : "使用时间" : 5
    use_string(string) : "使用字符串" : "使用中...."
    glow(target_destination) : "发光实体" : : "将为此按钮获得+use发光效果的实体的名称。"
    auto_disable(choices) : "自动禁用时间到" : 1 : "当使用计时器时间到时，禁用按钮。（可以通过输入来启用）" =
        [
        0: "否"
        1: "是"
        ]

    spawnflags(flags)  =
        [
        2048: "[2048] 开始时锁定" : 0
        ]

    locked_sound(choices) : "锁定声音" : 0 : "当玩家尝试使用按钮并因为它被锁定而失败时播放的声音。这些是Buttons.snd*类别中的声音。" =
        [
        0: "无（静音）"
        1: "Buttons.snd1: 大电击 & 预热"
        2: "Buttons.snd2: 拒绝访问"
        3: "Buttons.snd3: 允许访问"
        4: "Buttons.snd4: 快速组合锁"
        5: "Buttons.snd5: 动力死锁1"
        6: "Buttons.snd6: 动力死锁2"
        7: "Buttons.snd7: 水泵"
        8: "Buttons.snd8: 小电击"
        9: "Buttons.snd9: 钥匙卡声音"
        10: "Buttons.snd10: 嗡嗡声"
        11: "Buttons.snd11: 嗡嗡声关闭"
        12: "Buttons.snd12: 锁扣锁定"
        13: "Buttons.snd13: 锁扣解锁"
        14: "Buttons.snd14: 电灯开关"
        15: "Buttons.snd15: 小哔哔声"
        16: "Buttons.snd16: 小拒绝声"
        17: "Buttons.snd17: 小哆嗦声"
        18: "Buttons.snd18: 小科技拒绝声"
        19: "Buttons.snd19: 点击和结合屏幕噪音"
        20: "Buttons.snd20: 宽敞的哔声"
        21: "Buttons.snd21: 杠杆或轮子：转动+移动吱吱声"
        22: "Buttons.snd22: 杠杆或轮子：锁扣+释放气体"
        23: "Buttons.snd23: 杠杆或轮子：棘轮+吱吱声"
        24: "Buttons.snd24: 杠杆或轮子：大棘轮"
        25: "Buttons.snd25: 杠杆或轮子：铿锵+气体释放"
        26: "Buttons.snd26: 杠杆或轮子：锁扣+大金属砰声"
        27: "Buttons.snd27: 杠杆或轮子：更小的棘轮"
        28: "Buttons.snd28: 杠杆或轮子：更小的杠杆移动"
        31: "Buttons.snd31: 电击嗡嗡声"
        32: "Buttons.snd32: 点击哔声"
        33: "Buttons.snd33: 科技哔声"
        34: "Buttons.snd34: 点击哔哔声开"
        35: "Buttons.snd35: 小高哔声"
        36: "Buttons.snd36: 小科技嗡嗡哔声"
        37: "Buttons.snd37: 小点击哔哔声（更改为电灯开关）"
        40: "Buttons.snd40: 联合门锁 - 锁定"
        41: "Buttons.snd41: 联合哔声咆哮"
        42: "Buttons.snd42: 联合吱吱声咆哮"
        43: "Buttons.snd43: 联合哀鸣低语"
        44: "Buttons.snd44: 联合点击谈话"
        45: "Buttons.snd45: 联合点击咆哮嘶嘶声"
        46: "Buttons.snd46: 联合点击嘶嘶声（拒绝）"
        47: "Buttons.snd47: 联合点击讲话器"
        ]

    use_sub_string(string) : "使用子字符串"

    // 输入
    input Lock(void) : "锁定按钮，防止其功能并播放锁定声音。"
    input Unlock(void) : "解锁按钮，允许其功能。"
    input Enable(void) : "启用按钮，使其发光并可以使用。"
    input Disable(void) : "禁用按钮，使其无法使用且不发光。"

    // 输出
    output OnPressed(void) : "当按钮被按下时触发。"
    output OnUnPressed(void) : "当按钮被松开时触发。"
    output OnTimeUp(void) : "当按钮被按住的时间超过所需时间时触发。"
    output OnUseLocked(void) : "当按钮在锁定状态下被使用时触发。"
    ]

@SolidClass base(CombineBallSpawners) 
    sphere(ballradius)
= func_combine_ball_spawner: "生成联合球。"
    [

    // 输出
    output OnBallReinserted(void) : "当一个联合球被重新插入到场地时触发（仅当检查了联合动力供应时触发）"
    output OnLastBallGrabbed(void) : "当场地上的最后一个联合球被mega physcannon抓住时触发"
    ]

@SolidClass base(BaseEntityVisBrush) 
    sphere(fademindist)
    sphere(fademaxdist)
= func_conveyor: "一个作为传送带的刷子实体，具有移动表面。表面材料应该有一个ConveyorScroll材料代理，以同步材料移动和推动效果。"
    [
    movedir(angle) : "移动方向（俯仰偏航翻滚）" : "0 0 0" : "传送带移动的方向。"
    spawnflags(flags)  =
        [
        1: "[1] 不推送" : 0
        2: "[2] 非实体" : 0
        ]

    speed(float) : "传送带速度" : 100

    // 输入
    input ToggleDirection(void) : "改变传送带的方向。"
    input SetSpeed(float) : "设置传送带速度。"
    ]

@SolidClass base(BaseEntityVisBrush) 
    sphere(fademindist)
    sphere(fademaxdist)
= func_elevator: "一个垂直移动的刷子实体。"
    [
    top(vecline) : "顶层位置"
    bottom(vecline) : "底层位置"
    speed(integer) : "速度" : 100 : "电梯移动的速度，单位为每秒多少单位。"
    acceleration(integer) : "加速度" : 100 : "电梯接近其目标速度的加速度，单位为每秒每秒多少单位。"
    blockdamage(float) : "阻挡伤害" : 0 : "阻挡电梯的任何实体每帧要受到的伤害量。"
    startsound(sound) : "电梯开始移动时播放的声音。"
stopsound(sound) : "电梯停止移动时播放的声音。"
disablesound(sound) : "电梯被禁用时播放的声音。"

// 输入
input MoveToFloor(string) : "开始移动电梯到指定楼层。"
input Disable(void) : "停止电梯并阻止它再次移动。"
input SetMaxSpeed(float) : "设置电梯的最大速度。"

// 输出
output OnReachedTop(string) : "当刷子到达顶部时触发。"
output OnReachedBottom(string) : "当刷子到达底部时触发。"
]

@SolidClass base(BaseEntityVisBrush) 
    sphere(fademindist)
    sphere(fademaxdist)
    line(255 255 0, targetname, target)
= func_guntarget: "这是一个沿着路径轨道移动的移动目标。它可以被射击并击毁。"
    [
    speed(integer) : "速度（单位每秒）" : 100 : "目标沿其路径移动的速度。"
    target(target_destination) : "生成轨道" : : "这个目标应该跟随的路径中第一个path_track实体的名称。"
    health(integer) : "承受伤害" : 0 : "这个目标被击毁前所承受的伤害量。"

    // 输入
    input Start(void) : "开始移动目标。"
    input Stop(void) : "停止目标的移动。"
    input Toggle(void) : "切换目标的移动和停止状态。"

    // 输出
    output OnDeath(void) : "当目标被击毁时触发。"
    ]

@SolidClass base(BaseEntityVisBrush) 
    sphere(fademindist)
    sphere(fademaxdist)
= func_illusionary: "传统支持。请改用func_brush。一个始终是非实体的刷子。"
    [
    ]

@SolidClass base(BaseEntityVisBrush) 
    sphere(fademindist)
    sphere(fademaxdist)
    sphere(DisappearDist)
    sphere(DisappearMinDist)
    sphere(DisappearMaxDist)
= func_lod: "一个刷子构建的模型，可以在指定距离上淡出。用于创建不需要在远处绘制的世界细节，以提高性能。"
    [
    solid(choices) : "实体" : 0 : "设置这些刷子是否应与其他实体发生碰撞。" =
        [
        0: "实体"
        1: "非实体"
        ]

    disappearmaxdist(integer) : "消失的最大距离" : 2200 : "这些刷子应该完全淡出的距离。"
    disappearmindist(integer) : "开始消失的最小距离" : 2000 : "这些刷子开始淡出的距离。"
    ]

@SolidClass base(BaseEntityVisBrush, Angles) 
    sphere(fademindist)
    sphere(fademaxdist)
    sphere(movedistance)
= func_movelinear: "一个沿着给定距离和给定方向线性移动的刷子实体。"
    [
    movedir(angle) : "移动方向（俯仰偏航翻滚）" : "0 0 0" : "当被告知打开或传递一个正的SetPosition值时，刷子将移动的方向。"
    spawnflags(flags)  =
        [
        8: "[8] 不是实体" : 0
        ]

    startposition(float) : "起始位置" : 0 : "刷子生成时的位置，其中0是起始位置，1是打开位置。负数将位置设置在相反方向。"
    speed(float) : "速度" : 100 : "刷子移动的速度，单位为每秒单位。"
    movedistance(float) : "移动距离" : 100 : "刷子应该从起始点移动的距离。"
    blockdamage(float) : "阻挡伤害" : 0 : "对阻挡刷子的任何实体造成的伤害，每帧。"
    startsound(sound) : "开始声音" : : "刷子开始移动时播放的声音。"
    stopsound(sound) : "停止声音" : : "刷子停止移动时播放的声音。"

    // 输入
    input Open(void) : "将刷子移动到终点位置（起始位置 + （移动方向 * 移动距离））。"
    input Close(void) : "将刷子移动到起始位置。"
    input SetPosition(string) : "将刷子移动到特定位置，其中0是起始位置，1是打开位置。接受任何值，负数在相反方向移动。"
    input SetSpeed(float) : "设置速度并立即更新。"
    input ResetPosition(float) : "为我们当前位置设置一个新的起始位置。"
    input TeleportToTarget(target_destination) : "传送到这个实体的原点。"

    // 输出
    output OnFullyOpen(void) : "当刷子到达终点位置（起始位置 + （移动方向 * 移动距离））时触发。"
    output OnFullyClosed(void) : "当刷子到达起始位置时触发。"
    ]

@SolidClass base(NavCost) = func_nav_avoid: "通过增加该区域的寻路成本来影响机器人避开这个区域。"
    [
    ]

@SolidClass base(NavCost) = func_nav_prefer: "通过降低该区域的寻路成本来影响机器人偏好这个区域。"
    [
    ]

@PointClass base(BaseEntityAnimating, SetModel) 
    sphere(fademindist)
    sphere(fademaxdist)
    studioprop()
    iconsprite("editor/func_orator")
    sphere(maxthenanydispatchdist)
= func_orator: "一个非常简单的模型实体，具有动画和响应规则。"
    [
    spawnflags(flags)  =
        [
        1: "[1] 不是实体" : 1
        ]

    maxthenanydispatchdist(float) : "最大跟随距离" : 0 : "来自这个演讲者的响应上的一个'然后任何'后续操作会被派发到这么多单位距离以外的角色。如果设置为0，意味着即使是无限远的角色也可能响应。"

    // 输入
    input SpeakResponseConcept(string) : "说出指定的响应概念"
    ]

@SolidClass base(BaseEntityVisBrush) 
    sphere(fademindist)
    sphere(fademaxdist)
= func_plat: "一个垂直移动的固体实体。"
    [
    spawnflags(flags)  =
        [
        1: "[1] 切换" : 1
        64: "[64] X轴" : 0
        128: "[128] Y轴" : 0
        ]

    noise1(sound) : "移动声音" : : "固体移动时播放的声音。"
    noise2(sound) : "停止声音" : : "固体停止移动时播放的声音。"
    speed(integer) : "移动速度" : 50 : "固体垂直移动的速度，单位为每秒多少单位。"
    height(integer) : "旅行高度" : 0 : "从起始位置开始，这个平台移动的垂直距离。如果是负数，平台会降低。"

    // 输入
    input Toggle(void) : "切换平台状态。"
    input GoUp(void) : "命令平台上升。"
    input GoDown(void) : "命令平台下降。"
    ]

@SolidClass base(BaseEntityVisBrush, Button) 
    sphere(fademindist)
    sphere(fademaxdist)
    line(255 255 255, targetname, master)
= func_rot_button: "一个设计用于旋转的可供玩家使用的按钮固体实体。当玩家使用时，它会旋转到按下的位置。"
    [
    speed(integer) : "速度" : 50 : "按钮旋转的速度，单位为每秒多少度。"
    health(integer) : "生命值（已过时）" : 0 : "用于指定按钮是否可以通过射击来激活的旧方法。改用'伤害激活'生成标志。"
    wait(integer) : "重置前延迟（-1为保持）" : 3 : "按钮被按下后，返回到起始位置前的时间，单位为秒。一旦返回，它可以再次使用。如果值设置为-1，按钮永远不会返回。"
    distance(integer) : "距离（度）" : 90 : "按钮被按下时应该旋转的角度量。"
    spawnflags(flags)  =
        [
        1: "[1] 不是实体" : 0
        2: "[2] 反向" : 0
        32: "[32] 切换" : 0
        64: "[64] X轴" : 0
        128: "[128] Y轴" : 0
        256: "[256] 触摸激活" : 0
        512: "[512] 伤害激活" : 0
        1024: "[1024] 使用激活" : 0
        2048: "[2048] 开始时锁定" : 0
        4096: "[4096] 火花" : 0
        ]

    ]

@SolidClass base(BaseEntityVisBrush, Origin, Angles) 
    sphere(fademindist)
    sphere(fademaxdist)
= func_rotating: "一个旋转的固体实体。"
    [
    maxspeed(integer) : "最大旋转速度" : 100 : "固体的最大旋转速度，单位为每秒多少度。"
    fanfriction(integer) : "摩擦力（0 - 100%）" : 20 : "旋转的摩擦力。值必须在0到100%之间。较低的值使固体加速和减速更快。"
    message(sound) : "旋转时声音WAV" : : "旋转时播放的声音。"
    volume(integer) : "音量（10为最大）" : 10 : "旋转声音的音量。"
    spawnflags(flags)  =
        [
        1: "[1] 开始时打开" : 0
        2: "[2] 反向" : 0
        4: "[4] X轴" : 0
        8: "[8] Y轴" : 0
        16: "[16] 加速/减速" : 0
        32: "[32] 风扇痛" : 0
        64: "[64] 不是实体" : 0
        128: "[128] 小声音半径" : 0
        256: "[256] 中等声音半径" : 0
        512: "[512] 大声音半径" : 1
        ]

    dmg(integer) : "阻塞伤害" : 0 : "对任何阻塞旋转的实体造成的伤害，每帧。"
    solidbsp(choices) : "实体类型" : 0 =
        [
        0: "VPhysics"
        1: "BSP"
        ]


    // 输入
    input SetSpeed(integer) : "设置速度为指定的最大旋转速度的比例，其中0是停止，1是最大旋转速度。"
    input Start(void) : "开始旋转。"
    input Stop(void) : "停止旋转。"
    input StopAtStartPos(void) : "当它再次到达开始位置时（在其旋转轴上），停止旋转。"
    input StartForward(void) : "以最大速度开始向前旋转。"
    input StartBackward(void) : "以最大速度开始向后旋转。"
    input Toggle(void) : "切换旋转器是否旋转。"
    input Reverse(void) : "反转旋转器的旋转方向，保持当前速度。"
    input SnapToStartPos(void) : "立即回到初始位置并停止移动。"
    ]

@SolidClass base(BaseTank) 
    line(255 255 255, targetname, control_volume)
    line(255 255 255, targetname, TraceFilter)
    sphere(PlayerBBoxDist)
    sphere(minrange)
    sphere(maxrange)
= func_tankmortar: "一个炮塔固体，发射迫击炮弹。这用于HL2 Combine Nexus '压制装置'。"
    [
    imagnitude(integer) : "爆炸威力" : 100
    firedelay(string) : "炮弹飞行时间" : 2 : "炮塔发射后多久炮弹撞击"
    firestartsound(sound) : "开火开始声音" : : "迫击炮开火的声音"
    fireendsound(sound) : "开火结束声音"
    incomingsound(sound) : "来袭炮弹声音" : : "炮弹落在目标上的声音"
    warningtime(float) : "来袭警告时间" : 1 : "炮弹撞击前多久播放警告声音"
    firevariance(float) : "开火时间变化" : 0 : "在开火频率上增加多少变化性（时间+-）"

    // 输入
    input ShootGun(void) : "手动射击炮。"
    input FireAtWill(void) : "允许炮塔在准备好后立即开火。"
    ]

@SolidClass base(BaseEntityVisBrush) 
    sphere(fademindist)
    sphere(fademaxdist)
    line(255 255 0, targetname, target)
= func_train: "Quake时代的老实体。它跟随一系列path_corner实体。尽管大部分功能已被func_tracktrain取代，但这个实体不受那个实体的转向不准确问题的影响，可能更适合快速移动的物体。"
    [
    spawnflags(flags)  =
        [
        8: "[8] 非实体" : 0
        ]

    target(target_destination) : "生成路径角落" : : "火车路径中第一个path_corner的名字。火车将在这个path_corner生成。"
    speed(float) : "速度" : 50 : "火车移动的速度。"
    noise1(sound) : "移动音效" : "Default.Null" : "火车移动时播放的声音。这必须指定，但可以设置为'Default.Null'以不播放任何声音。"
    noise2(sound) : "停止音效" : "Default.Null" : "火车停止移动时播放的声音。这必须指定，但可以设置为'Default.Null'以不播放任何声音。"
    volume(float) : "声音音量 (0-10)" : 10 : "移动和停止时发出的声音的音量。"
    dmg(float) : "压碎伤害" : 0 : "对阻挡火车的实体造成的伤害量。"

    // 输入
    input Toggle(void) : "切换移动"
    input Start(void) : "开始移动"
    input Stop(void) : "停止移动"
    ]

@SolidClass base(BaseEntityVisBrush) 
    sphere(fademindist)
    sphere(fademaxdist)
    line(255 255 255, targetname, target)
= func_traincontrols: "当玩家使用时，该实体会覆盖玩家的控制权，让他们驾驶火车。"
    [
    target(target_destination) : "火车名称" : : "玩家使用这些控制时要控制的目标火车。"
    ]

@SolidClass base(BaseEntityVisBrush) 
    sphere(fademindist)
    sphere(fademaxdist)
= func_wall: "半条命的遗留支持。请改用func_brush。一个通用的刷子实体。"
    [
    ]

@PointClass base(gibshooterbase) 
    iconsprite("editor/gibshooter.vmt")
    color(200 200 0)
    line(255 255 255, targetname, lightingorigin)
= gibshooter: "一个发射碎块的实体。碎块的样式取决于语言类型。"
    [
    ]

@SolidClass base(BaseEntityVisBrush, Angles) 
    sphere(fademindist)
    sphere(fademaxdist)
    line(255 255 255, targetname, master)
= momentary_rot_button: "一个设计用于旋转车轮的刷子实体，玩家可以旋转它们到任意位置然后停止。"
    [
    speed(float) : "速度 (度/秒)" : 50 : "车轮每秒转动的角度。"
    glow(target_destination) : "发光实体" : : "将为这个按钮获得+use发光的实体的名称。"
    sounds(choices) : "声音" : 0 : "按下时播放的声音。从Buttons.snd*类别中选择声音。" =
        [
        0: "无 (静音)"
        1: "Buttons.snd1: 大电击 & 预热"
        2: "Buttons.snd2: 拒绝访问"
        3: "Buttons.snd3: 允许访问"
        4: "Buttons.snd4: 快速组合锁"
        5: "Buttons.snd5: 动力死锁 1"
        6: "Buttons.snd6: 动力死锁 2"
        7: "Buttons.snd7: 水泵"
        8: "Buttons.snd8: 小电击"
        9: "Buttons.snd9: 钥匙卡声音"
        10: "Buttons.snd10: 嗡嗡声"
        11: "Buttons.snd11: 嗡嗡声关闭"
        12: "Buttons.snd12: 锁上"
        13: "Buttons.snd13: 解锁"
        14: "Buttons.snd14: 开关灯"
        15: "Buttons.snd15: 小蜂鸣"
        16: "Buttons.snd16: 小拒绝"
        17: "Buttons.snd17: 小哔哔声"
        18: "Buttons.snd18: 小技术拒绝"
        19: "Buttons.snd19: 点击和组合屏幕噪声"
        20: "Buttons.snd20: 宽敞的哔哔声"
        21: "Buttons.snd21: 杠杆或车轮：转动 + 移动吱吱声"
        22: "Buttons.snd22: 杠杆或车轮：锁上 + 放气"
        23: "Buttons.snd23: 杠杆或车轮：棘轮 + 吱吱声"
        24: "Buttons.snd24: 杠杆或车轮：大棘轮"
        25: "Buttons.snd25: 杠杆或车轮：响亮 + 放气"
        26: "Buttons.snd26: 杠杆或车轮：锁上 + 大金属砰声"
        27: "Buttons.snd27: 杠杆或车轮：小棘轮"
        28: "Buttons.snd28: 杠杆或车轮：小杠杆移动"
        31: "Buttons.snd31: 电击嗡嗡声"
        32: "Buttons.snd32: 点击哔哔声"
        33: "Buttons.snd33: 技术哔哔声"
        34: "Buttons.snd34: 点击哔哔哔声开"
        35: "Buttons.snd35: 小高哔哔声"
        36: "Buttons.snd36: 小技术噪音哔哔声"
        37: "Buttons.snd37: 小点击哔哔声 (变为开关灯)"
        40: "Buttons.snd40: 联合门锁 - 锁定"
        41: "Buttons.snd41: 联合哔哔声咆哮"
        42: "Buttons.snd42: 联合嘶嘶声咆哮"
        43: "Buttons.snd43: 联合呜咽咕噜声"
        44: "Buttons.snd44: 联合点击谈话"
        45: "Buttons.snd45: 联合点击咆哮嘶嘶声"
        46: "Buttons.snd46: 联合点击嘶嘶声 (拒绝)"
        47: "Buttons.snd47: 联合点击讲话者"
        ]

    distance(float) : "距离" : 90 : "车轮允许旋转的最大角度。"
    returnspeed(float) : "自动返回速度" : 0 : "如果没有设置'切换'生成标志，当车轮被放任时自动返回的速度，以度每秒计。"
    spawnflags(flags)  =
        [
        1: "[1] 不实体化" : 1
        32: "[32] 切换 (禁用自动返回)" : 1
        64: "[64] X 轴" : 0
        128: "[128] Y 轴" : 0
        1024: "[1024] 使用激活" : 1
        2048: "[2048] 开始时锁定" : 0
        8192: "[8192] 锁定时使用时晃动" : 0
        ]

    startposition(float) : "起始位置" : 0 : "生成时的位置。该值在0.0和1.0之间，其中0是未旋转位置，1是旋转位置 + '距离'。"
startdirection(choices) : "开始方向" : -1 : "指定按钮首次使用时的移动方向。如果起始位置是0或1，则忽略此设置。" =
        [
        -1: "前进"
        1: "后退"
        ]

    solidbsp(choices) : "实体BSP" : 0 : "如果设置，使用SOLID_BSP碰撞类型。" =
        [
        0: "否"
        1: "是"
        ]


    // 输入
    input Lock(void) : "锁定按钮，阻止其功能。"
    input Unlock(void) : "解锁按钮，允许其功能。"
    input SetPosition(string) : "移动到一个位置。参数必须是0到1之间的值，其中0是未旋转位置，1是旋转位置+ '距离'。"
    input SetPositionImmediately(string) : "立即传送到一个位置。参数必须是0到1之间的值，其中0是未旋转位置，1是旋转位置+ '距离'。"
    input Enable(void) : "启用按钮，允许它被USE。"
    input Disable(void) : "禁用按钮，使其默默地忽略玩家。"

    // 输出
    output Position(integer) : "每当按钮移动时触发。输出是按钮从0到1的位置，其中0是未旋转位置，1是旋转位置+ '距离'。"
    output OnPressed(integer) : "当按钮首次被按下时触发。"
    output OnUnpressed(integer) : "当按钮首次被释放时触发。"
    output OnFullyClosed(void) : "当按钮到达位置1，即旋转位置+ '距离'时触发。"
    output OnFullyOpen(void) : "当按钮到达位置0，即未旋转的起始位置时触发。"
    output OnReachedPosition(void) : "每当按钮到达一个目标位置时触发：即当它变为开启、关闭或到达由'SetPosition'输入指定的点时。"
    ]

@PointClass base(BaseNPCMaker) 
    line(255 16 16, targetname, ignoreentity)
    color(0 0 255)
    iconsprite("editor/ficool2/npc_template_maker.vmt")
    line(255 255 0, targetname, templatename)
    sphere(radius)
    sphere(minspawndistance)
    line(255 255 0, targetname, destinationgroup)
= npc_template_maker: "一个创建NPC的实体。它创建的NPC是模板NPC的克隆。NPC在这个制造者的原点周围或在指定的目的地点产生。"
    [
    spawnflags(flags)  =
        [
        256: "[256] 始终使用半径产生" : 0
        512: "[512] 不预载模板模型" : 0
        ]

    templatename(target_destination) : "模板NPC的名称" : : "这个制造者应该克隆创建的模板NPC。"
    radius(float) : "半径" : 256 : "在这个制造者周围的半径内，NPC将被放置。产生的NPC将尝试在这个半径内找到空位产生。"
    destinationgroup(target_destination) : "目的地组的名称" : : "如果你希望产生的NPC在info_npc_spawn_destination实体处创建，请在这里输入该实体的名称。如果你有多个同名的目的地实体，将使用目的地标准来从组中选择一个。"
    criterionvisibility(choices) : "目的地标准：对玩家可见？" : 2 : "NPC尝试在玩家能看见的目的地产生吗？只有在使用目的地组时才适用。" =
        [
        0: "是"
        1: "否"
        2: "不关心"
        ]

    criteriondistance(choices) : "目的地标准：与玩家的距离？" : 2 : "NPC尝试产生在离玩家当前位置最近或最远的地方吗？只有在使用目的地组时才适用。" =
        [
        0: "最近"
        1: "最远"
        2: "不关心"
        ]

    minspawndistance(integer) : "玩家与产生点的最小距离" : 0 : "产生目的地节点到玩家的距离必须大于或等于这个值。"

    // 输入
    input SpawnNPCInRadius(void) : "在制造者半径内的某处产生一个NPC。"
    input SpawnNPCInLine(void) : "在制造者后方的一条线内的某处产生一个NPC。"
    input SpawnMultiple(integer) : "产生多个NPC（使用目的地组，否则是半径）。"
    input ChangeDestinationGroup(target_destination) : "切换到不同的目的地实体组。"
    input SetMinimumSpawnDistance(integer) : "设置玩家到目的地节点的最小产生距离。"
    ]

@PointClass base(TwoObjectPhysics) 
	line(255 255 0, targetname, attach1)
	line(0 0 255, targetname, attach2)
	line(128 128 128, targetname, constraintsystem)
	sphere(teleportfollowdistance)
	iconsprite("editor/phys_ballsocket.vmt")
	line(255 255 255, targetname, attach1)
	line(255 255 255, targetname, attach2)
	line(128 128 128, targetname, attach1, targetname, attach2)
	color(128 128 128)
= phys_ballsocket: "一个约束，保持两个物体相对于约束原点的位置固定。它不影响旋转。"
    [
    ]

@PointClass base(TwoObjectPhysics) 
	line(255 255 0, targetname, attach1)
	line(0 0 255, targetname, attach2)
	line(128 128 128, targetname, constraintsystem)
	sphere(teleportfollowdistance)
	studio("models/editor/axis_helper.mdl")
	line(255 255 255, targetname, attach1)
	line(255 255 255, targetname, attach2)
	line(128 128 128, targetname, attach1, targetname, attach2)
	color(128 128 128)
= phys_constraint: "一个约束，保持两个物体的相对位置和方向固定。"
    [
    ]

@PointClass base(TwoObjectPhysics) 
	line(255 255 0, targetname, attach1)
	line(0 0 255, targetname, attach2)
	line(128 128 128, targetname, constraintsystem)
	sphere(teleportfollowdistance)
	line(128 128 128, targetname, attach1)
	line(128 128 128, targetname, attach2)
	line(128 128 128, targetname, attach1, targetname, attach2)
	color(128 128 128)
	iconsprite("editor/ficool2/phys_hinge")
= phys_hinge: "一个物理模拟的铰链。使用助手来定义旋转轴。"
    [
    hingefriction(float) : "摩擦" : 0 : "铰链中的阻力/摩擦"
    hingeaxis(vecline) : "铰链轴"
    systemloadscale(float) : "负载比例" : 1 : "连接到这个铰链的负载比例（1=仅直接连接的物体）"
    minsoundthreshold(float) : "最小声音速度" : 6 : "当以低于这个速度的单位/秒行驶时，将不会播放任何声音。"
    maxsoundthreshold(float) : "全声音速度" : 80 : "当以这个速度或更高速度行驶时，将以全音量播放声音。"
    slidesoundfwd(sound) : "行进声音（前进）" : : "当沿助手轴向前行驶时播放这个声音"
    slidesoundback(sound) : "行进声音（后退）" : : "当沿助手轴向后行驶时播放这个声音"
    reversalsoundthresholdsmall(float) : "反转声音阈值（小）" : 0 : "当以超过这个单位/秒^2的加速度逆向行驶时，播放小的反转声音。"
    reversalsoundthresholdmedium(float) : "反转声音阈值（中）" : 0 : "当以超过这个单位/秒^2的加速度逆向行驶时，播放中等的反转声音。"
    reversalsoundthresholdlarge(float) : "反转声音阈值（大）" : 0 : "当以超过这个单位/秒^2的加速度逆向行驶时，播放大的反转声音。"
    reversalsoundsmall(sound) : "反转声音（小）" : : "当硬反转超过小阈值但小于中等阈值时播放这个声音"
    reversalsoundmedium(sound) : "反转声音（中）" : : "当硬反转超过中等阈值但小于大阈值时播放这个声音"
    reversalsoundlarge(sound) : "反转声音（大）" : : "当硬反转超过大阈值时播放这个声音"

    // 输入
    input SetAngularVelocity(float) : "以度/秒设置绕铰链（马达）的角速度。"
    input SetHingeFriction(float) : "改变铰链中的摩擦。"
    ]

@PointClass base(TwoObjectPhysics) 
	line(255 255 0, targetname, attach1)
	line(0 0 255, targetname, attach2)
	line(128 128 128, targetname, constraintsystem)
	sphere(teleportfollowdistance)
	studio("models/editor/axis_helper.mdl")
	line(255 255 255, targetname, attach1)
	line(255 255 255, targetname, attach2)
	line(128 128 128, targetname, attach1, targetname, attach2)
	sphere(minlength)
	color(128 128 128)
= phys_lengthconstraint: "一个约束，保留两个实体之间的距离。如果设置了'保持刚性'标志，可以将其视为一根杆。如果没有，可以将其视为虚拟绳。"
    [
    addlength(float) : "额外长度" : 0 : "在绳索的休息长度上增加（或减去）这个数值。"
    minlength(float) : "最小长度" : 0 : "如果约束不是刚性的，这是它可以有的最小长度。"
    attachpoint(vecline) : "附着物体2点" : "绳索附着到物体2的位置"
    spawnflags(flags)  =
        [
        1: "[1] 断裂前无碰撞" : 1
        2: "[2] 保持刚性" : 0
        ]

    ]

@PointClass base(BaseEntityAnimating, SetModel) 
	sphere(fademindist)
	sphere(fademaxdist)
	studio()
	color(128 128 128)
	iconsprite("editor/vizzys/phys_magnet")
= phys_magnet: "一个像磁铁一样的实体，当金属物理对象接触它时，它会将它们吸附到自己身上。"
    [
    spawnflags(flags)  =
        [
        1: "[1] 开始时休眠" : 0
        2: "[2] 禁止运动" : 0
        4: "[4] 接触即吸" : 0
        8: "[8] 允许附着旋转" : 0
        ]

    forcelimit(float) : "断裂力限制（磅）" : 0 : "打破粘在磁铁上的物体所需的力量。计算方法是将其设置为如果物体静止在磁铁上时会打破这个约束的物体质量。"
    torquelimit(float) : "扭矩限制以断裂（磅*距离）" : 0 : "打破粘在磁铁上的物体所需的扭矩。计算方法是将任何参考质量乘以打破约束所需的静止距离（从物体的质心计算）。"
    massscale(float) : "质量比例" : 0 : "物体质量的比例乘数。"
    overridescript(string) : "覆盖参数" : : "通常在物理道具.qc文件中的物理键/值对列表。格式是'键,值,键,值,等'。"
    maxobjects(integer) : "最大附着物体数量" : 0 : "可以同时粘在磁铁上的物理物体的最大数量。0 = 无限制。"

    // 输入
    input TurnOn(void) : "打开磁铁。"
    input TurnOff(void) : "关闭磁铁。这将分离任何当前粘在磁铁上的东西。"
    input Toggle(void) : "切换磁铁的开或关。"

    // 输出
    output OnAttach(void) : "当一个实体被磁铁抓住时触发。"
    output OnDetach(void) : "当一个实体被磁铁释放时触发。"
    ]

@PointClass base(TwoObjectPhysics) 
	line(255 255 0, targetname, attach1)
	line(0 0 255, targetname, attach2)
	line(128 128 128, targetname, constraintsystem)
	sphere(teleportfollowdistance)
	studio("models/editor/axis_helper.mdl")
	line(255 255 255, targetname, attach1)
	line(255 255 255, targetname, attach2)
	line(128 128 128, targetname, attach1, targetname, attach2)
	color(128 128 128)
= phys_pulleyconstraint: "一个约束，本质上是两个长度约束和两个点。想象它是连接到两个物体的虚拟绳索，每个物体都悬挂在它们上方的滑轮下。这个约束保持滑轮点与它们悬挂物体之间的距离总和恒定。"
    [
    addlength(float) : "额外长度" : 0 : "在滑轮绳索的休息长度上增加（或减去）这个数值。"
    gearratio(float) : "滑轮齿轮比" : 1 : "在滑轮绳索的休息长度上增加（或减去）这个数值。"
    position2(vecline) : "滑轮位置2" : : "物体2的滑轮位置。物体1的滑轮是这个约束实体的原点。物体1总是从滑轮点1悬挂，物体2总是从滑轮点2悬挂。"
    spawnflags(flags)  =
        [
        1: "[1] 断裂前无碰撞" : 1
        2: "[2] 保持刚性" : 0
        ]

    ]

@PointClass base(TwoObjectPhysics) 
	line(255 255 0, targetname, attach1)
	line(0 0 255, targetname, attach2)
	line(128 128 128, targetname, constraintsystem)
	sphere(teleportfollowdistance)
	studio("models/editor/axis_helper.mdl")
	line(255 255 255, targetname, attach1)
	line(255 255 255, targetname, attach2)
	line(128 128 128, targetname, attach1, targetname, attach2)
	color(128 128 128)
= phys_ragdollconstraint: "一个约束，固定两个实体的位置，相对于这个约束的原点。还允许在每个轴上限制旋转，以这个约束的空间为准。"
    [
    spawnflags(flags)  =
        [
        1: "[1] 断裂前无碰撞" : 1
        2: "[2] 仅限制旋转（自由移动）" : 0
        ]

    xmin(float) : "X轴最小限制" : -90 : "-180最小和180最大 = 这个轴上没有约束。"
    xmax(float) : "X轴最大限制" : 90 : "-180最小和180最大 = 这个轴上没有约束。"
    ymin(float) : "Y轴最小限制" : 0 : "-180最小和180最大 = 这个轴上没有约束。"
    ymax(float) : "Y轴最大限制" : 0 : "-180最小和180最大 = 这个轴上没有约束。"
    zmin(float) : "Z轴最小限制" : 0 : "-180最小和180最大 = 这个轴上没有约束。"
    zmax(float) : "Z轴最大限制" : 0 : "-180最小和180最大 = 这个轴上没有约束。"
    xfriction(float) : "X轴摩擦" : 0
    yfriction(float) : "Y轴摩擦" : 0
    zfriction(float) : "Z轴摩擦" : 0
    ]

@PointClass base(TwoObjectPhysics) 
    line(255 255 0, targetname, attach1)
    line(0 0 255, targetname, attach2)
    line(128 128 128, targetname, constraintsystem)
    sphere(teleportfollowdistance)
    halfgridsnap
    studio("models/editor/axis_helper.mdl")
    line(255 255 255, targetname, attach1)
    line(255 255 255, targetname, attach2)
    line(128 128 128, targetname, attach1, targetname, attach2)
    color(128 128 128)
= phys_slideconstraint: "一个约束，限制实体沿线段移动。"
    [
    spawnflags(flags)  =
        [
        1: "[1] 断裂前无碰撞" : 1
        2: "[2] 限制端点" : 0
        ]

    slideaxis(vecline) : "滑动轴"
    slidefriction(float) : "摩擦" : 0 : "约束中的阻力/摩擦"
    systemloadscale(float) : "负载比例" : 1 : "连接到这个约束的质量负载的比例（1=仅直接连接的物体）"
    minsoundthreshold(float) : "最小声音速度" : 6 : "当以低于这个速度的单位/秒行驶时，将不会播放任何声音。"
    maxsoundthreshold(float) : "全声音速度" : 80 : "当以这个速度或更高速度行驶时，将以全音量播放声音。"
    slidesoundfwd(sound) : "行进声音（前进）" : : "当沿助手轴向前行驶时播放这个声音"
    slidesoundback(sound) : "行进声音（后退）" : : "当沿助手轴向后行驶时播放这个声音"
    reversalsoundthresholdsmall(float) : "反转声音阈值（小）" : 0 : "当以超过这个单位/秒^2的加速度逆向行驶时，播放小的反转声音。"
    reversalsoundthresholdmedium(float) : "反转声音阈值（中）" : 0 : "当以超过这个单位/秒^2的加速度逆向行驶时，播放中等的反转声音。"
    reversalsoundthresholdlarge(float) : "反转声音阈值（大）" : 0 : "当以超过这个单位/秒^2的加速度逆向行驶时，播放大的反转声音。"
    reversalsoundsmall(sound) : "反转声音（小）" : : "当硬反转超过小阈值但小于中等阈值时播放这个声音"
    reversalsoundmedium(sound) : "反转声音（中）" : : "当硬反转超过中等阈值但小于大阈值时播放这个声音"
    reversalsoundlarge(sound) : "反转声音（大）" : : "当硬反转超过大阈值时播放这个声音"

    // 输入
    input SetVelocity(float) : "设置沿约束的线性速度"
    ]

@PointClass base(Angles, ForceController) 
    line(128 128 128, targetname, attach1)
    size(-8 -8 -8, 8 8 8)
    line(255 255 255, targetname, attach1)
    color(128 128 128)
= phys_thruster: "一个用于对物理对象施加恒定加速度的实体。力和扭矩是使用推进器的位置和方向作为冲量计算的。因此，将这些移动到物体的中心之外也会产生扭矩。可以通过取消选中'施加扭矩'标志来移除扭矩。通过选中'忽略位置'标志，可以将推进器的位置强制设置在物体的中心。"
    [
    spawnflags(flags)  =
        [
        32: "[32] 忽略位置" : 0
        ]

    force(string) : "力" : 0 : "力（将被积分，单位是力kg*in/s^2）"
    ]

@PointClass base(ForceController) 
    line(128 128 128, targetname, attach1)
    size(-8 -8 -8, 8 8 8)
    halfgridsnap
    line(255 255 255, targetname, attach1)
    color(128 128 128)
= phys_torque: "一个角推进器。用它来对实体施加角力。"
    [
    force(string) : "角加速度" : 0
    axis(vecline) : "旋转轴"
    ]

@PointClass base(BaseEntityPhysics) 
    sphere(fademindist)
    sphere(fademaxdist)
    sphere(expradius)
    studioprop()
= physics_cannister: "一个物理模拟的气罐，可以射击其盖子使其脱落，此时气体将开始逸出，导致罐子飞舞。如果受到足够的伤害，它将爆炸。模型应该有一个'喷嘴'附件点，这是气体逸出和推力产生的地方。"
    [
    model(studio) : "模型" : "models/props_c17/canister01a.mdl" : "用于气罐的模型。FGD中原始模型指定为fire_equipment/w_weldtank.mdl，但该模型不存在。"
    spawnflags(flags)  =
        [
        1: "[1] 开始时休眠" : 0
        2: "[2] 爆炸" : 1
        ]

    expdamage(float) : "爆炸伤害" : "200.0" : "气罐爆炸时产生的爆炸伤害量。"
    expradius(float) : "爆炸半径" : "250.0" : "气罐爆炸时产生的爆炸半径。"
    health(integer) : "健康" : 25 : "气罐在爆炸前承受的伤害量。"
    thrust(float) : "推力" : "3000.0" : "当盖子被吹掉，逸出的气体推动气罐时，这是产生的推力量。"
    fuel(float) : "燃料秒数" : "12.0" : "气罐漏气的时间，之后被认为是空的。"
    rendercolor(color255) : "烟雾颜色（R G B）" : "255 255 255"
    renderamt(integer) : "烟雾透明度（0 - 255）" : 128
    gassound(sound) : "推进器声音" : "PhysicsCannister.ThrusterLoop" : "气罐逸出气体时播放的声音。"

    // 输入
    input Activate(string) : "开始从气罐逸出气体。"
    input Deactivate(string) : "停止从气罐逸出气体。"
    input Explode(string) : "强制气罐爆炸。"
    input Wake(void) : "如果气罐正在休眠，唤醒它。"

    // 输出
    output OnActivate(void) : "当气体开始从气罐逸出时触发。"
    output OnAwakened(void) : "当这个实体醒来时触发（应用碰撞/力）。"
    ]

@PointClass base(BaseEntityAnimating, EnableDisable) 
    sphere(fademindist)
    sphere(fademaxdist)
    studio("models/extras/info_speech.mdl")
= point_commentary_node: "开发者评论的评论节点。通常在事后由评论系统添加，但也可以手动放置。"
    [
    commentaryfile(sound) : "评论文件" : : "当这个被触发时将播放的声音。"
    commentaryfile_nohdr(sound) : "评论文件（无HDR）" : : "如果HDR关闭且此项存在，将播放它。"
    speakers(string) : "发言者" : : "进行评论的角色/人物。"
    startdisabled(choices) : "开始时禁用" : 0 : "它应该被禁用吗？" =
        [
        0: "否"
        1: "是"
        ]

    prevent_movement(choices) : "阻止移动？" : 0 : "如果启用，玩家在评论播放时将无法移动。" =
        [
        0: "否"
        1: "是"
        ]

    precommands(string) : "预先命令" : : "在声音文件播放前将触发的命令。使用分号分隔多个命令。"
    postcommands(string) : "之后命令" : : "在声音文件播放后将触发的命令。也接受分号。"
    viewposition(target_destination) : "视角位置" : : "玩家视角将移动到的实体的目标名称。"
    viewtarget(target_destination) : "视角目标" : : "玩家视角将跟踪的实体的目标名称。如果设置，玩家不能移动他们的相机。"

    // 输入
    input StartCommentary(void) : "开始评论，就像玩家+USE这个一样。"
    input StopCommentary(void) : "强制停止评论节点。"
    input StartUnstoppableCommentary(void) : "开始评论，但不让玩家取消它。"

    // 输出
    output OnCommentaryStarted(void) : "当评论开始时触发。"
    output OnCommentaryStopped(void) : "当评论停止时触发。如果设置了viewposition，这会在玩家的视角返回到常规视角后触发。"
    ]

@BaseClass base(BaseEntityAnimating, SetModel, BreakableProp, Glow) = prop_dynamic_base
    [
    spawnflags(flags)  =
        [
        64: "[64] 使用Hitboxes作为Renderbox" : 0
        256: "[256] 开始时禁用碰撞" : 0
        ]

    defaultanim(string) : "默认动画" : : "这个道具在完成一个随机或强制动画后将恢复到的空闲动画的名称。"
    randomanimation(choices) : "随机动画" : 0 : "如果设置，这个道具将基于在'Min/Max Random Anim Time'中指定的时间随机选择并播放动画。在随机动画之间，它将恢复播放'默认动画'。" =
        [
        0: "否"
        1: "是"
        ]

    minanimtime(float) : "最小随机动画时间" : 5 : "随机动画之间的最小时间。"
    maxanimtime(float) : "最大随机动画时间" : 10 : "随机动画之间的最大时间。"
    disablebonefollowers(choices) : "禁用骨骼跟随者" : 0 : "如果设置，即使道具定义了骨骼跟随者，也不会使用它们。" =
        [
        0: "否"
        1: "是"
        ]

    lagcompensate(choices) : "滞后补偿" : 0 : "设置为是以滞后补偿这个道具，应该非常谨慎使用！" =
        [
        0: "否"
        1: "是"
        ]

    glowbackfacemult(float) : "发光背面乘数" : "1.0" : "在背面上乘以发光的数值，"

    // 输入
    input SetAnimation(string) : "强制道具播放动画。参数应该是动画的名称。"
    input SetDefaultAnimation(string) : "将默认动画设置为参数中指定的动画。"
    input SetPlaybackRate(float) : "设置动画的播放速率。"
    input SetBodyGroup(integer) : "通过索引设置可见的bodygroup。"
    input TurnOn(void) : "使道具可见。"
    input TurnOff(void) : "使道具不可见。"
    input EnableCollision(void) : "启用道具的碰撞。"
    input DisableCollision(void) : "禁用道具的碰撞。"

    // 输出
    output OnAnimationBegun(void) : "每当一个新动画开始播放时触发。"
    output OnAnimationDone(void) : "每当一个动画完成时触发。"
    ]

@PointClass base(BaseEntityPhysics, SetModel) 
    studioprop()
    sphere(fademindist)
    sphere(fademaxdist)
= prop_fuel_barrel: "一个像燃料桶一样的物理道具，当射击时会有反应"
    [
    spawnflags(flags)  =
        [
        1: "[1] 开始时休眠" : 0
        ]

    fademindist(float) : "开始淡出距离/像素" : -1 : "道具开始淡出的距离（<0 = 从fademaxdist减去）。"
    fademaxdist(float) : "结束淡出距离/像素" : 0 : "道具可见的最大距离（0 = 不淡出）。"
    fadescale(float) : "淡出比例" : 1 : "如果你在worldspawn中指定了淡出，或者如果引擎在低端/中端/XBox360下运行，那么引擎将强制淡出道具，即使没有指定fademindist/fademaxdist。这个比例因子给了你一些对淡出的控制。这里使用0关闭强制淡出。小于1的数字使道具在更远的距离淡出，大于1的数字使它在更近的距离淡出。"
    model(studio) : "模型" : "models/props_industrial/barrel_fuel.mdl"
    basepiece(studio) : "基础部件" : "models/props_industrial/barrel_fuel_partb.mdl"
    flyingpiece01(studio) : "飞行部件1" : "models/props_industrial/barrel_fuel_parta.mdl"
flyingpiece02(studio) : "飞行碎片2"
flyingpiece03(studio) : "飞行碎片3"
flyingpiece04(studio) : "飞行碎片4"
detonateparticles(string) : "爆炸粒子" : "weapon_pipebomb"
flyingparticles(string) : "飞行碎片粒子" : "barrel_fly"
detonatesound(sound) : "物体爆炸时播放的声音。" : "BaseGrenade.Explode"
    ]

@PointClass base(BaseEntityPhysics, EnableDisable, SetModel) 
    sphere(fademindist)
    sphere(fademaxdist)
    studioprop()
= prop_ragdoll: "一个物理模拟的道具，可以用内部关节进行操作。关节约束是物理模型的一部分。"
    [
    spawnflags(flags)  =
        [
        4: "[4] 碎片 - 不与玩家或其他碎片碰撞" : 1
        8192: "[8192] 允许溶解" : 0
        16384: "[16384] 禁止运动" : 0
        32768: "[32768] 允许伸展" : 0
        65536: "[65536] 开始时休眠" : 0
        ]

    angleoverride(string) : "动画覆盖" : : "由引擎通过hammer_update_entity填充，不要手动编辑，除非清除。"

    // 输入
    input StartRagdollBoogie(float) : "开始ragdoll boogie效果。参数覆盖=boogie的秒数。"
    input EnableMotion(void) : "启用物理运动/碰撞响应。"
    input DisableMotion(void) : "禁用物理运动/碰撞响应。"
    input FadeAndRemove(float) : "淡出然后移除（杀死）自己。参数覆盖=淡出持续时间"
    ]

@PointClass base(BaseEntityAnimating, SetModel) 
    sphere(fademindist)
    sphere(fademaxdist)
    studioprop()
= prop_wall_breakable: "像门一样可以破坏的墙壁部分。"
    [
    spawnflags(flags)  =
        [
        524288: "[524288] 开始时不可破坏" : 0
        ]


    // 输入
    input SetUnbreakable(void) : "墙壁不可破坏。"
    input SetBreakable(void) : "墙壁可以破坏。"

    // 输出
    output OnBreak(void) : "当墙壁改变受损状态时触发。"
    ]

@PointClass base(BaseEntityPhysics, SetModel) 
    sphere(fademindist)
    sphere(fademaxdist)
    studioprop()
= scripted_item_drop: "一个具有基本物理特性并能检测到玩家触摸的道具。"
    [
    ]

@SolidClass base(BaseEntityVisBrush) 
    sphere(fademindist)
    sphere(fademaxdist)
= simple_physics_brush: "一个简单的物理刷，没有独特的属性。通过phys_convert转换的基于刷的实体会变成这个实体。如果需要更多选项，请使用func_physbox。"
    [
    ]

@SolidClass base(TriggerOnce) 
    line(255 255 255, targetname, filtername)
= trigger_autosave: "当玩家触摸时自动保存的触发器体积。"
    [
    newlevelunit(choices) : "强制新的关卡单元" : 0 : "如果设置，保存将丢弃之前关卡的所有保存数据，以减小保存文件大小。只有在玩家无法返回之前的关卡时才能安全使用。" =
        [
        0: "否"
        1: "是"
        ]

    dangeroustimer(float) : "危险计时器" : 0 : "玩家必须存活多少秒后此自动保存才生效。"
    minimumhitpoints(integer) : "最小生命值" : 0 : "玩家生命值低于此数值时不保存危险状态。"
    ]

@PointClass base(BaseEntityAnimating, EnableDisable) 
    sphere(fademindist)
    sphere(fademaxdist)
    studioprop()
= trigger_finale: "终章触发器"
    [
    model(studio) : "模型" : "models/props/terror/hamradio.mdl"
    firstusedelay(float) : "首次使用延迟" : 0 : "对于分两部分开始的终章，延迟这么多秒后才允许另一个+use。"
    usedelay(float) : "使用延迟" : 0 : "+use后多少秒开始终章。"
    type(choices) : "终章类型" : 0 : "指定要触发的终章风格" =
        [
        0: "标准"
        1: "关卡"
        2: "自定义"
        4: "搜集"
        ]

    scriptfile(string) : "脚本文件"
    versustravelcompletion(float) : "对抗模式旅行" : "0.2" : "在对抗模式中通过旅行到终章获得的分数（在关卡终章中无效）"
    issacrificefinale(choices) : "是否为牺牲终章" : 0 : "如果为真，一个幸存者必须在逃生车辆外执行某些操作。" =
        [
        0: "否"
        1: "是"
        ]


    // 输入
    input FinaleEscapeFinished(void) : "给幸存者一个胜利。"
    input FinaleEscapeForceSurvivorPositions(void) : "让幸存者在逃生车辆上站立不动。"
    input FinaleEscapeVehicleReadyForSurvivors(void) : "解锁逃生车辆导航网格区域，并让幸存者说出车辆已经到达。"
    input ForceFinaleStart(void) : "现在开始终章。"
    input GauntletStopPanic(void) : "将关卡终章状态移出连续恐慌模式"
    input AdvanceFinaleState(void) : "增加终章状态"
    input SacrificeEscapeFailed(void) : "表明幸存者未能达到逃生要求"
    input SacrificeEscapeSucceeded(void) : "表明幸存者满足了逃生要求"
    input SacrificePlayerBeginsRun(void) : "玩家（!Activator）已经开始牺牲跑"
    input ForceTankSpawn(void) : "可能仅用于正在进行的关卡风格终章。"

    // 输出
    output FinaleEscapeStarted(void) : "当幸存者应该开始逃生时触发。"
    output FinaleWon(void) : "当幸存者赢得终章时触发。"
    output FinaleLost(void) : "当幸存者输掉终章时触发。"
    output FirstUseStart(void) : "当玩家第一次使用触发器时触发。"
    output UseStart(void) : "当玩家使用触发器开始终章时触发。"
    output FinaleStart(void) : "当终章开始时触发。"
    output FinalePause(void) : "在每次终章波间的暂停时触发。"
    output EscapeVehicleLeaving(void) : "当逃生车辆开始离开时触发。"
    ]

@SolidClass base(TriggerOnce) 
    line(255 255 255, targetname, filtername)
= trigger_once: "触发一次后自行移除的触发器体积。"
    [
    ]

@PointClass base(BaseEntityAnimating) 
    sphere(fademindist)
    sphere(fademaxdist)
    studioprop()
= trigger_standoff: "对峙触发器"
    [
    model(studio) : "模型" : "models/props/terror/hamradio.mdl"
    spawnflags(flags)  =
        [
        512: "[512] 禁用+use" : 0
        ]

    useduration(float) : "使用持续时间" : 0 : "幸存者必须+use触发器多少秒才能开始终章（0是立即）。"
    usedelay(float) : "使用延迟" : 0 : "+use后多少秒开始终章。"

    // 输入
    input FinaleEscapeFinished(void) : "给幸存者一个胜利。"
    input FinaleEscapeForceSurvivorPositions(void) : "让幸存者在逃生车辆上站立不动。"
    input FinaleEscapeVehicleReadyForSurvivors(void) : "让幸存者说出车辆已经停下来。"
    input ForceFinaleStart(void) : "现在开始终章。"

    // 输出
    output FinaleEscapeStarted(void) : "当幸存者应该开始逃生时触发。"
    output FinaleWon(void) : "当幸存者赢得终章时触发。"
    output FinaleLost(void) : "当幸存者输掉终章时触发。"
    output UseStart(void) : "当基于持续时间的+use开始时触发。"
    output UseCancel(void) : "当基于持续时间的+use提前停止时触发。"
    output FinaleStart(void) : "当终章开始时触发。"
    output FinalePause(void) : "在每次终章波间的暂停时触发。"
    output EscapeVehicleLeaving(void) : "当逃生车辆开始离开时触发。"
    ]

@BaseClass base(BaseLogicalNPC) = BaseNPC: "仅适用于可见NPC的行为。"
    [
    target(target_destination) : "目标路径角" : : "如果设置，这个NPC生成后会走向的路径角实体的名称。"
    expressionoverride(sound) : "表情覆盖" : : "输入一个VCD文件来覆盖这个NPC的面部表情。"
    dontusespeechsemaphore(choices) : "不使用语音信号量？" : 0 : "友好NPC不允许在另一个友好NPC说话时说话。在某些情况下，我们不希望说话的NPC阻止其他NPC说话（例如，如果一个友好NPC在监视器上长时间说话）。为了让这个NPC在说话时不阻止其他NPC，让它在说话时不抢占信号量。" =
        [
        0: "否（使用语音信号量）"
        1: "是（不使用语音信号量）"
        ]

    linedivider_npc(string) readonly : "=========================================================================================================="

    // 输入
    input SetBodyGroup(integer) : "黑客：设置这个NPC的身体组（从0 - n）。你最好知道你在做什么！"
    input SetExpressionOverride(string) : "设置一个VCD文件来覆盖这个NPC的面部表情。"
    ]

@BaseClass base(WeaponSpawnSingle) = WeaponSpawn
    [
    count(integer) : "数量" : 5 : "消失前提供的最大武器数量。"
    spawnflags(flags)  =
        [
        4: "[4] 吸收任何掉落的武器类型" : 0
        ]

    ]

@SolidClass base(Trigger) 
    line(255 255 255, targetname, filtername)
= color_correction_volume: "一个控制地图中颜色校正的实体。"
    [
    spawnflags(flags)  =
        [
        ]

    filtername(filterclass) readonly : "过滤器名称（忽略）" : : "触发器体积有一个过滤器，但它被忽略了。"
    fadeduration(float) : "查找淡入淡出持续时间" : "10.0" : "查找在进入/退出时淡入/淡出的持续时间"
    maxweight(float) : "最大权重" : "1.0" : "这是这个查找表的最大权重"
    filename(string) : "查找表文件名" : : "这是查找表的文件名"
    ]

@PointClass base(env_shooter) 
    iconsprite("editor/ficool2/env_rotorshooter.vmt")
    line(255 255 255, targetname, lightingorigin)
    color(200 200 0)
= env_rotorshooter: "当在直升机的旋翼洗涤影响范围内时，创建碎片的实体。"
    [
    rotortime(float) : "旋翼下时间" : 1 : "平均需要在旋翼下多久时间才能射出一个碎片。"
    rotortimevariance(float) : "时间变化" : "0.3" : "随机变化在旋翼下需要多久时间才能射出一个碎片。"
    ]

@SolidClass base(func_brush) = func_block_charge: "充电器不会穿过这个刷子"
    [
    ]

@SolidClass base(BreakableBrush) 
    sphere(fademindist)
    sphere(fademaxdist)
    sphere(exploderadius)
= func_breakable: "一个可以因为伤害或输入而破坏的刷实体。"
    [
    minhealthdmg(integer) : "最小伤害以受伤" : 0 : "如果伤害小于此数值，该道具将忽略任何伤害事件。"
physdamagescale(float) : "物理撞击伤害比例" : "1.0" : "当这个物体被物理对象击中时，伤害能量的比例。注意：0意味着为了向后兼容而禁用了这个功能。\n设置为1.0表示材料和肉体一样坚固，更小的数字表示更坚固的材料。"
]

@SolidClass base(Door, Angles, Origin) 
    sphere(fademindist)
    sphere(fademaxdist)
    line(255 255 255, targetname, master)
    line(255 255 255, targetname, chainstodoor)
= func_door: "用作玩家可使用门的固体实体。"
    [
    movedir(angle) : "移动方向（俯仰偏航翻滚）" : "0 0 0" : "门打开时的移动方向。"
    ]

@SolidClass base(Door, Angles, Origin) 
    sphere(fademindist)
    sphere(fademaxdist)
    line(255 255 255, targetname, master)
    line(255 255 255, targetname, chainstodoor)
= func_door_rotating: "用作旋转玩家可使用门的固体实体。"
    [
    spawnflags(flags)  =
        [
        2: "[2] 反向" : 0
        16: "[16] 单向" : 0
        64: "[64] X轴" : 0
        128: "[128] Y轴" : 0
        65536: "[65536] 新的func_door +USE规则（不适用于prop_doors!!）" : 0
        ]

    distance(float) : "距离" : 90 : "门打开时应旋转的角度，以度为单位。"
    solidbsp(choices) : "实体类型" : 0 : "如何计算碰撞。BSP更基础，但允许与玩家更稳定的碰撞。" =
        [
        0: "VPhysics"
        1: "BSP"
        ]

    always_fire_blocked_outputs(choices) : "始终触发阻塞输出" : 0 =
        [
        0: "否"
        1: "是"
        ]

    ]

@SolidClass base(func_brush) 
    sphere(fademindist)
    sphere(fademaxdist)
    line(255 255 0, targetname, target)
= func_monitor: "一个显示器，用于渲染来自给定点摄像机实体的视图。"
    [
    target(target_destination) : "摄像机名称"

    // 输入
    input Toggle(void) : "切换 - 如果开启，关闭；如果关闭，开启。"
    input Enable(void) : "启用。"
    input Disable(void) : "禁用。"
    input SetCamera(target_destination) : "设置此显示器使用的摄像机。使用地图中的点摄像机实体的名称。"
    ]

@SolidClass base(func_plat) 
    sphere(fademindist)
    sphere(fademaxdist)
= func_platrot: "一个垂直移动并且可以在移动时旋转的固体实体。"
    [
    speed(integer) : "移动速度" : 50 : "固体垂直移动的速度，单位为每秒多少单位。它将在相同的时间内完成旋转。"
    rotation(integer) : "旋转量" : 0 : "这个平台在移动时应该旋转的角度，以度为单位。"

    // 输入
    input Toggle(void) : "切换平台的状态。"
    input GoUp(void) : "命令平台向上移动。"
    input GoDown(void) : "命令平台向下移动。"
    ]

@SolidClass base(func_brush) 
    sphere(fademindist)
    sphere(fademaxdist)
= func_playerghostinfected_clip: "简单的剪辑固体，阻止玩家幽灵感染者的移动。"
    [
    ]

@SolidClass base(func_brush) 
    sphere(fademindist)
    sphere(fademaxdist)
= func_playerinfected_clip: "简单的剪辑固体，阻止玩家感染者的移动。"
    [
    ]

@SolidClass base(func_brush) 
    sphere(fademindist)
    sphere(fademaxdist)
= func_reflective_glass: "用于生成完美反射的玻璃，渲染世界+实体。通常，你希望你的玻璃固体在所有非反射表面上都有不绘制效果，并且你希望在材质中应用到非不绘制表面的着色器，比如lightmappedreflective。参见hl2/materials/glass/reflectiveglass001.vmt的示例。注意：目前，你不能在有水的场景中使用反射玻璃，并且在你的视锥体（+ pvs）中一次只能有1个反射玻璃。除非玩家处于第三人称模式，否则他们不会看到自己的倒影。"
    [
    ]

@SolidClass base(BaseTrain) 
    sphere(fademindist)
    sphere(fademaxdist)
    line(255 255 0, targetname, target)
= func_tanktrain: "一个移动的火车，沿着路径轨迹实体的路径行驶，向玩家射击，并且可以被摧毁。\n注意：建造你的火车，使得火车的前部朝向X轴。当它生成时，它会自动旋转以面向路径上的下一个路径轨迹。"
    [
    health(integer) : "生命值" : 100

    // 输出
    output OnDeath(void) : "当坦克被杀死时触发。"
    ]

@SolidClass base(BaseTrain) 
    sphere(fademindist)
    sphere(fademaxdist)
    line(255 255 0, targetname, target)
= func_tracktrain: "一个玩家可以乘坐的移动平台。它沿着路径轨迹实体的路径行驶。\n注意：建造你的火车，使得火车的前部朝向X轴。当它生成时，它会自动旋转以面向路径上的下一个路径轨迹。"
    [
    ]

@SolidClass base(func_wall) 
    sphere(fademindist)
    sphere(fademaxdist)
= func_wall_toggle: "半条命的遗留支持。使用func_brush替代。一个可以切换开/关的通用固体实体。关闭时，固体将是非实体的并且不可见的。不投射光照贴图阴影。"
    [
    spawnflags(flags)  =
        [
        1: "[1] 起始时不可见" : 0
        ]


    // 输入
    input Toggle(void) : "切换固体的开/关。关闭时，固体将是非实体的并且不可见。"
    ]

@SolidClass base(func_movelinear) 
    sphere(fademindist)
    sphere(fademaxdist)
    sphere(movedistance)
= func_water_analog: "一个沿着给定距离线性移动的水固体实体，以给定方向移动。这只是带有水物理碰撞的func_movelinear。"
    [
    movedir(angle) : "移动方向（俯仰偏航翻滚）" : "0 0 0" : "被告知'打开'时水的移动方向。"
    startposition(float) : "起始位置" : 0 : "水固体生成时的位置。范围是0.0到1.0之间的值，其中0是起始位置，1是起始位置 + （移动方向 * 移动距离）。"
    speed(float) : "速度" : 100 : "水固体移动的速度，单位为每秒多少单位。"
    movedistance(float) : "移动距离" : 100 : "水固体应该移动的距离，单位为单位。"
    startsound(sound) : "水固体开始移动时播放的声音。"
    stopsound(sound) : "水固体停止移动时播放的声音。"

    // 输入
    input Open(void) : "将水固体移动到结束位置（起始位置 + （移动方向 * 移动距离））。"
    input Close(void) : "将水固体移动到起始位置。"
    input SetPosition(string) : "将水固体移动到0.0到1.0之间的特定位置，其中0是起始位置，1是起始位置 + （移动方向 * 移动距离）。"

    // 输出
    output OnFullyOpen(void) : "当水固体达到结束位置（起始位置 + （移动方向 * 移动距离））时触发。"
    output OnFullyClosed(void) : "当水固体达到起始位置时触发。"
    ]

@NpcClass base(BaseLogicalNPC) 
    sphere(fademindist)
    sphere(fademaxdist)
    line(255 0 0, targetname, enemyfilter)
    iconsprite("editor/bullseye.vmt")
    color(255 0 0)
= npc_bullseye: "用于定位或其他行为的虚拟NPC。"
    [
    linedivider_npc(string) readonly : "=========================================================================================================="
    rendermode(choices) readonly : "渲染模式" : 1 : "这必须设置为颜色，以便Hammer正确渲染精灵。它在引擎中不使用。" =
        [
        1: "颜色"
        ]

    health(integer) : "生命值" : 35 : "与其他NPC不同，关卡设计者被允许设置bullseyes的生命值。"
    minangle(float) : "最小角度" : 360 : "bullseye被视为有效敌人所需的bullseye角度。"
    mindist(float) : "最小距离" : 0 : "bullseye被视为有效敌人所需的bullseye距离。"
    autoaimradius(float) : "自动瞄准半径" : 0 : "自动瞄准影响半径。使用ent_autoaim <picker>来可视化。"
    spawnflags(flags)  =
        [
        65536: "[65536] 不是实体" : 0
        131072: "[131072] 不受伤害" : 0
        262144: "[262144] 只有敌人伤害" : 0
        524288: "[524288] 流血" : 0
        1048576: "[1048576] 完美准确性" : 0
        2097152: "[2097152] 与物理对象碰撞（创建VPhysics影子）" : 0
        ]


    // 输入
    input InputTargeted(void) : "触发OnTargeted输出。"
    input InputReleased(void) : "触发OnReleased输出。"

    // 输出
    output OnTargeted(void) : "当被定位时触发。"
    output OnReleased(void) : "当不再被定位时触发。"
    ]

@NpcClass base(BaseLogicalNPC) 
    sphere(fademindist)
    sphere(fademaxdist)
    line(255 0 0, targetname, enemyfilter)
    color(255 150 0)
    iconsprite("editor/vizzys/npc_enemyfinder.vmt")
    sphere(MinSearchDist)
    sphere(MaxSearchDist)
= npc_enemyfinder: "敌人发现者"
    [
    spawnflags(flags)  =
        [
        65536: "[65536] 检查可见性" : 1
        131072: "[131072] APC可见性检查" : 0
        262144: "[262144] 短期记忆" : 0
        524288: "[524288] 可以成为敌人" : 0
        ]

    rendermode(choices) readonly : "渲染模式" : 1 : "这必须设置为颜色，以便Hammer正确渲染精灵。它在引擎中不使用。" =
        [
        1: "颜色"
        ]

    fieldofview(float) : "视野范围" : "0.2" : "查看多远（1.0 = 正前方，0.0 = +/- 90度，-1.0 = 所有方向）"
    minsearchdist(integer) : "最小搜索距离" : 0
    maxsearchdist(integer) : "最大搜索距离" : 2048
    freepass_timetotrigger(float) : "玩家通过问题时间" : 0 : "敌人隐藏后授予“自由通行证”的时间量"
    freepass_duration(float) : "玩家通过持续时间" : 0 : "授予“自由通行证”后，目标被允许的时间量再次被获取"
    freepass_movetolerance(float) : "玩家通过移动容忍度" : 120 : "授予“自由通行证”后，目标被允许移动的距离再次被获取"
    freepass_refillrate(float) : "玩家通过补充率" : "0.5" : "自由通行证开始过期后，目标每隐藏一秒钟再次获得的时间量"
    freepass_peektime(float) : "玩家通过窥视时间" : 0 : "目标在掩体中被允许窥视而不受惩罚的时间长短"
    starton(choices) : "开始" : 1 =
        [
        0: "否"
        1: "是"
        ]


    // 输入
    input TurnOn(void) : "打开：寻找敌人"
    input TurnOff(void) : "关闭：停止寻找敌人"
    input FieldOfView(float) : "设置视野范围。"
    input MinSearchDist(integer) : "设置最小搜索距离。"
    input MaxSearchDist(integer) : "设置最大搜索距离。"

    // 输出
    output OnLostEnemies(void) : "当敌人发现者没有敌人时触发。"
    output OnAcquireEnemies(void) : "当敌人发现者获取敌人时触发。"
    ]

@PointClass base(prop_dynamic_base, Glow) 
    sphere(exploderadius)
    sphere(fademindist)
    sphere(fademaxdist)
    studioprop()
= prop_door_rotating: "用于在世界中放置门的实体。"
    [
    slavename(target_destination) : "从属名称" : : "应该从属于这扇门的任何门的名称（即，当这扇门打开时应该打开，当这扇门关闭时应该关闭）。"
    hardware(choices) : "硬件类型" : 1 =
        [
        0: "<无>"
        1: "杠杆"
        2: "推杆"
        3: "键盘"
        ]

    ajarangles(angle) : "微开角度（俯仰 偏航 翻滚）" : "0 0 0" : "如果门的“生成位置”设置为微开，这些是生成时的角度，而不是打开或关闭。"
    spawnpos(choices) : "生成位置" : 0 =
        [
        0: "关闭"
        1: "顺时针打开"
        2: "逆时针打开"
        3: "微开（使用微开角度）"
        ]

    axis(axis) : "铰链轴"
    distance(float) : "旋转距离（度）" : 90 : "门打开时应旋转的度数。"
    speed(float) : "速度" : 100 : "门移动的速度。"
    soundopenoverride(sound) : "完全打开声音" : : "门打开完成时播放的声音。"
    soundcloseoverride(sound) : "完全关闭声音" : : "门关闭完成时播放的声音。"
    soundmoveoverride(sound) : "移动声音" : : "门开始移动时播放的声音。"
    returndelay(integer) : "关闭前延迟（-1保持打开）" : -1 : "门打开后关闭前的时间量，以秒为单位。如果设置值为-1，门不会自行关闭。"
    dmg(integer) : "阻挡时造成的伤害" : 0 : "阻挡这扇门移动的实体每帧造成的伤害量。"
    health(integer) : "健康值（0=不可破坏）" : 0
    soundlockedoverride(sound) : "锁定声音" : : "玩家尝试打开门但因为门被锁定而失败时播放的声音。"
    soundunlockedoverride(sound) : "解锁声音" : : "门解锁时播放的声音。"
    forceclosed(choices) : "强制关闭" : 0 : "如果设置，这扇门无论如何都会关闭。适用于即使玩家试图用物体阻挡也必须关闭的门。" =
        [
        0: "否"
        1: "是"
        ]

    spawnflags(flags)  =
        [
        256: "[256] 以禁用碰撞开始" : 0
        2048: "[2048] 开始时锁定" : 0
        4096: "[4096] 门静音（无声，不警告NPC）" : 0
        8192: "[8192] 使用关闭" : 1
        16384: "[16384] 对NPC静音（不警告NPC）" : 0
        32768: "[32768] 忽略玩家+USE" : 0
        524288: "[524288] 开始不可破坏" : 0
        ]

    opendir(choices) : "开门方向" : 0 : "强制门只向前或只向后开。两个方向是标准门行为。" =
        [
        0: "两个方向都开"
        1: "只顺时针开"
        2: "只逆时针开"
        ]


    // 输入
    input Open(void) : "打开门，如果它没有完全打开。"
    input OpenAwayFrom(string) : "远离指定实体打开门。"
    input Close(void) : "关闭门，如果它没有完全关闭。"
    input Toggle(void) : "切换门的开闭状态。"
    input Lock(void) : "锁定门。"
    input Unlock(void) : "解锁门。"
    input SetRotationDistance(float) : "设置打开和关闭之间的距离（以度为单位）。"
    input SetSpeed(float) : "设置门旋转的速度。100是默认值。"
    input SetUnbreakable(void) : "门不能被破坏。"
    input SetBreakable(void) : "门可以被破坏。"

    // 输出
    output OnClose(void) : "当门被命令关闭时触发。"
    output OnOpen(void) : "当门被命令打开时触发。"
    output OnFullyOpen(void) : "当门达到完全打开位置时触发。"
    output OnFullyClosed(void) : "当门达到完全关闭位置时触发。"
    output OnBlockedClosing(void) : "当门在关闭时被阻挡时触发。"
    output OnBlockedOpening(void) : "当门在打开时被阻挡时触发。"
    output OnUnblockedClosing(void) : "当门在关闭时被解除阻挡时触发。"
    output OnUnblockedOpening(void) : "当门在打开时被解除阻挡时触发。"
    output OnLockedUse(void) : "当玩家使用门但门被锁定时触发。"
    output OnBreak(void) : "当门的伤害状态发生变化时触发。"
    ]

@PointClass base(prop_dynamic_base, EnableDisable) 
    sphere(exploderadius)
    studioprop()
    sphere(fademindist)
    sphere(fademaxdist)
= prop_dynamic: "可以放置在层级中的道具，并且可以播放动画。它也可以配置为在受到足够伤害时破坏。请注意，对象的健康值将被模型内的健康值覆盖，以确保游戏范围内的健康值一致。如果道具使用的模型被配置为用作prop_physics（即，它应该是物理模拟的），那么它通常不能用作prop_dynamic。在关卡加载时，它将在控制台中显示警告并自行移除。请改用prop_dynamic_override。"
    [
    ]

@PointClass base(prop_dynamic_base) 
    sphere(exploderadius)
    studioprop()
    sphere(fademindist)
    sphere(fademaxdist)
= prop_dynamic_ornament: "一种将一个工作室模型作为装饰附加到另一个模型上的方法。它将以玩家/NPC武器渲染的方式渲染。"
    [
    solid(choices) readonly : "碰撞" : 0 : "碰撞不正确地跟随目标实体，因此这应该始终是非固体的。" =
        [
        0: "不固体"
        ]

    initialowner(target_destination) : "目标实体" : : "这个装饰品应该在启动时附加的实体的名称。"

    // 输入
    input SetAttached(target_destination) : "将装饰品附加到不同的实体。参数应该是要附加的实体的名称。"
    input Detach(string) : "从目标实体分离并变得不可见。装饰品可以使用SetAttached输入重新附加。"
    ]

@PointClass base(prop_dynamic_base, EnableDisable) 
    sphere(exploderadius)
    studioprop()
    sphere(fademindist)
    sphere(fademaxdist)
= prop_dynamic_override: "prop_dynamic的变体，允许使用任何模型，包括那些设计用作prop_dynamic/prop_static的模型。"
    [
    health(integer) : "健康值" : 0 : "在破裂前承受的伤害点数。0表示不破裂。"
    ]

@PointClass base(prop_dynamic_base, EnableDisable) 
    sphere(exploderadius)
    sphere(fademindist)
    sphere(fademaxdist)
    studioprop()
= prop_health_cabinet: "健康柜"
    [
    model(studio) : "模型" : "models/props_interiors/medicalcabinet02.mdl"
    healthcount(integer) : "止痛药数量" : 1 : "柜内止痛药/急救包的数量（1-4）"
    ]

@PointClass base(prop_dynamic_base, EnableDisable) 
    sphere(exploderadius)
    studioprop()
    sphere(fademindist)
    sphere(fademaxdist)
= prop_minigun: "玩家可以+USE的固定枪"
    [
    model(studio) : "模型" : "models/w_models/weapons/w_minigun.mdl"
    maxyaw(float) : "最大偏航" : 90 : "枪可以转动的最大偏航角度。"
    maxpitch(float) : "最大俯仰" : 60 : "枪可以抑制的最大俯仰角度。"
    minpitch(float) : "最小俯仰" : -30 : "枪可以抬高的最小俯仰角度。"

    // 输出
    output OnFireStart(void) : "当机枪开始旋转并开始射击时触发。"
    output OnFireStop(void) : "当机枪停止射击时触发。"
    ]

@PointClass base(prop_dynamic_base, EnableDisable) 
    sphere(exploderadius)
    sphere(fademindist)
    sphere(fademaxdist)
    studioprop("models/w_models/weapons/w_minigun.mdl")
= prop_minigun_l4d1: "玩家可以+USE的固定枪"
    [
    model(studio) : "模型" : "models/w_models/weapons/w_minigun.mdl"
    maxyaw(float) : "最大偏航" : 90 : "枪可以转动的最大偏航角度。"
    maxpitch(float) : "最大俯仰" : 60 : "枪可以抑制的最大俯仰角度。"
    minpitch(float) : "最小俯仰" : -30 : "枪可以抬高的最小俯仰角度。"

    // 输出
    output OnFireStart(void) : "当机枪开始旋转并开始射击时触发。"
    output OnFireStop(void) : "当机枪停止射击时触发。"
    ]

@PointClass base(prop_dynamic_base, EnableDisable) 
    sphere(exploderadius)
    studioprop()
    sphere(fademindist)
    sphere(fademaxdist)
= prop_mounted_machine_gun: "50口径固定机枪（+USE）"
    [
    model(studio) : "模型" : "models/w_models/weapons/50cal.mdl"
    maxyaw(float) : "最大偏航" : 90 : "枪可以转动的最大偏航角度。"
    maxpitch(float) : "最大俯仰" : 60 : "枪可以抑制的最大俯仰角度。"
    minpitch(float) : "最小俯仰" : -30 : "枪可以抬高的最小俯仰角度。"

    // 输出
    output OnFireStart(void) : "当机枪开始射击时触发。"
    output OnFireStop(void) : "当机枪停止射击时触发。"
    ]

@PointClass base(BasePropPhysics, SetModel) 
    studioprop()
    sphere(fademindist)
    sphere(fademaxdist)
= prop_physics: "一个作为单个刚体物理模拟的道具。它可以使用铰链或其他约束与其他物理对象进行约束。它也可以配置为在受到足够伤害时破裂。请注意，对象的健康值将被模型内的健康值覆盖，以确保游戏范围内的健康值一致。如果道具使用的模型被配置为用作prop_dynamic（即，它不应该是物理模拟的），那么它通常不能用作prop_physics。在关卡加载时，它将在控制台中显示警告并自行移除。请改用prop_physics_override。"
    [

    // 输入
    input Ignite(void) : "点燃，突然燃烧起来。"
    input IgniteLifetime(float) : "点燃，参数为寿命。"
    input IgniteNumHitboxFires(integer) : "点燃，参数为命中箱火焰数量。"
    input IgniteHitboxFireScale(float) : "点燃，参数为命中箱火焰比例。"
    ]

@PointClass base(BasePropPhysics, SetModel) 
    sphere(fademindist)
    sphere(fademaxdist)
    studioprop()
    sphere(radius)
= prop_sphere: "一个具有完美球形的prop_physics变体。通常限制在12单位的半径内。"
    [
    ]

@PointClass base(prop_dynamic_base, SetModel) 
    sphere(exploderadius)
    sphere(fademindist)
    sphere(fademaxdist)
    studioprop()
    color(240 180 250)
= prop_vehicle_choreo_generic: "用于脚本事件的通用Choreo车辆。"
    [
    model(studio) : "模型" : : "使用的模型。"
    vehiclescript(string) : "车辆脚本文件" : "scripts/vehicles/choreo_vehicle.txt"
    ignoreplayer(choices) : "忽略玩家碰撞" : 0 : "玩家移动时不会与该车辆碰撞。" =
        [
        0: "否"
        1: "是"
        ]


    // 输入
    input Open(void) : "播放车辆的打开动画并解锁车辆以供进出。"
    input Close(void) : "播放车辆的关闭动画并锁定车辆以供进出。"
    input EnterVehicle(void) : "强制激活器（或玩家）进入车辆。"
    input EnterVehicleImmediate(void) : "强制激活器（或玩家）立即进入车辆，无需进出动画。"
    input ExitVehicle(void) : "将玩家从车辆中赶出。"
    input Viewlock(bool) : "设置为真以防止玩家*完全*环顾四周。设置为假以允许他们在限制内环顾。"
    input SetAnimation(string) : "强制道具播放动画。参数应为动画名称。"

    // 输出
    output OnOpen(void) : "当车辆打开足够供人进入时触发。"
    output OnClose(void) : "当车辆关闭得太紧无法进入时触发。"
    ]

@PointClass base(BasePropPhysics, BaseDriveableVehicle, SetModel) 
    sphere(fademindist)
    sphere(fademaxdist)
    studioprop()
= prop_vehicle_driveable: "通用可驾驶的studiomodel车辆。"
    [
    ]

@PointClass base(BasePropPhysics) 
    sphere(fademindist)
    sphere(fademaxdist)
    studioprop()
= simple_physics_prop: "一个没有独特属性的简单物理道具。通过phys_convert转换的基于模型的实体会变成这种实体，以及溶解的对象。更多选项请参见prop_physics。"
    [
    ]

@SolidClass base(Trigger) 
    line(255 255 255, targetname, filtername)
= trigger_active_weapon_detect: "当玩家触碰并且激活特定武器时触发输出"
    [
    weaponclassname(string) : "要检测的武器" : "weapon_dieselcan" : "玩家必须激活的武器类名"

    // 输出
    output OnTouchedActiveWeapon(void) : "触碰到激活我们武器的玩家时触发"
    ]

@SolidClass base(Trigger) 
    line(255 255 255, targetname, filtername)
= trigger_auto_crouch: "允许触碰触发器的玩家自动蹲下。"
    [
    ]

@SolidClass base(Trigger) 
    line(255 255 255, targetname, filtername)
    line(255 255 255, targetname, landmark)
    color(200 0 0)
= trigger_changelevel: "触发关卡变换的实体。\n在两个地图中放置一个info_landmark，标记每个地图中的“相同”位置。\n提示与技巧：要在下一个关卡中触发事件，请使用OnLevelChange输出在当前关卡中打开一个env_global。在下一个关卡中创建一个logic_auto，检查env_global设置的状态。\n\n要控制哪些实体通过关卡转换，请创建一个或多个trigger_transitions，并给它们命名与地标相同。任何在trigger_transition(s)内的实体都会转到下一个地图。"
    [
    map(string) : "新地图名称"
    landmark(target_destination) : "地标名称"
    spawnflags(flags)  =
        [
        2: "[2] 禁用触碰" : 0
        4: "[4] 到前一章节 - 如果地图是从新游戏加载的则禁用" : 0
        ]


    // 输入
    input ChangeLevel(void) : "引起关卡变换。当使用按钮等触发关卡变换时使用此项。"

    // 输出
    output OnChangeLevel(void) : "当关卡变化时触发。"
    ]

@SolidClass base(Trigger) 
    line(255 255 255, targetname, filtername)
= trigger_escape: "指示体积内是否有幸存者可以逃离终局"
    [

    // 输出
    output OnEscapePossible(void) : "如果至少有1个幸存者站在触发器内，则触发"
    output OnEscapeImpossible(void) : "如果触发器内没有幸存者，则触发"
    ]

@SolidClass base(Trigger) 
    line(255 255 255, targetname, filtername)
= trigger_gravity: "改变触碰它的任何实体的重力的触发器体积。"
    [
    gravity(float) : "重力（0-1）" : 1
    ]

@SolidClass base(Trigger, DamageType) 
    line(255 255 255, targetname, filtername)
    line(255 255 255, targetname, master)
= trigger_hurt: "伤害触碰它的实体的触发器体积。"
    [
    damage(integer) : "伤害" : 20 : "对触碰此触发器的实体造成的伤害量。每半秒造成一次伤害。有关如何造成伤害的更多细节，请参见“伤害模型”。"
    damagecap(integer) : "伤害上限" : 20 : "使用宽恕翻倍伤害模型时能够造成的最大伤害量。"
    damagemodel(choices) : "伤害模型" : 0 : "如何造成伤害。正常情况下，每半秒总是造成指定量的伤害。宽恕翻倍开始时以指定量造成伤害，并在触碰者受伤时将其翻倍，当他们离开触发器时重置。适用于制造随时间致命的触发器，而不必在每次触碰时造成大量伤害。" =
        [
        0: "正常"
        1: "宽恕翻倍"
        ]

    nodmgforce(choices) : "零伤害力" : 0 : "受伤的实体是否不接受来自此触发器的物理力。" =
        [
        0: "否"
        1: "是"
        ]

    damageforce(vector) : "伤害力覆盖"
    thinkalways(choices) : "始终每帧思考" : 0 : "通常触发器每半秒思考一次，在某些情况下，您可能需要要求它每帧造成伤害。这是昂贵的！" =
        [
        0: "否"
        1: "是"
        ]


    // 输入
    input SetDamage(float) : "为此触发器设置新的伤害量。"

    // 输出
    output OnHurt(void) : "每当此触发器伤害到非玩家的东西时触发。"
    output OnHurtPlayer(void) : "每当此触发器伤害到玩家时触发。"
    ]

@SolidClass base(Trigger, Origin, Angles) 
    line(255 255 255, targetname, filtername)
= trigger_impact: "一个可以告知推动其内部所有物理对象的触发器体积，方向由此触发器的角度指定。\n还输出冲击时的力量，以供其他需要使用的人使用。"
    [
    magnitude(float) : "强度" : 200 : "冲击的强度。负值反转方向。"
    noise(float) : "噪声" : "0.1" : "方向噪声的量（0-1）。0 = 无噪声，1 = 随机方向。"
    viewkick(float) : "视角踢" : "0.05" : "如果玩家在触发器内，玩家视角踢的量。与强度成正比（0-1）。"

    // 输入
    input Impact(float) : "触发冲击，推动体积内的所有实体。"
    input SetMagnitude(float) : "设置冲击的强度。"

    // 输出
    output ImpactForce(string) : "冲击后触发。传递的参数是生成的冲击力。"
    ]

@SolidClass base(Trigger) 
	line(255 255 255, targetname, filtername)
	line(255 255 0, targetname, target)
= trigger_look: "当玩家看着某物时用于触发某事的实体。当玩家在触发体积内看着目标实体一定时间时，它会触发'OnTrigger'。如果玩家离开触发区或从目标实体看向别处，计时器将重置。如果选中了'Use Velocity instead of facing'生成标志，触发器将使用玩家的速度而不是玩家的视线，因此它可以确定玩家何时朝着目标实体移动。在玩家开车向某物驶去时触发很有用。注意：仅设计用于单人游戏。"
    [
    spawnflags(flags)  =
        [
        128: "[128] 触发一次" : 1
        256: "[256] 使用速度而非面向" : 0
        ]

    target(target_destination) : "看向目标" : : "要被看的实体的名称。"
    looktime(float) : "看向时间" : "0.5" : "玩家必须看向目标的时间（以秒为单位）才能触发输出。如果玩家离开触发器，或看向视野阈值以外，则重置。"
    fieldofview(float) : "视野" : "0.9" : "玩家必须多么接近目标。1.0 = 完全正前方，0.0 = +/- 90度，-1.0 = 所有方向）。这实际上是cos(角度)。"
    timeout(float) : "超时" : 0 : "玩家进入触发器后等待的时间（以秒为单位），在此之后如果玩家从未看向目标，则触发OnTimeout输出，0 = 永不。"
    notlookingfrequency(float) : "未看向频率" : "0.5" : "两次触发OnNotLooking输出之间的时间（以秒为单位）。"

    // 输入
    input FieldOfView(float) : "设置视野。"
    input LookTime(float) : "设置所需的看向时间。"

    // 输出
    output OnTrigger(void) : "当触发器被激活时触发。"
    output OnTimeout(void) : "在超时间隔过后如果玩家从未看向目标则触发。"
    ]

@SolidClass base(Trigger) 
    line(255 255 255, targetname, filtername)
= trigger_multiple: "一个可以多次触发的触发体积。"
    [
    wait(float) : "重置前延迟" : 1 : "在最初接触后，trigger_multiple再次触发OnTrigger的时间（以秒为单位），如果他们仍在接触的话。如果设置为-1，则永远不会再次触发（在这种情况下，您应该只使用trigger_once）。如果设置为0，则将重置为0.2秒。这仅影响OnTrigger输出，不影响OnStartTouch/OnEndTouch等。"
    entireteam(choices) : "整个队伍编号" : 0 : "如果整个队伍正在接触，则触发OnEntireTeamStartTouch。" =
        [
        0: "无"
        2: "幸存者"
        3: "感染者"
        ]

    allowincap(choices) : "昏迷玩家可以触发" : 0 =
        [
        0: "否"
        1: "是"
        ]

    allowghost(choices) : "幽灵玩家可以触发" : 0 =
        [
        0: "否"
        1: "是"
        ]


    // 输出
    output OnTrigger(void) : "每当触发器被激活并且等待时间已过时，反复触发。"
    output OnEntireTeamStartTouch(void) : "当整个队伍开始接触触发器时触发。"
    output OnEntireTeamEndTouch(void) : "当整个队伍停止接触触发器时触发。"
    ]

@SolidClass base(Trigger) 
    line(255 255 255, targetname, filtername)
= trigger_playermovement: "一个用于禁用玩家在跳跃时自动蹲下/站起的实体。"
    [
    spawnflags(flags)  =
        [
        16: "[16] （'禁用自动玩家移动'的过时别名，取消勾选我）" : 0
        128: "[128] 禁用自动玩家移动" : 1
        2048: "[2048] 在触发器内自动蹲下" : 0
        4096: "[4096] 在触发器内自动行走" : 0
        8192: "[8192] 在触发器内禁用跳跃" : 1
        ]

    ]

@SolidClass base(Trigger) 
    line(255 255 255, targetname, filtername)
    line(255 255 255, targetname, measuretarget)
    sphere(radius)
= trigger_proximity: "测量玩家在触发体积内距离给定点（和给定半径内）的距离。NearestPlayerDistance输出在玩家位于中心点时为0，当玩家在半径处时为1。"
    [
    measuretarget(target_destination) : "测量起点" : : "要测量玩家距离的目标实体的起点的名称。"
    radius(float) : "测量半径" : 256 : "距离应映射到的半径。如果玩家在半径外，则将被忽略。"

    // 输出
    output NearestEntityDistance(float) : "当实体接触触发体积时连续触发。输出参数是从测量起点到通过触发器过滤器的最近实体的距离。距离映射到半径距离，因此当实体在点上时为0，当实体在半径边缘时为1。!activator是最近的实体。"
    ]

@SolidClass base(Trigger) 
    line(255 255 255, targetname, filtername)
= trigger_push: "一个推动接触它的实体的触发体积。"
    [
    pushdir(angle) : "推动方向（俯仰 偏航 翻滚）" : "0 0 0" : "指示推动接触实体的方向的角度。"
    spawnflags(flags)  =
        [
        128: "[128] 触发一次，然后删除触发器" : 0
        256: "[256] 影响梯子（半条命2）" : 0
        4096: "[4096] 正确计算对象质量（trigger_push曾假设为100公斤）和多组分物理对象（汽车，斑点...）" : 1
        ]

    speed(integer) : "推动速度" : 40 : "以单位/秒的速度将实体推开。"
    alternateticksfix(float) : "交替tick的力量缩放" : 0 : "如果非零，当使用交替ticks运行时，按此量缩放力量。这修复了由于在使用sv_alternateticks 1运行时较长的帧时间导致的过大力量的问题。"
    triggeronstarttouch(choices) : "开始接触时触发" : 0 : "在开始接触而不是在接触时触发。" =
        [
        0: "否"
        1: "是"
        ]


    // 输入
    input SetPushSpeed(integer) : "设置单位/秒的推动速度。"
    ]

@SolidClass base(Trigger) 
    line(255 255 255, targetname, filtername)
= trigger_remove: "一个移除任何接触它的实体的触发体积。小心，移除一些实体可能会导致不稳定。这不同于杀死实体。即以这种方式移除的NPC不会触发它们的OnKilled输出。"
    [

    // 输出
    output OnRemove(void) : "每当实体被移除时触发。"
    ]

@SolidClass base(Trigger) 
    line(255 255 255, targetname, filtername)
= trigger_serverragdoll: "一个强制任何在其内部的NPC创建服务器端布娃娃而不是客户端布娃娃的体积。"
    [
    ]

@SolidClass base(Trigger) 
    line(255 255 255, targetname, soundscape)
    line(255 255 255, targetname, filtername)
= trigger_soundscape: "声景触发器。不需要为此触发器创建输出。它会自动触发由其'Soundscape'属性引用的声景。"
    [
    soundscape(target_source) : "声景"
    ]

@SolidClass base(Trigger) 
    line(255 255 255, targetname, filtername)
    line(255 255 0, targetname, target)
    line(0 255 0, target, landmark)
= trigger_teleport: "一个触发体积，触发后将接触它的实体传送。实体被传送到远程目的地，并将其角度设置为远程目的地的角度。如果指定了本地目的地地标，则传送的实体会根据它们最初与地标的偏移量相对于目标进行偏移，其角度保持不变。"
    [
    target(target_destination) : "远程目的地" : : "指定应传送实体到达的点的实体。"
    landmark(target_destination) : "本地目的地地标" : : "如果指定，则传送的实体会根据它们最初与地标的偏移量相对于目标进行偏移。"
    spawnflags(flags)  =
        [
        32: "[32] 即使没有指定本地地标也保留角度" : 0
        1: "[1] 客户端/玩家" : 1
        2: "[2] NPC" : 0
        4: "[4] func_pushable" : 0
        8: "[8] 物理对象" : 0
        16: "[16] 仅玩家盟友NPC" : 0
        64: "[64] 一切（不包括物理碎片）" : 0
        512: "[512] 仅不在车辆中的客户端" : 0
        1024: "[1024] 物理碎片" : 0
        2048: "[2048] 仅在车辆中的NPC（尊重玩家盟友标志）" : 0
        4096: "[4096] 正确计算对象质量（trigger_push曾假设为100公斤）和多组分物理对象（汽车，斑点...）" : 1
        ]

    ]

@SolidClass base(Trigger, EnableDisable) 
    line(255 255 255, targetname, filtername)
= trigger_togglesave: "一个触发体积，每次玩家接触它时都会自动保存。触发后，必须启用它才能再次激活。"
    [
    ]

@SolidClass base(Trigger) 
    line(255 255 255, targetname, filtername)
= trigger_tonemap: "为接触触发器的玩家更改色调映射控制器。"
    [
    tonemapname(target_destination) : "色调映射名称" : : "与此触发器相关联的色调映射控制器实体的名称。"
    ]

@SolidClass base(Trigger) 
    line(255 255 255, targetname, filtername)
= trigger_upgrade_laser_sight: "为接触的玩家提供激光瞄准升级。"
    [
    ]

@SolidClass base(Trigger) 
    line(255 255 255, targetname, filtername)
= trigger_vphysics_motion: "一个影响接触它的vphysics对象运动的体积触发器。"
    [
    spawnflags(flags)  =
        [
        4096: "[4096] 可移动（通过层级附加）" : 0
        ]

setgravityscale(float) : "重力比例" : "1.0" : "按此比例缩放场中物体的重力。"
setadditionalairdensity(float) : "额外空气密度用于阻力" : 0
setvelocitylimit(float) : "速度限制" : "0.0" : "场中最大速度（0为禁用）"
setvelocitylimitdelta(float) : "速度限制力" : "0.0" : "当速度超过限制时每秒减少的最大速度量（0为禁用）"
setvelocityscale(float) : "速度比例/阻力" : "1.0"
setangvelocitylimit(float) : "角速度限制" : "0.0" : "场中最大角速度（度/秒，0为禁用）"
setangvelocityscale(float) : "角速度比例/阻力" : "1.0"
setlinearforce(float) : "线性力" : "0.0" : "在触发器中施加的力的量（0为禁用）"
setlinearforceangles(angle) : "力的方向" : "0 0 0" : "线性力的方向（俯仰偏航滚转或YZX）"
particletrailmaterial(material) : "粒子尾迹材料" : : "用于粒子尾迹的材料名，无名则无粒子尾迹"
particletraillifetime(float) : "粒子尾迹生命周期" : 4 : "发射粒子的生命周期"
particletrailstartsize(float) : "粒子尾迹起始尺寸" : 2 : "发射粒子的起始尺寸"
particletrailendsize(float) : "粒子尾迹结束尺寸" : 3 : "发射粒子的结束尺寸"

// 输入
input SetGravityScale(float) : "设置场中物体的重力比例。"
input SetAdditionalAirDensity(float) : "额外空气密度用于阻力"
input SetVelocityLimit(float) : "设置场中最大速度。"
input SetVelocityLimitDelta(float) : "每秒减少的最大速度量"
input SetVelocityLimitTime(string) : "接受两个参数：第一个是新的速度限制，第二个是达到该值所需的时间"
input SetVelocityScale(float) : "速度比例/阻力"
input SetAngVelocityLimit(float) : "设置场中最大角速度。"
input SetAngVelocityScale(float) : "角速度比例/阻力"
input SetLinearForce(float) : "线性力（0为禁用）"
input SetLinearForceAngles(vector) : "设置力的方向。"
]

@SolidClass base(Trigger, Angles) 
    line(255 255 255, targetname, filtername)
= trigger_wind: "一个触发体积，推动接触它的物理对象。"
    [
    speed(integer) : "速度" : 200 : "风力强度的基线。"
    speednoise(integer) : "速度噪声" : 0 : "风速的噪声 +/-"
    directionnoise(integer) : "方向噪声" : 10 : "风向的噪声。"
    holdtime(integer) : "保持时间" : 0 : "改变风之前等待的基线时间。"
    holdnoise(integer) : "保持噪声" : 0 : "改变风之前等待时间的噪声。"

    // 输入
    input SetSpeed(integer) : "设置风力强度的基线。"
    ]

@PointClass base(WeaponSpawnSingle) 
    sphere(fademindist)
    sphere(fademaxdist)
    color(0 0 200)
    studioprop("models/w_models/weapons/w_eq_adrenaline.mdl")
= weapon_adrenaline_spawn: "肾上腺素"
    [
    ]

@PointClass base(WeaponSpawnSingle) 
    sphere(fademindist)
    sphere(fademaxdist)
    color(0 0 200)
    studioprop("models/w_models/weapons/w_eq_defibrillator.mdl")
= weapon_defibrillator_spawn: "除颤器"
    [
    ]

@PointClass base(WeaponSpawnSingle) 
    sphere(fademindist)
    sphere(fademaxdist)
    color(0 0 200)
    studioprop("models/w_models/weapons/w_eq_Medkit.mdl")
= weapon_first_aid_kit: "物理急救箱 - 此实体用于脚本事件中，需要生成带有物理活动的单个物品。"
    [
    ]

@PointClass base(WeaponSpawnSingle) 
    sphere(fademindist)
    sphere(fademaxdist)
    color(0 0 200)
    studioprop("models/w_models/weapons/w_eq_Medkit.mdl")
= weapon_first_aid_kit_spawn: "急救箱"
    [
    ]

@PointClass base(WeaponSpawnSingle) 
    sphere(fademindist)
    sphere(fademaxdist)
    color(0 0 200)
    studioprop("models/props_junk/gascan001a.mdl")
= weapon_gascan_spawn: "汽油桶"
    [
    ]

@PointClass base(WeaponSpawnSingle) 
    sphere(fademindist)
    sphere(fademaxdist)
    color(0 0 200)
    studioprop("models/w_models/weapons/w_grenade_launcher.mdl")
= weapon_grenade_launcher: "榴弹发射器 - 此实体用于脚本事件中，需要生成带有物理活动的单个物品。"
    [
    ]

@PointClass base(WeaponSpawnSingle) 
    sphere(fademindist)
    sphere(fademaxdist)
    color(0 0 200)
    iconsprite("editor/weapon_item_spawn")
= weapon_item_spawn
    [
    item1(integer) : "弹药堆" : 1
    item2(integer) : "急救箱" : 0
    item3(integer) : "燃烧瓶" : 1
    item4(integer) : "止痛药" : 1
    item5(integer) : "管状炸弹" : 1
    item6(integer) : "氧气瓶" : 0
    item7(integer) : "丙烷罐" : 0
    item8(integer) : "汽油桶" : 0
    item11(integer) : "肾上腺素" : 1
    item12(integer) : "除颤器" : 0
    item13(integer) : "喷吐者胆汁" : 0
    item16(integer) : "电锯" : 0
    item17(integer) : "榴弹发射器" : 0
    item18(integer) : "M60机枪" : 0
    melee_weapon(string) : "近战武器" : : "选项：'Any' 或逗号分隔的近战武器脚本名。留空则无。"
    ]

@PointClass base(WeaponSpawnSingle) 
    sphere(fademindist)
    sphere(fademaxdist)
    color(0 0 200)
    studioprop("models/w_models/weapons/w_eq_painpills.mdl")
= weapon_pain_pills_spawn: "止痛药"
    [
    ]

@PointClass base(WeaponSpawnSingle) 
    sphere(fademindist)
    sphere(fademaxdist)
    color(0 0 200)
    studioprop("models/props_junk/gascan001a.mdl")
= weapon_scavenge_item_spawn: "搜集物品"
    [
    glowstate(choices) : "初始发光状态" : 3 =
        [
        0: "关闭"
        3: "开启"
        ]


    // 输入
    input SpawnItem(void) : "生成搜集模式的物品实例。"
    input TurnGlowsOn(void) : "所有当前和未来生成的物品都应发光。"
    input TurnGlowsOff(void) : "所有当前和未来生成的物品都不应发光。"

    // 输出
    output OnItemPickedUp(void) : "当这个生成器的搜集物品被玩家拾取时触发。"
    ]

@PointClass base(WeaponSpawnSingle) 
    sphere(fademindist)
    sphere(fademaxdist)
    color(0 0 200)
    studioprop("models/w_models/weapons/w_eq_explosive_ammopack.mdl")
= weapon_upgradepack_explosive_spawn: "升级包 - 爆炸性"
    [
    ]

@PointClass base(WeaponSpawnSingle) 
    sphere(fademindist)
    sphere(fademaxdist)
    color(0 0 200)
    studioprop("models/w_models/weapons/w_eq_incendiary_ammopack.mdl")
= weapon_upgradepack_incendiary_spawn: "升级包 - 燃烧性"
    [
    ]

@SolidClass base(func_breakable) 
    sphere(fademindist)
    sphere(fademaxdist)
    sphere(exploderadius)
    quadbounds()
= func_breakable_surf: "一个可破坏的表面，用于部分可破坏的玻璃/瓷砖等。除了期望可见的那一面外，所有面都必须标记为NODRAW，并且那面必须是四边形。应用于可见面的材料必须设置为可破坏的。"
    [
    spawnflags(flags)  =
        [
        1: "[1] 物理损伤贴图" : 0
        2: "[2] 受持有物体损伤" : 0
        4: "[4] 播放破碎声音" : 0
        ]

    health(integer) : "生命值" : 5 : "表面在破碎前承受的伤害量。"
    fragility(integer) : "脆弱性" : 100 : "如果'表面类型'设置为玻璃，此值设置破碎后玻璃碎片的脆弱度。较低的值使玻璃碎片趋向于更稳定。"
    surfacetype(choices) : "表面类型" : 0 : "设置固体的行为。玻璃碎裂成多种尺寸，并且容易破碎。瓷砖只沿边缘破碎，并且破碎后仍然坚固。" =
        [
        0: "玻璃"
        1: "瓷砖"
        ]

    lowerleft(vecline) readonly : "左下角（只读）" : : "由Hammer在保存时自动设置。"
    lowerright(vecline) readonly : "右下角（只读）" : : "由Hammer在保存时自动设置。"
    upperleft(vecline) readonly : "左上角（只读）" : : "由Hammer在保存时自动设置。"
    upperright(vecline) readonly : "右上角（只读）" : : "由Hammer在保存时自动设置。"
    error(choices) readonly : "面错误" : 0 : "由Hammer设置，以指示无效的玻璃/瓷砖表面。" =
        [
        0: "无错误"
        1: "多重纹理面"
        2: "非方形面"
        ]


    // 输入
    input Shatter(vector) : "打碎窗户。输入一个向量。前两个坐标是打碎的X,Y中心（从0-1的值）。第三个坐标是打碎的半径，以单位为单位。"
    ]

@SolidClass base(func_breakable) 
    sphere(fademindist)
    sphere(fademaxdist)
    sphere(exploderadius)
= func_physbox: "一个物理模拟的固体实体。"
    [
    spawnflags(flags)  =
        [
        16384: "[16384] 碎片 - 不与玩家或其他碎片碰撞" : 0
        32768: "[32768] 禁用运动" : 0
        65536: "[65536] 使用首选携带角度" : 0
        131072: "[131072] 在Physcannon抓取时启用运动" : 0
        262144: "[262144] 忽略+USE进行拾取" : 0
        524288: "[524288] 在+USE时生成输出" : 1
        1048576: "[1048576] 开始时休眠" : 0
        2097152: "[2097152] 物理枪不允许拾取此物。" : 0
        4194304: "[4194304] 物理枪不允许踢飞此物体。" : 0
        8388608: "[8388608] 防止玩家碰撞时启用运动" : 0
        ]

    damagetype(choices) : "冲击伤害类型" : 0 =
        [
        0: "钝器"
        1: "锐器"
        ]

    massscale(float) : "质量比例" : 0 : "物体质量的比例乘数。"
    ha_override_mass(float) : "[HA] 质量覆盖" : : "如果设置，后编译器将修改固体数据，直接将其设置为此质量值。"
    overridescript(string) : "覆盖参数" : : "通常在物理道具.qc文件中的一系列物理键/值对。格式是'key,value,key,value,etc'。"
    damagetoenablemotion(integer) : "健康水平以覆盖运动" : 0 : "如果指定，此物体将开始时禁用运动。一旦其健康值降低到指定量以下，它将启用运动。"
    forcetoenablemotion(float) : "物理冲击力以覆盖运动" : 0 : "如果指定，此物体将开始时禁用运动。任何对physbox施加的力大于此值的冲击都将启用运动。"
    health(integer) : "强度" : 0 : "受到的伤害点数，在破碎之前。0意味着不破碎。"
    preferredcarryangles(vector) : "首选玩家携带角度" : "0 0 0" : "如果设置了'使用首选携带角度'的spawnflag，这个角度是物体在玩家用physgun或+USE拾起时应该定位的角度。"
    notsolid(choices) : "对世界不实体" : 0 =
        [
        0: "对世界实体"
        1: "穿过世界"
        ]

exploitablebyplayer(choices) : "玩家可利用" : 0 =
        [
        0: "默认"
        1: "爆炸性"
        ]


    // 输入
    input Wake(void) : "如果这个物理对象正在休眠，唤醒它。"
    input Sleep(void) : "让这个物理对象休眠。如果给予唤醒输入，或者有力作用于它，它将醒来。注意物理对象在静止一段时间后会自动休眠，所以你不真的需要使用这个。"
    input EnableMotion(void) : "启用物理运动/碰撞响应。"
    input DisableMotion(void) : "禁用物理运动/碰撞响应。"
    input ForceDrop(void) : "如果这个对象被玩家携带，使用物理枪或+USE，强制它被放下。"
    input DisableFloating(void) : "禁用流体/浮动模拟以减少成本。"

    // 输出
    output OnDamaged(void) : "当这个实体受到伤害时触发。"
    output OnAwakened(void) : "当这个实体被唤醒（应用碰撞/力）时触发。"
    output OnMotionEnabled(void) : "由于受到伤害/物理枪/力的作用，运动被启用时触发。"
    output OnPhysGunPickup(void) : "当玩家用物理枪或+USE拾起这个对象时触发。"
    output OnPhysGunPunt(void) : "当玩家用物理枪踢这个对象时触发。"
    output OnPhysGunOnlyPickup(void) : "当玩家仅用物理枪拾起这个对象时触发。+USE拾起不触发这个输出。"
    output OnPhysGunDrop(void) : "当玩家放下这个对象时触发。"
    output OnPlayerUse(void) : "当玩家尝试+USE物理箱时触发。只有当设置了在+USE生成输出的生成标志时，这个输出才会触发。"
    ]

@SolidClass base(func_breakable) 
    sphere(fademindist)
    sphere(fademaxdist)
    sphere(exploderadius)
= func_pushable: "一个可以被推动的带有原始物理的刷子。"
    [
    size(choices) : "外壳大小" : 0 =
        [
        0: "点大小"
        1: "玩家大小"
        2: "大号大小"
        3: "玩家蹲伏"
        ]

    spawnflags(flags)  =
        [
        1: "[1] 仅在触发器上破坏" : 0
        2: "[2] 触碰即破坏" : 0
        4: "[4] 压力破坏" : 0
        512: "[512] 物理立即破坏" : 0
        1024: "[1024] 不受物理伤害" : 0
        2048: "[2048] 不允许子弹穿透" : 0
        128: "[128] 可破坏的" : 0
        ]

    friction(float) : "摩擦力" : 50 : "这决定了玩家推动刷子时它会给出多少阻力。范围是0到400，其中400是最大的阻力。"
    ]

@SolidClass base(func_platrot) 
    sphere(fademindist)
    sphere(fademaxdist)
    line(255 255 255, targetname, train)
    line(0 255 0, targetname, toptrack)
    line(0 0 255, targetname, bottomtrack)
= func_trackchange: "一个作为旋转/移动平台的实体，将火车运送到新的轨道。它必须在X-Y平面区域比火车大，因为它必须在火车靠近时包含火车在这些尺寸内才能操作。轨道将围绕自己的原点旋转。与这个实体类似的变体是func_trackautochange，然而你不能触发func_trackautochange，除非路径轨道是死胡同。如果勾选了自动激活火车标志，火车在func_trackchange完成其运动后不会在路径的顶部/底部暂停。相反，它将继续前进，不需要通过触发器重新激活。如果选中，平台仅在其原点的位置旋转，不需要移动指定的高度。顶部和底部的路径轨道应该将它们的原点定位在相同的坐标中。"
    [
    height(integer) : "旅行高度" : 0 : "从顶部到底部的旅行距离。如果选择了从底部开始的标志，旅行距离不会从底部变到顶部，它只会使平台从底部开始并等待func_tracktrain到达。"
    rotation(integer) : "旋转量" : 0 : "这个平台在移动时应该旋转的角度量，以度为单位。"
    train(target_destination) : "要切换的火车" : : "这个平台将运送到顶部/底部轨道的func_tracktrain的名称。"
    toptrack(target_destination) : "顶部轨道" : : "顶部路径的最后一个路径轨道的名称（如果选择了从底部开始的标志，这是顶部路径的第一个路径轨道的名称）。"
    bottomtrack(target_destination) : "底部轨道" : : "底部轨道的第一个路径轨道的名称（如果选择了从底部开始的标志，这是底部路径的最后一个路径轨道的名称）。"
    speed(integer) : "移动/旋转速度" : 0 : "func_trackchange穿越整个上升/下降路径的速度（单位每秒）。"
    spawnflags(flags)  =
        [
        1: "[1] 自动激活火车 - 见描述" : 0
        2: "[2] 重连轨道" : 0
        8: "[8] 从底部开始 - 如果勾选了这个标志，平台将从底部开始而不是从顶部路径轨道开始" : 0
        16: "[16] 仅旋转 - 见描述" : 0
        64: "[64] X轴 - 火车围绕X轴而不是Z轴旋转。可以与Y轴结合使用" : 0
        128: "[128] Y轴 - 火车围绕Y轴而不是Z轴旋转。可以与X轴结合使用" : 0
        ]


    // 输入
    input Trigger(void) : "触发轨道变更。"
    ]

@SolidClass base(func_door) 
    sphere(fademindist)
    sphere(fademaxdist)
    line(255 255 255, targetname, master)
    line(255 255 255, targetname, chainstodoor)
= func_water: "带有水体碰撞物理的func_door特殊变体。"
    [
    ]

@PointClass base(BaseNPC, SetModel) 
    sphere(fademindist)
    sphere(fademaxdist)
    color(0 200 200)
    studioprop()
= generic_actor: "通用演员NPC"
    [
    hull_name(choices) : "外壳类型" : "HUMAN_HULL" =
        [
        "HUMAN_HULL": "人类"
        "WIDE_HUMAN_HULL": "宽体"
        "TINY_HULL": "微型"
        "MEDIUM_HULL": "中型"
        "LARGE_HULL": "大型"
        ]

    defaultanim(string) : "默认动画" : : "这个道具在完成一个随机或强制动画后恢复到的空闲动画的名称。"
    randomanimation(choices) : "随机动画" : 0 : "如果设置，这个道具将基于最小/最大随机动画时间指定的时间随机选择并播放动画。在随机动画之间，它将恢复播放'默认动画'。" =
        [
        0: "否"
        1: "是"
        ]

    ]

@PointClass base(BaseNPC) 
    sphere(fademindist)
    sphere(fademaxdist)
    color(0 200 200)
    studio()
    bbox(-4 -4 -4, 4 4 4)
= monster_generic: "通用脚本NPC"
    [
    spawnflags(flags)  =
        [
        65536: "[65536] 非实体" : 0
        ]

    model(studio) : "模型"
    body(integer) : "身体" : 0
    ]

@PointClass base(BaseNPC, SetModel) 
    sphere(fademindist)
    sphere(fademaxdist)
    color(0 200 200)
    studio()
= npc_furniture: "用于需要在scripted_sequence中与NPC同步动画的非NPC实体。通常是一个家具或门，NPC需要在scripted_sequence中操作。"
    [

    // 输入
    input DisablePlayerCollision(void) : "禁用与玩家的碰撞。"
    input EnablePlayerCollision(void) : "启用与玩家的碰撞。"
    ]

@PointClass base(prop_physics, EnableDisable) 
    studioprop()
    sphere(fademindist)
    sphere(fademaxdist)
= prop_car_alarm: "这个类与prop_physics相同，带有汽车警报。"
    [

    // 输出
    output OnCarAlarmStart(void) : "汽车警报应该启动"
    output OnCarAlarmEnd(void) : "汽车警报已关闭"
    output OnCarAlarmChirpStart(void)
    output OnCarAlarmChirpEnd(void)
    ]

@PointClass base(prop_dynamic) 
    studioprop()
    sphere(fademindist)
    sphere(fademaxdist)
= prop_car_glass: "这个类与prop_dynamic相同，带有汽车警报。"
    [
    ]

@PointClass base(prop_door_rotating) 
    sphere(exploderadius)
    sphere(fademindist)
    sphere(fademaxdist)
    studioprop()
= prop_door_rotating_checkpoint: "用于在世界中放置特殊检查点门的实体。"
    [
    ]

@PointClass base(prop_physics) 
    studioprop()
    sphere(fademindist)
    sphere(fademaxdist)
= prop_physics_multiplayer: "这个类与prop_physics相同，除了运行时碰撞使用一种更有弹性的方法，避免了普通物理对象得到的预测错误。"
    [
    physicsmode(choices) : "物理模式" : 0 =
        [
        0: "自动检测"
        1: "实体，服务器端"
        2: "非实体，服务器端"
        3: "非实体，客户端"
        ]

    ]

@PointClass base(prop_physics) 
    studioprop()
    sphere(fademindist)
    sphere(fademaxdist)
= prop_physics_override: "prop_physics的一个变体，它将允许使用没有编译物理数据的模型，如静态或动态模型。健康和物理数据可以在这个版本上被覆盖，以代替缺失的信息。"
    [
    health(integer) : "健康" : 0 : "在破坏之前需要承受的伤害点数。0表示不破坏。"
    ]

@PointClass base(prop_physics) 
    sphere(fademindist)
    sphere(fademaxdist)
    studioprop()
= prop_physics_respawnable: "这个类与prop_physics相同，除了它在破碎后会重新出现"
    [
    respawntime(float) : "重新出现时间" : 60 : "这个道具在破碎后重新出现的秒数。"

    // 输入
    input InputRespawn(void) : "强制重生。"

    // 输出
    output OnMaterialize(void) : "道具已实体化"
    ]

@SolidClass base(trigger_hurt) 
    line(255 255 255, targetname, filtername)
    line(255 255 255, targetname, master)
= trigger_hurt_ghost: "一个触发区域，触碰它的实体（和幽灵）会受到伤害。"
    [
    ]

@PointClass base(WeaponSpawn, SetModel) 
    color(0 0 200)
    studioprop()
= weapon_ammo_spawn: "弹药"
    [
    ]

@PointClass base(WeaponSpawn) 
    color(0 0 200)
    studioprop("models/w_models/Weapons/w_autoshot_m4super.mdl")
= weapon_autoshotgun_spawn: "自动霰弹枪"
    [
    ]

@PointClass base(WeaponSpawn) 
    color(0 0 200)
    studioprop("models/weapons/melee/w_chainsaw.mdl")
= weapon_chainsaw_spawn: "电锯"
    [
    ]

@PointClass base(WeaponSpawn) 
    color(0 0 200)
    studioprop("models/w_models/weapons/w_grenade_launcher.mdl")
= weapon_grenade_launcher_spawn: "榴弹发射器"
    [
    ]

@PointClass base(WeaponSpawn) 
    color(0 0 200)
    studioprop("models/w_models/Weapons/w_sniper_mini14.mdl")
= weapon_hunting_rifle_spawn: "狩猎步枪"
    [
    ]

@PointClass base(WeaponSpawn) 
    color(0 0 200)
    studioprop("models/weapons/melee/w_fireaxe.mdl")
= weapon_melee_spawn: "近战武器"
    [
    melee_weapon(string) : "近战武器" : "any" : "选项：'Any' 或逗号分隔的近战武器脚本名称字符串。留空则为无。"
    ]

@PointClass base(WeaponSpawn) 
    color(0 0 200)
    studioprop("models/w_models/weapons/w_eq_molotov.mdl")
= weapon_molotov_spawn: "燃烧瓶"
    [
    ]

@PointClass base(WeaponSpawn) 
    color(0 0 200)
    studioprop("models/w_models/weapons/w_eq_pipebomb.mdl")
= weapon_pipe_bomb_spawn: "管状炸弹"
    [
    ]

@PointClass base(WeaponSpawn) 
    color(0 0 200)
    studioprop("models/w_models/Weapons/w_desert_eagle.mdl")
= weapon_pistol_magnum_spawn: "马格南手枪"
    [
    ]

@PointClass base(WeaponSpawn) 
    color(0 0 200)
    studioprop("models/w_models/Weapons/w_pistol_a.mdl")
= weapon_pistol_spawn: "手枪"
    [
    ]

@PointClass base(WeaponSpawn) 
    color(0 0 200)
    studioprop("models/w_models/Weapons/w_shotgun.mdl")
= weapon_pumpshotgun_spawn: "泵动霰弹枪"
    [
    ]

@PointClass base(WeaponSpawn) 
    color(0 0 200)
    studioprop("models/w_models/Weapons/w_rifle_ak47.mdl")
= weapon_rifle_ak47_spawn: "AK47"
    [
    ]

@PointClass base(WeaponSpawn) 
    color(0 0 200)
    studioprop("models/w_models/Weapons/w_rifle_B.mdl")
= weapon_rifle_desert_spawn: "沙漠步枪"
    [
    ]

@PointClass base(WeaponSpawn) 
    color(0 0 200)
    studioprop("models/w_models/Weapons/w_m60.mdl")
= weapon_rifle_m60_spawn: "M60机枪"
    [
    ]

@PointClass base(WeaponSpawn) 
    color(0 0 200)
    studioprop("models/w_models/Weapons/w_rifle_sg552.mdl")
= weapon_rifle_sg552_spawn: "SG552"
    [
    ]

@PointClass base(WeaponSpawn) 
    color(0 0 200)
    studioprop("models/w_models/Weapons/w_rifle_m16a2.mdl")
= weapon_rifle_spawn: "突击步枪"
    [
    ]

@PointClass base(WeaponSpawn) 
    color(0 0 200)
    studioprop("models/w_models/Weapons/w_pumpshotgun_A.mdl")
= weapon_shotgun_chrome_spawn: "镀铬霰弹枪"
    [
    ]

@PointClass base(WeaponSpawn) 
    color(0 0 200)
    studioprop("models/w_models/Weapons/w_shotgun_spas.mdl")
= weapon_shotgun_spas_spawn: "SPAS霰弹枪"
    [
    ]

@PointClass base(WeaponSpawn) 
    color(0 0 200)
    studioprop("models/w_models/Weapons/w_smg_mp5.mdl")
= weapon_smg_mp5_spawn: "MP5"
    [
    ]

@PointClass base(WeaponSpawn) 
    color(0 0 200)
    studioprop("models/w_models/Weapons/w_smg_uzi.mdl")
= weapon_smg_silenced_spawn: "微型UZI"
    [
    ]

@PointClass base(WeaponSpawn) 
    color(0 0 200)
    studioprop("models/w_models/Weapons/w_smg_uzi.mdl")
= weapon_smg_spawn: "冲锋枪"
    [
    ]

@PointClass base(WeaponSpawn) 
    color(0 0 200)
    studioprop("models/w_models/Weapons/w_sniper_awp.mdl")
= weapon_sniper_awp_spawn: "AWP狙击步枪"
    [
    ]

@PointClass base(WeaponSpawn) 
    color(0 0 200)
    studioprop("models/w_models/Weapons/w_sniper_military.mdl")
= weapon_sniper_military_spawn: "军用狙击步枪"
    [
    ]

@PointClass base(WeaponSpawn) 
    color(0 0 200)
    studioprop("models/w_models/Weapons/w_sniper_scout.mdl")
= weapon_sniper_scout_spawn: "侦察兵狙击步枪"
    [
    ]

@PointClass base(WeaponSpawn) 
    color(0 0 200)
    studioprop("models/w_models/Weapons/w_rifle_m16a2.mdl")
= weapon_spawn: "可配置武器生成器"
    [
    weapon_selection(choices) : "选择" : "any_primary" : "生成选定的武器或武器类别" =
        [
        "any": "任意主武器或副武器"
        "any_pistol": "任意手枪"
        "weapon_pistol": "手枪"
        "weapon_pistol_magnum": "马格南手枪"
        "any_primary": "任意主武器"
        "tier1_any": "任意一级主武器"
        "tier2_any": "任意二级主武器"
        "any_smg": "任意一级冲锋枪"
        "any_rifle": "任意二级步枪"
        "any_sniper_rifle": "任意二级狙击步枪"
        "any_shotgun": "任意霰弹枪"
        "tier1_shotgun": "任意一级霰弹枪"
        "tier2_shotgun": "任意二级霰弹枪"
        "weapon_smg": "冲锋枪"
        "weapon_smg_silenced": "消音冲锋枪"
        "weapon_pumpshotgun": "泵动霰弹枪"
        "weapon_shotgun_chrome": "镀铬霰弹枪"
        "weapon_autoshotgun": "自动霰弹枪"
        "weapon_shotgun_spas": "SPAS霰弹枪"
        "weapon_rifle": "M4步枪"
        "weapon_rifle_desert": "沙漠步枪"
        "weapon_rifle_ak47": "AK47"
        "weapon_hunting_rifle": "狩猎步枪"
        "weapon_sniper_military": "军用狙击步枪"
        "weapon_smg_mp5": "MP5"
        "weapon_rifle_sg552": "SG552"
        "weapon_sniper_awp": "AWP狙击步枪"
        "weapon_sniper_scout": "侦察兵狙击步枪"
        ]

    spawn_without_director(choices) : "无导演立即生成" : 0 : "绕过近距离检查，使附近的武器为相同等级/不为相同武器。" =
        [
        0: "否"
        1: "是"
        ]

    no_cs_weapons(choices) : "无CS武器" : 0 : "当选择'任意'武器时，如果您不想要CS武器，请将此设置为真。" =
        [
        0: "否"
        1: "是"
        ]

    spawnflags(flags)  =
        [
        16: "[16] 限制于生成位置（不落到地面）" : 0
        ]

    ]

@PointClass base(WeaponSpawn) 
    color(0 0 200)
    studioprop("models/w_models/weapons/w_eq_bile_flask.mdl")
= weapon_vomitjar_spawn: "呕吐罐"
    [
    ]

@SolidClass base(func_physbox) 
    sphere(fademindist)
    sphere(fademaxdist)
    sphere(exploderadius)
= func_physbox_multiplayer: "此类与func_physbox相同，不同的是运行时碰撞使用了一种更有弹性的方法，避免了普通物理对象获取的预测错误。"
    [
    ]

@SolidClass base(func_trackchange) 
    line(255 255 255, targetname, train)
    line(0 255 0, targetname, toptrack)
    line(0 0 255, targetname, bottomtrack)
= func_trackautochange: "一个作为旋转/移动平台的实体，将火车带到新轨道上。它必须在X-Y平面区域内比火车大，因为它必须在这些维度内包含火车才能在火车接近时操作。轨道将绕其原点旋转。此实体只有在火车处于死胡同的路径轨道上时才允许被触发。如果选中了自动激活火车标志，那么func_trackautochange完成移动后，火车不会在路径的顶部/底部暂停。相反，它将继续向前移动，无需重新激活触发器。如果选择，平台只会在其原点旋转而不移动指定的高度。顶部和底部的路径轨道应该将它们的原点定位在相同的坐标中。"
    [
    ]

@PointClass base(npc_furniture) 
    studio()
= monster_furniture: "npc_furniture的别称。"
    [
    ]